## API service
- `cmd/api/main` loads config, boots Stripe via `pkg/stripe.NewClient` (missing/invalid API key, secret, or env exits before other services), runs dev migrations (`MaybeRunDev`), starts Postgres/Redis/GCS, the session manager, domain services, and finally runs `routes.NewRouter` on `http.Server.ListenAndServe` (cmd/api/main.go:33-80; pkg/stripe/client.go:33-119; pkg/migrate/autorun.go:12-34).
- `routes.NewRouter` wires `Recoverer`, `RequestID`, `Logging`, `Auth`, `StoreContext`, `Idempotency`, and `RateLimit` middleware, then mounts health, public, `/api` (store/media/licenses), `/api/admin`, and `/api/v1/agent` groups (api/routes/router.go:17-106). The `/api/v1/agent` group lives under `/api` so it can reuse auth + role middleware while skipping `StoreContext` when needed; inside it agents hit `/orders/queue`, `/orders`, and `/orders/{orderId}` to see the dispatch queue or their personal assignments.
- `/api/v1/vendor/analytics` sits under `/api/v1/vendor`; `StoreContext` plus the `StoreType=vendor` guard ensure only vendor stores reach it, `controllers.VendorAnalytics` resolves either a `preset` (7d/30d/90d, default 30d) or RFC3339 `from`/`to` range, and it calls `internal/analytics.Service.VendorAnalytics` so KPIs and per-day aggregates (orders, revenue, AOV, cash collected) come straight from BigQuery (`api/routes/router.go`:48-69; `api/controllers/analytics/vendor.go`:16-58; `internal/analytics/service.go`:1-200).
- `GET /ads/serve`, `POST /ads/impression`, and `GET /ads/click` implement the Phase 19 ads engine: serve filters active ads + store gating, consults Redis budgets, issues signed tokens with target metadata, and tracks impressions/clicks via Redis counters/dedupe keys while the nightly scheduler sinks totals into `ad_daily_rollups`/`usage_charges` and checkout attribution stamps tokens onto `vendor_orders`/line items so analytics/ROAS flows run on Postgres truth (`docs/AD_ENGINE.md`:30-260).
- `/api/v1/webhooks/stripe` lives under `/api/v1/webhooks`; the controller verifies the `Stripe-Signature`, passes the raw event to `internal/webhooks/stripe.Service`, and relies on `internal/webhooks/stripe.IdempotencyGuard` + Redis so `customer.subscription.*` + `invoice.*` events keep `subscriptions.status` and `stores.subscription_active` synchronized with Stripe without replays (`api/routes/router.go:104-108`; `api/controllers/webhooks/stripe.go:13-82`; `internal/webhooks/stripe/service.go:1-178`; `internal/webhooks/stripe/idempotency.go:1-42`).
- `/api/v1/vendor/subscriptions`, `/api/v1/vendor/subscriptions/cancel`, and the GET variant run under the same vendor guard with `Idempotency-Key` enabled for the POSTs; `api/controllers/subscriptions/vendor.go` resolves the store, validates the Stripe payload, and calls `internal/subscriptions.Service` so Stripe + billing rows stay synchronized, the single-active subscription per store is enforced, and `stores.subscription_active` reflects the current state (`api/controllers/subscriptions/vendor.go:19-154`; `internal/subscriptions/service.go:1-230`; `api/middleware/idempotency.go:37-58`).
- `GET /api/v1/notifications` lives under the `/api` store group, so `middleware.Auth` + `middleware.StoreContext` provide the active store (`StoreIDFromContext`). `controllers.ListNotifications` parses `limit`, `cursor`, and `unreadOnly`, validates the inputs, and calls `notifications.Service.List`, which normalizes the `limit` (default 25, max 100 via `pagination.NormalizeLimit`), applies cursor pagination ordered by `(created_at, id) DESC`, optionally filters `read_at IS NULL`, and returns a `ListResult{items, cursor}` payload (`api/routes/router.go:129-133`; `api/controllers/notifications.go:17-67`; `internal/notifications/service.go:24-79`; `internal/notifications/repo.go:54-75`; `pkg/pagination/pagination.go:12-40`).
- `POST /api/v1/notifications/{notificationId}/read` and `POST /api/v1/notifications/read-all` share the same `/api` store group so `middleware.Idempotency` already injects `Idempotency-Key` and `StoreID`. Each controller validates the store, parses the optional UUID path param, and calls `notifications.Service.MarkRead`/`MarkAllRead`; the service, in turn, applies the `read_at IS NULL` filter before updating and records either a single `read` flag or the number of rows updated, keeping every mutation scoped to the tenant (`api/routes/router.go:129-133`; `api/controllers/notifications.go:69-118`; `internal/notifications/service.go:81-109`; `internal/notifications/repo.go:78-113`; `api/middleware/idempotency.go:37-208`).
- `GET /api/v1/admin/orders/payouts`/`{orderId}` run under the `/api/admin` group; `AdminPayoutOrders` uses `internal/orders.Repository.ListPayoutOrders` (internal/orders/repo.go:561-620) to read delivered/settled/unpaid orders with cursor pagination, and `AdminPayoutOrderDetail` loads `internal/orders.Repository.FindOrderDetail`, rejecting any order that is not delivered or settled before returning the shared `OrderDetail` (api/controllers/admin_orders.go:17-100; internal/orders/repo.go:553-620).
- `POST /api/v1/admin/orders/{orderId}/confirm-payout` lives in the same group; `AdminConfirmPayout` (internal/orders/service.go:847-940) validates the delivered/settled order, updates the payment intent to `paid` with `vendor_paid_at`, closes the vendor order, appends a `vendor_payout` ledger row, and emits `order_paid` via the outbox inside the same transaction so the payout flow is atomic and idempotent.
- `GET /api/v1/agent/orders/queue` sits inside the agent group, exposing the dispatch queue of `status=hold` vendor orders with no active assignment so agents can list work in a paginated fashion. `api/controllers/agent_orders.AgentOrderQueue` reads optional `limit`/`cursor` params, uses `internal/orders.Repository.ListUnassignedHoldOrders` (internal/orders/repo.go:376-433) to left join `order_assignments` and return cursor-paginated summaries ordered by `created_at DESC`, and responds with `AgentOrderQueueList`.
- `GET /api/v1/agent/orders` also lives inside the agent group; `api/controllers.AgentAssignedOrders` binds the Authorization/role guard, parses `limit`/`cursor`, and delegates to `internal/orders.Repository.ListAssignedOrders` (internal/orders/repo.go:376-550) to join `order_assignments` (active = true), filter by the caller’s user ID, and return an `AgentOrderQueueList` of the agent’s active assignments.
- `GET /api/v1/agent/orders/{orderId}` uses `internal/orders.Repository.FindOrderDetail` (internal/orders/repo.go:553-596), the shared detail payload, and the controller’s assignment check so the endpoint only responds when the `ActiveAssignment` belongs to the requesting agent (`api/controllers/agent_assigned_orders.go:60-109`).
- `POST /api/v1/agent/orders/{orderId}/pickup` wires `controllers.AgentPickupOrder` to `internal/orders.Service.AgentPickup` (internal/orders/service.go:641-712); the service ensures the active assignment matches the caller, rejects invalid states with `CodeStateConflict`, stores `order_assignments.pickup_time` (only once) thanks to the new metadata columns (`pkg/migrate/migrations/20260129000000_add_order_assignment_meta.sql`), and promotes `vendor_orders.status`/`shipping_status` to `in_transit`, keeping the idempotent behavior even on retries.
- `POST /api/v1/agent/orders/{orderId}/deliver` routes `controllers.AgentDeliverOrder` to `internal/orders.Service.AgentDeliver` (internal/orders/service.go:724-778); the service demands the assignment belongs to the requester, enforces `vendor_orders.status=in_transit` (rejecting other states with `pkg.errors.CodeStateConflict`), updates `status/shipping_status` to `delivered`, writes `vendor_orders.delivered_at`, and sets `order_assignments.delivery_time`, treating duplicate calls as no-ops once the timestamps are recorded.
- `POST /api/v1/checkout` requires `middleware.Idempotency` (`Idempotency-Key` header, 7d TTL) so the first success (checkout group + vendor orders) is cached while mismatched payloads return `pkg/errors.CodeIdempotency`/HTTP `409`; non-buyer stores hit `pkg/errors.CodeForbidden`/HTTP `403`, the handler decodes `cart_id` + optional `attributed_ad_click_id`, calls `internal/checkout.Service.Execute`, and the response mirrors `checkoutResponse` (`checkout_group_id`, per-vendor `vendor_orders` with totals/items/status/notes, plus `rejected_vendors` that enumerate every rejected line item) (`api/controllers/checkout.go:9-145`; `api/middleware/idempotency.go:37-208`). `pkg/checkout.ValidateMOQ` still runs beforehand so any line item short of the stored `moq` triggers `pkg/errors.CodeStateConflict`/HTTP `422` with a `violations` array (`product_id`, optional `product_name`, `required_qty`, `requested_qty`) that highlights the blocked SKUs (`pkg/checkout/validation.go:11-43`).
- Checkout orchestration leans on deterministic helpers in `internal/checkout/helpers` to group `CartItem`s by `vendor_store_id`, recompute per-vendor totals (subtotals/discounts/totals), validate buyer/vendor eligibility (store type, subscription, state, MOQ), and atomically reserve inventory (`ReserveInventory`) via a conditional UPDATE that decrements `available_qty` while incrementing `reserved_qty` and returns per-line outcomes for partial success before persisting the checkout; the core orchestrator service (PF-080) runs inside `internal/checkout/service.go` with a single transaction per attempt, turning the `CartRecord` into a `CheckoutGroup`, per-vendor `VendorOrders`, and `OrderLineItems`, then marks the cart `converted` (`internal/checkout/helpers/grouping.go` & `internal/checkout/helpers/validation.go`; `internal/checkout/service.go`).
- Checkout orchestration leans on deterministic helpers in `internal/checkout/helpers` to group `CartItem`s by `vendor_store_id`, recompute per-vendor totals (subtotals/discounts/totals), and validate buyer/vendor eligibility (store type, subscription, state, MOQ) before invoking the persistence/services that convert the cart snapshot into checkout entities (`internal/checkout/helpers/grouping.go` & `internal/checkout/helpers/validation.go`).
- Checkout execution hinges on new order data models (`checkout_groups`, `vendor_orders`, `order_line_items`, `payment_intents`) that store the CartRecord snapshot before reservation logic runs, following the schema defined in Doc 4 and built in PF-077.
- `PUT /api/v1/cart` is protected by `middleware.Idempotency` (24h TTL) and calls `internal/cart.Service.UpsertCart`; the service validates the buyer store (verified buyer), vendor visibility (verified + subscription+state), inventory availability, MOQ + volume tiers, subtotal/total math, and cart-level discounts before atomically writing the `cart_record` + `cart_items` snapshot that checkout later consumes (`api/middleware/idempotency.go:45-208`; `internal/cart/service.go:39-209`).
- Buyer product listings (`GET /api/v1/products` and `GET /api/v1/products/{productId}`) reuse `pkg/visibility.EnsureVendorVisible` so only vendors with `stores.kyc_status=verified`, `subscription_active=true`, and `address.state` matching the requested (and buyer's) state are returned; mismatches raise `pkg/errors.CodeValidation`/HTTP `422` or `pkg/errors.CodeNotFound`/HTTP `404`, keeping hidden vendors out of search/detail endpoints (pkg/visibility/visibility.go:11-46).
- `middleware.Auth` validates bearer JWTs via `pkg/auth.ParseAccessToken`, ensures refresh session exists, and injects `user_id`, `store_id`, and `role` into context for the `/api` group (api/middleware/auth.go:23-80).

## Worker loop
- `cmd/worker/main` mirrors the API boot (config, logger, Stripe via `pkg/stripe.NewClient`, DB, Redis, Pub/Sub, GCS) and fails fast when Stripe or secrets misconfigure before assembling the `Service` that runs until cancellation (cmd/worker/main.go:30-185; pkg/stripe/client.go:33-119).
- `cmd/worker/service.go` ensures every dependency is non-nil (Stripe included) and `ensureReadiness` pings DB/Redis/PubSub/GCS before launching `media.Consumer.Run` and `notificationConsumer.Run`; `pingStripe` simply verifies the injected client is initialized so startup never proceeds without the Stripe surface (`cmd/worker/service.go`:33-124).
- `internal/schedulers/licenses.Service` is started from the worker to run every 24h, warn stores 14d ahead of `expiration_date`, expire licenses when due, mirror store KYC, and emit `license_status_changed` outbox events for both warnings and expirations (`internal/schedulers/licenses/service.go:1-220`).
- `internal/media/consumer.Consumer` listens to `pubsub.MediaSubscription()`, decodes `OBJECT_FINALIZE` JSON payloads, and marks matching media rows uploaded, nacking on transient DB timeouts (internal/media/consumer/consumer.go:30-235).
- `cmd/media_deleted_worker/main` boots config/db/pubsub, subscribes to `pubsub.MediaDeletionSubscription()` (projects/packfinderz/subscriptions/media-deleted-sub), parses the GCS `OBJECT_DELETE` JSON_API_V1 payload to map `object.name` → `gcs_key` → `media_id`, loads that media's `media_attachments`, and feeds them to `internal/media/consumer.DeletionConsumer`, which detaches each attachment in a deterministic order (per-domain hooks run before mutation), deletes the rows only after successful detachment, and keeps the consumer idempotent so duplicate deliveries are safe (cmd/media_deleted_worker/main.go:1-70; internal/media/consumer/deletion_consumer.go:1-200).
- `internal/notifications/consumer.Consumer` (wired in `cmd/worker/main.go` with the domain subscription and `pkg/outbox/idempotency.Manager`) watches `license_status_changed` events, deduplicates via Redis, and creates `NotificationTypeCompliance` rows for pending, verified, and rejected statuses so admins/stores get compliance notices (internal/notifications/consumer.go:18-197; cmd/worker/main.go:83-116).

## Cron worker
- `cmd/cron-worker/main` mirrors the shared bootstrap (config, logger, DB, Redis), flips `cfg.Service.Kind` to `cron-worker`, runs dev migrations when `PACKFINDERZ_APP_ENV=dev`/`PACKFINDERZ_AUTO_MIGRATE=true`, and then hands control to `internal/cron.Service` via a registry, a Redis lock, and Prometheus metrics so the scheduler can log/metric every run even before domain jobs exist (`cmd/cron-worker/main.go`:13-112; `pkg/migrate/autorun.go`:12-34).
- The cron service keeps a 24h ticker, acquires `pf:cron-worker:lock:<env>` via `cron.NewRedisLock`, logs leadership handoffs, and iterates over `cron.Registry.Jobs()` while emitting `job start`, `job completed`, and `job failed` logs plus `duration_ms` so every job run is observable; job failures never stop the next job or the next cycle (`internal/cron/service.go`:14-154).
- `internal/cron.Registry` exposes `NewRegistry`, `Register`, and `Jobs()` so callers can add named jobs safely, `internal/cron.Lock` abstracts the Redis lease, and `pkg/metrics.CronJobMetrics` increments `job_duration_seconds`, `job_success`, and `job_failure` per job (`internal/cron/registry.go`:11-38; `internal/cron/lock.go`:1-80; `pkg/metrics/cron.go`:16-40). The cron worker currently builds the registry without jobs, so it simply exercises the lock/metrics plumbing until business jobs register themselves (`cmd/cron-worker/main.go`:73-112).

## Outbox publisher
- `cmd/outbox-publisher/main` boots config/logging/DB/PubSub, instantiates `outbox.Repository`, and runs the publisher service until interrupted (cmd/outbox-publisher/main.go:1-72).
- `cmd/outbox-publisher/service.go` `Run` loops: `processBatch` fetches `outbox_events` rows inside `db.WithTx`, publishes via `pubsub.DomainPublisher()`, marks success/failure, and backs off with jitter (`sleep`, `nextBackoff`) when no work or errors occur (cmd/outbox-publisher/service.go:66-235).
- `publishRow` marshals stored `PayloadEnvelope`, attaches metadata attributes, and waits on Pub/Sub publish result before marking the row published (cmd/outbox-publisher/service.go:128-185).

## Outbox pattern
- `pkg/outbox.DomainEvent` + `PayloadEnvelope` capture aggregate/event metadata; `Service.Emit` marshals the payload, assigns `event_id`, and queues an `OutboxEvent` row via `Repository.Insert` (pkg/outbox/service.go:1-98; pkg/outbox/envelope.go:9-21).
- `Repository.FetchUnpublishedForPublish` locks `published_at IS NULL` rows (SKIP LOCKED), `MarkPublishedTx` stamps `published_at`, and `MarkFailedTx` increments `attempt_count` while truncating `last_error` (pkg/outbox/repository.go:20-101).
- `DecoderRegistry` registers custom decoders for consumed events, enabling deterministic payload parsing downstream (pkg/outbox/registry.go:1-32).
- `pkg/outbox/idempotency.Manager` paired with `cfg.Eventing.OutboxIdempotencyTTL` prevents duplicate consumer side effects via `pf:idempotency:evt:processed:<consumer>:<event_id>` keys (pkg/outbox/idempotency/idempotency.go:1-66; pkg/config/config.go:131-181).
- `license_status_changed` events flow through the domain topic so the compliance consumer can branch between admin notifications for pending uploads and store notifications for verified/rejected licenses while honoring the idempotency key tracking (`internal/notifications/consumer.go:71-186`).
- `internal/consumers/analytics.Consumer` handles `order_created`, `cash_collected`, and `order_paid` envelopes; it calls `pkg/outbox/idempotency.Manager.CheckAndMarkProcessed`/`Delete` with the `pf:evt:processed:analytics:<event_id>` guard, logs failures, and funnels exactly one row per event into `marketplace_events` via `pkg/bigquery.Client.InsertRows` so analytics ingestion stays deduplicated (`internal/consumers/analytics/consumer.go`:17-114; pkg/bigquery/client.go:149-168; pkg/outbox/idempotency/idempotency.go:1-66).
- Admin license decisions recompute `stores.kyc_status` inside the same transaction by scanning all licenses and calling `DetermineStoreKYCStatus`, ensuring the mirror flips to `verified`, `rejected`, or `expired` before the outbox event fires (`internal/licenses/service.go:385-425`).

## Session & Idempotency
- `pkg/auth/session.Manager` ensures refresh TTL exceeds access TTL, stores refresh tokens keyed by `AccessSessionKey`, rotates/revokes tokens, and supports middleware `HasSession` checks (pkg/auth/session/manager.go:45-154).
- `middleware.Idempotency` hashes request bodies, requires `Idempotency-Key` for configured routes, replays stored responses on retries, and stores records using `redis.IdempotencyStore.SetNX` (api/middleware/idempotency.go:37-208).
- `middleware.StoreContext` rejects `/api` requests lacking a store in context, keeping responses consistent (api/middleware/store.go:6-16).

## Media ingestion
- `internal/media/service.PresignUpload` validates uploader role/kind/size, persists a `Media` row with status `pending`, and signs a PUT URL with the GCS client before the object hits storage (internal/media/service.go:94-195).
- `ListMedia`/`buildReadURL` apply cursor pagination, filters, and attach signed GET URLs for `uploaded` or `ready` media before returning `ListResult` (internal/media/list.go:15-139).
- `DeleteMedia` checks ownership/status, deletes the GCS object, and marks the row `deleted` after `DeleteObject` succeeds (internal/media/service.go:242-284).
- `DeleteMedia` now loads the `media_attachments` for the target media, rejects the call if any `entity_type` is in `ProtectedAttachmentEntities` (`license|ad`), and only emits the downstream delete event after that guard passes so protected attachments are never orphaned; the worker still handles detaching unprotected references afterward (internal/media/service.go:242-284; pkg/db/models/media_attachment.go:11-24).
- `internal/media.NewAttachmentReconciler` is the canonical helper for attachment CRUD: it diffs `old_media_ids` vs `new_media_ids` inside the caller’s transaction, refuses media rows owned by a different `store_id`, and creates or removes `media_attachments` rows (through `MediaAttachmentRepository`) so every domain write follows the lifecycle rules without mutating existing attachments manually (internal/media/attachment_reconciler.go:13-97; internal/media/attachment_repository.go:11-32).
- `internal/media/consumer` picks up GCS `OBJECT_FINALIZE` events via Pub/Sub, finds the row by GCS key, and calls `MarkUploaded` so subsequent reads expose the download URL (internal/media/consumer/consumer.go:30-235).

## Dependencies & tooling
- `pkg/pubsub.NewClient` verifies every configured subscription exists before returning publishers/subscribers used by the worker and publisher (pkg/pubsub/client.go:18-202).
- `pkg/storage/gcs.NewClient` fetches credentials (JSON/service account/metadata), pings the bucket, and exposes `SignedURL`, `SignedReadURL`, and `DeleteObject` used by media/license flows (pkg/storage/gcs/client.go:35-506).
- `pkg/bigquery.NewClient` boots the shared analytics client, enforces `PACKFINDERZ_BIGQUERY_DATASET` plus `PACKFINDERZ_BIGQUERY_MARKETPLACE_TABLE`/`PACKFINDERZ_BIGQUERY_AD_TABLE`, and exposes `Ping` so `/health/ready` and the worker readiness probes fail fast when `marketplace_events` or `ad_events` are missing before ingestion begins (pkg/bigquery/client.go:27-184; pkg/config/config.go:179-187).
- `pkg/migrate.MaybeRunDev` auto-runs Goose migrations when `PACKFINDERZ_AUTO_MIGRATE` plus dev env are enabled, keeping service schema in sync (pkg/migrate/autorun.go:12-34).
