## pkg/auth
- `MintAccessToken(cfg config.JWTConfig, now time.Time, payload AccessTokenPayload) (string, error)` validates JWT params plus roles/store/KYC before signing HS256 tokens with the configured expiration (pkg/auth/token.go:15-119).
- `ParseAccessToken` and `ParseAccessTokenAllowExpired` return typed `AccessTokenClaims` used by middleware and refresh operations (pkg/auth/token.go:66-119).
- `AccessTokenPayload`/`AccessTokenClaims` carry user, active store, role, store type, KYC, and JTI metadata for minted tokens (pkg/auth/claims.go:9-27).

## pkg/auth/session
- `Manager` (`NewManager`, `Generate`, `Rotate`, `Revoke`, `HasSession`) maps access IDs to refresh tokens in Redis, enforces TTLs, and rotates tokens via constant-time comparison (pkg/auth/session/manager.go:45-154).

## pkg/config
- `Config` aggregates `App`, `Service`, `DB`, `Redis`, `JWT`, `Password`, feature flags, `Eventing.OutboxIdempotencyTTL`, and GCP/GCS/PubSub/Outbox settings loaded via `Load()` and `envconfig` (pkg/config/config.go:12-234).

## pkg/db
- `New(ctx, cfg, logg)` builds a GORM/Postgres client, applies pool settings, and exposes `DB()`, `Ping()`, `Close()`, `Exec()`, `Raw()`, and `WithTx()` helpers for transactional work (pkg/db/client.go:17-136).
- Domain models: `Product`, `InventoryItem`, `ProductVolumeDiscount`, and `ProductMedia` mirror the new catalog tables with UUID PKs, enum-backed categories/units, feelings/flavors arrays, and GORM relations for inventory/discount/media preloads (pkg/db/models/product.go:9-45; pkg/db/models/inventory_item.go:9-24; pkg/db/models/product_volume_discount.go:9-24; pkg/db/models/product_media.go:11-29).

## pkg/redis
- `Client` (`New`, `Set`, `Get`, `SetNX`, `Incr`, `IncrWithTTL`, `FixedWindowAllow`) unifies redis commands, key namespaces (`IdempotencyKey`, `RateLimitKey`, `AccessSessionKey`) and refresh-token helpers for session handling (pkg/redis/client.go:33-233).

## pkg/pubsub
- `Client` (`NewClient`, `Subscription`, `MediaSubscription`, `DomainPublisher`, `Ping`) boots a V2 client, verifies the configured subscriptions/topics exist, and exposes publishers/subscribers (pkg/pubsub/client.go:18-202).

## pkg/stripe
- `NewClient(ctx, cfg config.StripeConfig, logg *logger.Logger)` normalizes `cfg.Environment()` to `test` or `live`, trims the API key and webhook secret loaded from `PACKFINDERZ_STRIPE_API_KEY` / `PACKFINDERZ_STRIPE_SECRET`, validates that the key prefix matches the selected env (`sk_test`/`rk_test` or `sk_live`/`rk_live`), builds `stripe.NewClient`, logs success, and fails fast when secrets are missing or invalid so the API/worker never starts with a misconfigured Stripe surface (`pkg/stripe/client.go:33-119`; `pkg/config/config.go:191-209`).
- `Client.API()`, `.Environment()`, and `.SigningSecret()` expose the wrapped Stripe SDK client plus the normalized environment and webhook secret metadata needed by subscriptions, billing, and webhook handlers (`pkg/stripe/client.go:67-89`).

## pkg/storage/gcs
- `Client` loads credentials (JSON/service account/metadata), keeps a cached token source, pings the bucket, and exposes `SignedURL`, `SignedReadURL`, `DeleteObject`, and bucket helpers that embed service-account signing logic (pkg/storage/gcs/client.go:35-506).

## pkg/bigquery
- `NewClient(ctx, config.GCPConfig, config.BigQueryConfig, logger)` bootstraps the shared BigQuery client, loads credentials from JSON or `GOOGLE_APPLICATION_CREDENTIALS`, and requires `PACKFINDERZ_BIGQUERY_DATASET` (default `packfinderz`) plus the `PACKFINDERZ_BIGQUERY_MARKETPLACE_TABLE`/`PACKFINDERZ_BIGQUERY_AD_TABLE` names before continuing (`pkg/bigquery/client.go`:27-108; `pkg/config/config.go`:179-187).
- `Ping(ctx)` reruns the dataset + table metadata check so `/health/ready` and worker readiness fail fast when `marketplace_events`/`ad_events` are missing, avoiding ingestion before the analytics tables exist (`pkg/bigquery/client.go`:111-147).
- `InsertRows(ctx, table, rows []any)` streams row payloads (maps, `ValueSaver`s, or `bigquery.ValuesSaver`) into the configured dataset table so outbox/analytics consumers can emit events without rehydrating the SDK (`pkg/bigquery/client.go`:149-168).
- `Query(ctx, sql, params []bigquery.QueryParameter)` returns a `*bigquery.RowIterator` for analytics helpers that need parameterized reads while keeping configuration encapsulated (`pkg/bigquery/client.go`:170-184).

## pkg/outbox
- `ActorRef` + `PayloadEnvelope` describe stored envelopes that wrap `DomainEvent.Data` with version, event ID, actor, and timestamps before persistence (pkg/outbox/envelope.go:9-21).
- `DomainEvent` carries aggregate/type/actor/data metadata and `Service.Emit(ctx, tx, event)` marshals it into `OutboxEvent` rows while logging the queued event (pkg/outbox/service.go:1-98).
- `Repository` supports `Insert`, `FetchUnpublishedForPublish`, `MarkPublishedTx`, and `MarkFailedTx`, handling locking, attempt counts, and truncated `last_error` fields (pkg/outbox/repository.go:20-101).
- `Repository.DeletePublishedBefore` filters on `published_at` + `attempt_count >= 5` so the PF-140 cron job can delete published records older than the 30-day cutoff without touching active batches (`pkg/outbox/repository.go`:119-137; `internal/cron/outbox_retention_job.go`:1-102).
- `DecoderRegistry` lets consumers register versioned decoders for published payloads (pkg/outbox/registry.go:1-32).
- `event_type` routing registry (planned PF-142 work) lives in `pkg/outbox/registry`: it maps each `enums.OutboxEventType` to a single Pub/Sub topic, the expected aggregate type, and the typed payload definition in `pkg/outbox/payloads`, validates `payload_json` + the envelope invariants (`aggregate_type`, `aggregate_id`, presence of payload) before the dispatcher constructs the Pub/Sub message, and classifies unknown/invalid `event_type`s as terminal (non-retryable) failures that the future DLQ plumbing must capture; the dispatcher only consumes `event_type`, `aggregate_type`, `aggregate_id`, and `payload_json` from the row so no extra persistence lookups happen during dispatch (pkg/outbox/registry.go:1-32; pkg/outbox/payloads/*.go).
- PF-144 defines the DLQ persistence helpers for terminal failures under `pkg/outbox/dlq_repository.go`: each DLQ row mirrors the exact stored envelope (`event_id`, `event_type`, `aggregate_type`, `aggregate_id`, `payload_json`) plus `error_reason`/`error_message` metadata and timestamps, the repository writes rows append-only, and the dispatcher will insert the DLQ record atomically while marking the outbox row terminal so auditing or manual remediation tooling can replay the failure without rehydrating additional state (`pkg/outbox/DLQRepository`, migration pending).

## pkg/outbox/idempotency
- `Manager` (`NewManager`, `CheckAndMarkProcessed`) wraps a `redis.IdempotencyStore`, enforces `PACKFINDERZ_EVENTING_IDEMPOTENCY_TTL` (default 720h), and leans on `pf:idempotency:evt:processed:<consumer>:<event_id>` keys (pkg/outbox/idempotency/idempotency.go:1-66; pkg/config/config.go:131-181).

## pkg/migrate
- `MaybeRunDev` auto-applies migrations in dev mode, while `Run` and `MigrateToVersion` delegate to `goose` for CLI migrations and version targeting (pkg/migrate/autorun.go:12-34; pkg/migrate/migrate.go:12-72).

## pkg/pagination
- `Params`, `Cursor`, `NormalizeLimit`, `LimitWithBuffer`, `EncodeCursor`, and `ParseCursor` encapsulate the cursor pagination contract used by licenses/media listings (pkg/pagination/pagination.go:12-80).

## pkg/checkout
- `ValidateMOQ([]MOQValidationInput)` ensures every line item meets its `MOQ` before checkout commits reservations/orders; violations collect `MOQViolationDetail` entries with `product_id`, optional `product_name`, `required_qty`, and `requested_qty`, and the helper returns `pkg/errors.CodeStateConflict` so the API reports HTTP `422` with a canonical `violations` array (pkg/checkout/validation.go:11-43).

## pkg/visibility
- `VendorVisibilityInput` plus `EnsureVendorVisible` drive canonical rules for buyer-facing product and store queries: vendors must be `kyc_status=verified`, `subscription_active=true`, and share the requested state (plus the buyer store’s state when provided); violations map to `pkg/errors.CodeNotFound` (hidden vendors) or `pkg/errors.CodeValidation` (state mismatch) so client listings/details consistently return `404`/`422` (pkg/visibility/visibility.go:11-46).
- PF-118 confirmed every browse/search path (product list/detail/search helpers) calls `EnsureVendorVisible`, preventing `stores.subscription_active=false` vendors from surfacing while keeping paid vendors visible (`api/controllers/products.go:8-244`; `pkg/visibility/visibility.go:11-46`).

## pkg/security
- `HashPassword`, `VerifyPassword`, and `GenerateTempPassword` wrap Argon2id hashing and random-password generation tuned by `PasswordConfig`, and validate hash formats (pkg/security/password.go:15-166).

## pkg/types
- `Address`, `Social`, `GeographyPoint`, and `Ratings` mirror Postgres composite types (`address_t`, `social_t`, geography, JSONB) with `Value`/`Scan` helpers used by GORM models (pkg/types/address.go:10-109; pkg/types/social.go:9-58; pkg/types/geography_point.go:12-117; pkg/types/ratings.go:9-47).

## internal/billing
- `Repository` (`internal/billing/repo.go:1-121`) scopes every table operation to `store_id`, orders rows by `created_at DESC`, and exposes `Create/List/Find` helpers (plus `WithTx`) for `subscriptions`, `payment_methods`, `charges`, and `usage_charges`, keeping Stripe state per store so services can gate listings, billing history, and usage reporting.
- `Service` (`internal/billing/service.go:12-56`) validates the repository dependency and forwards the same CRUD primitives, so controllers or consumers can persist subscriptions, payment methods, charges, and metered usage without re-implementing the SQL.

## internal/subscriptions
- `Service` (`internal/subscriptions/service.go:1-230`) composes `internal/billing.Repository`, the Stripe subscription client, the store repository, and a transaction runner so vendor creation/cancellation keeps Stripe and Postgres in sync, enforces the one-active-subscription rule, mirrors Stripe metadata/period windows, and updates `stores.subscription_active` idempotently (including optional overrides for `price_id`/customer/payment details).
- `api/controllers/subscriptions/vendor.go` wires `POST /api/v1/vendor/subscriptions`, `POST /api/v1/vendor/subscriptions/cancel`, and `GET /api/v1/vendor/subscriptions`, enforces `StoreContext` + `StoreType=vendor`, requires `Idempotency-Key` for the write paths, hydrates the `stripe_customer_id`/`stripe_payment_method_id` payload plus optional `price_id`, and returns either the new subscription (201) or the current active record/`null` so frontend consumer work consistently with the service’s single-row guarantee (api/controllers/subscriptions/vendor.go:19-154; api/middleware/idempotency.go:37-58).

## internal/webhooks/stripe
- `Service` (`internal/webhooks/stripe/service.go:1-178`) consumes `stripe.Event`s, handles `customer.subscription.created|updated|deleted` plus `invoice.paid|invoice.payment_failed`, verifies `stripe.Subscription` payloads, and mirrors Stripe metadata/payment windows into `subscriptions` + `stores.subscription_active` inside a transaction.
- `IdempotencyGuard` (`internal/webhooks/stripe/idempotency.go:1-42`) deduplicates deliveries using Redis keys `pf:idempotency:stripe-webhook:<event_id>` with `PACKFINDERZ_EVENTING_IDEMPOTENCY_TTL` so retried events remain safe, and the controller verifies `Stripe-Signature`, reads `Stripe-Signature` + body, and forwards the constructed event to the webhook service (`api/controllers/webhooks/stripe.go:13-82`; `internal/webhooks/stripe/service.go:1-178`; `internal/webhooks/stripe/idempotency.go:1-42`).

## internal/auth
- `Service.Login(ctx, LoginRequest)` returns `LoginResponse` with tokens, user DTO, and `StoreSummary` list after verifying credentials and membership (internal/auth/service.go:24-153; internal/auth/dto.go:9-29).
- `RegisterService.Register(ctx, RegisterRequest)` builds user/store/membership rows under a transaction, hashing passwords and enforcing TOS/store type validation (internal/auth/register.go:21-133).
- `SwitchStoreService.Switch(ctx, SwitchStoreInput)` verifies membership status, rotates refresh tokens, and mints a store-scoped access token (internal/auth/switch_store.go:18-118).

## internal/memberships
- `Repository` exposes `ListUserStores`, `GetMembershipWithStore`, `ListStoreUsers`, `CreateMembership`, `UserHasRole`, `CountMembersWithRoles`, and `DeleteMembership` to mediate memberships (internal/memberships/repo.go:13-145).
- DTOs `MembershipWithStore` and `StoreUserDTO` blend membership metadata with store/user details for API responses (internal/memberships/dto.go:12-76).

## internal/stores
- `Service` (`GetByID`, `Update`, `ListUsers`, `InviteUser`, `RemoveUser`) ties `stores.Repository`, `memberships.Repository`, and `users.Repository` to enforce role checks, update fields, invite users, and protect the last owner (internal/stores/service.go:42-373).
- `StoreDTO`, `CreateStoreDTO`, and model mappers shape the safe tenant payload returned to clients (internal/stores/dto.go:13-140).

- `Repository` (internal/cart/repo.go:22-118) orchestrates `CartRecord`/`CartItem` persistence for checkout staging: `Create`/`ReplaceItems` seed snapshots, `FindActiveByBuyerStore`/`FindByIDAndBuyerStore` preload items and scope by `buyer_store_id`, `UpdateStatus` flips the `cart_status` enum (`active|converted`), and `DeleteByBuyerStore` cleans up all records for a buyer when needed.
- `models.CartRecord` captures `buyer_store_id`, optional `session_id`, shipping address, totals (subtotal/total/fees/discount), `cart_level_discount[]`, and timestamps (`pkg/db/models/cart_record.go:12-41`); the schema is undergoing PF-147 rework so models will mirror the newer `pkg/migrate/migrations/20260306000000_cart_modifications.sql` columns (`checkout_group_id`, `valid_until`, `discounts_cents`, `currency`, `ad_tokens`, vendor group relationship) once aligned. `models.CartItem` stores product/vendor snapshots (SKU, unit, price tiers, MOQ, THC/CBD, featured image) plus `cart_id` FK cascading on delete (`pkg/db/models/cart_item.go:11-37`); column names/JSON status/warnings will shift along with the migration, and the upcoming model updates must keep `quantity`, `line_subtotal_cents`, `applied_volume_discount`, `cart_item_status`, and warning payloads in sync with the DB (`pkg/migrate/migrations/20260306000000_cart_modifications.sql`).
- `service.Service.QuoteCart` (internal/cart/service.go:310-414) consumes `cartdto.QuoteCartRequest`, preloads vendors once, validates promos/products/inventory, normalizes quantities/pricing, aggregates vendor groups, and persists `cart_record`, `cart_items`, and `cart_vendor_groups` in a single transaction before returning the authoritative cart snapshot.
- `service.Service.GetActiveCart` (internal/cart/service.go:259-284) validates the buyer store, enforces `buyer_store_id` ownership, and returns the active `cart_record` + `cart_items`, allowing `GET /api/v1/cart` to surface the cached checkout snapshot or respond `404` when none exists.
- `internal/checkout/helpers` (internal/checkout/helpers/grouping.go; internal/checkout/helpers/validation.go) provides deterministic, DB‑free helpers that group `CartItem`s by `vendor_store_id`, recompute per-vendor totals (`ComputeVendorTotals`, `ComputeTotalsByVendor`), and validate buyer/vendor eligibility (`ValidateBuyerStore`, `ValidateVendorStore`). `ValidateVendorStore` now reuses `pkg/visibility.EnsureVendorVisible`, so cart persistence + checkout share the same subscription/state gating before any cross-store data is read.
- PF-079 adds an inventory reservation helper in the same package so checkout can run conditional updates on `inventory_items` (ensuring `available_qty >= qty`, never negative, moving units to `reserved_qty`) while reporting success/failure per line item, enabling partial success semantics without DB locks.
- `internal/checkout/service` (PF-080) orchestrates the checkout transaction: converts an active `CartRecord` into a `CheckoutGroup`, creates `VendorOrders`/`OrderLineItems`, retries/reserves inventory, handles partial successes, and marks the cart `converted` exactly once before returning the checkout DTO (`internal/checkout/service.go`).
- `internal/checkout/service.emitOrderCreatedEvent` writes the `order_created` outbox row (`aggregate=checkout_group`, `version=1`) inside the same transaction as the cart conversion by emitting an `OrderCreatedEvent` payload with the newly created `checkout_group_id` and every `vendor_order_id` (`internal/checkout/service.go`:150-271; pkg/enums/outbox.go:5-108).

## internal/orders
- `internal/orders.Repository` persists `checkout_groups`, `vendor_orders`, `order_line_items`, and `payment_intents` (internal/orders/interfaces.go:1-29) and surfaces both `ListBuyerOrders` and `ListVendorOrders`.
- `ListBuyerOrders` returns `BuyerOrderList` with `BuyerOrderSummary` rows (order number, totals, statuses, vendor info, total items) ordered by `created_at DESC`, building cursors with `pkg/pagination.NormalizeLimit`, `LimitWithBuffer`, and the `pagination.Cursor`/`ParseCursor` helpers (`pkg/pagination/pagination.go:12-80`; internal/orders/dto.go:29-46`).
- `ListVendorOrders` returns `VendorOrderList` scoped to `vendor_store_id`, filters on `order_status`, `fulfillment_status`, `shipping_status`, `payment_status`, actionable status list, `created_at` range, and a `q` search over buyer/vendor names before ordering by `created_at DESC`, `id DESC` and paginating with the same helpers (internal/orders/repo.go:214-326; internal/orders/dto.go:22-75).
- `FindOrderDetail` loads a single `vendor_orders` row plus joined `order_line_items`, `payment_intent`, buyer/vendor `stores`, and the single `active` `order_assignments` row so the service can render detail views without extra queries (internal/orders/repo.go:322-347; internal/orders/dto.go:78-115).
- API: `api/controllers/orders.List` wires `GET /api/v1/orders`, reads `activeStoreId`/`StoreType` from middleware, and calls the buyer or vendor list helper with the same cursor + filter params (order_status, fulfillment_status, shipping_status, payment_status, actionable_statuses, q, date_from/to, limit, cursor); `api/controllers/orders.Detail` handles `GET /api/v1/orders/{orderId}`, enforces the store owns the order before returning `internal/orders.Repository.FindOrderDetail` (api/controllers/orders/orders.go:13-221; middleware.StoreID/StoreTypeFromContext).
- `BuyerOrderFilters`/`VendorOrderFilters` (internal/orders/dto.go:10-36) mirror the supported inputs, exposing optional status/date filters plus `Query`, while the responses include sequential `order_number`, totals, `total_items`, status enums, and store summaries; `VendorOrderSummary` omits buyer logos per the MVP assumption.
- `pkg/db/models/vendor_order.go:12-37` now records `fulfillment_status`, `shipping_status`, and `order_number`; `pkg/migrate/migrations/20260126000001_add_vendor_order_fields.sql:4-51` introduces the enum types, `vendor_order_number_seq`, the `order_number` column, and `ux_vendor_orders_order_number`.
- `api/routes/router.go:60-116` mounts `POST /api/v1/vendor/orders/{orderId}/decision` behind auth/store/idempotency middleware; `api/controllers/orders.VendorOrderDecision` parses `{decision: accept|reject}`, requires a vendor store context, and forwards the request to `internal/orders.Service.VendorDecision`.
- `internal/orders.Service.VendorDecision` validates the decision is allowed in the current state, stores `enums.VendorOrderStatusAccepted`/`Rejected`, and emits the `order_decided` outbox event (`enums.EventOrderDecided`) so downstream consumers (buyers) can react to the vendor’s decision (`internal/orders/service.go:24-147`; pkg/enums/outbox.go:57-69).
- `internal/orders.Service.LineItemDecision` backs `POST /api/v1/vendor/orders/{orderId}/line-items/decision` (api/routes/router.go:60-116), checks vendor ownership, releases inventory for rejected items via`inventory.Release`, recomputes `subtotal_cents`, `total_cents`, and `balance_due_cents`, updates `fulfillment_status`/`status` when all `pending` rows resolve, and emits the `order_fulfilled` outbox event (`enums.EventOrderFulfilled`) once every line is handled so the buyer sees the final state (`internal/orders/service.go:180-359`; pkg/enums/outbox.go:57-72).
- `internal/orders.Service` also exposes buyer helpers (`CancelOrder`, `NudgeVendor`, `RetryOrder`): cancel releases inventory/rejects non-fulfilled lines, zeros the balance, sets status to canceled, and emits `order_canceled`; nudge emits a `NotificationRequested` event when the order is still mutable; retry replays only the expired vendor order by cloning the snapshot, reserving fresh inventory, creating a payment intent, and emitting `order_retried`, leaving the rest of the checkout group untouched (`internal/orders/service.go:360-660`; pkg/enums/outbox.go:57-72).
- `ListPayoutOrders` (internal/orders/repo.go:561-620) filters `vendor_orders` with `status=delivered`, joined `payment_intents` with `status=settled`, sorts by `delivered_at` asc, and returns cursor pages of `orderId`, `orderNumber`, `vendorStoreId`, `amountCents`, `deliveredAt` so admins can drive `/api/v1/admin/orders/payouts`.
- `ConfirmPayout` (internal/orders/service.go:847-940) validates delivered + settled orders, updates the payment intent to `paid`, closes the vendor order, appends a `vendor_payout` ledger event, and emits the `order_paid` outbox event inside a single transaction so payouts stay atomic and idempotent.
- `ConfirmPayout` trails vendor payout confirmation: it updates payout/order status, writes the payout entry, and reuses `ledger.Service.RecordEvent` under the same transaction so every payout produces an append-only ledger row (`internal/orders/service.go:871-888`; internal/ledger/service.go:22-64).

- `internal/cron/order_ttl_job.go` (PF-138) runs after the license scheduler: it calls `orders.Repository.FindPendingOrdersBefore` (`status=created_pending`, `created_at` ASC, cutoff at 5/10 days) to deliver `order_pending_nudge` when orders hit 5 days and `order_expired` once they cross 10, reusing `orders.ReleaseLineItemInventory` so eligible `inventory_items` rows return reserved quantities before the vendor order shifts to `VendorOrderStatusExpired` with `balance_due_cents=0` and both outbox events are emitted inside the same transaction (`internal/cron/order_ttl_job.go`:44-208; `internal/orders/repo.go`:131-150; `internal/orders/service.go`:853-975; `pkg/db/models/inventory_item.go`:9-24; `pkg/enums/outbox.go`:5-84; `pkg/enums/vendor_order_status.go`:5-26`). Cron metrics/logs still emit the `job`/`duration_ms`/`event` fields so sequential TTL jobs remain observable (`internal/cron/service.go`:90-122; `pkg/metrics/cron.go`:16-40).


## internal/ledger
- `Repository` exposes only `Create` and `ListByOrderID`, so ledger rows are append-only (internal/ledger/repo.go:11-38).
- `Service.RecordEvent` enforces a valid `LedgerEventType`, builds the event, and writes it via the repository so every ledger row is created centrally and never updated/deleted (internal/ledger/service.go:22-64).

## internal/users
- `Repository` provides `Create`, `FindByEmail`, `FindByID`, `UpdateLastLogin`, and `UpdatePasswordHash`; the legacy `UpdateStoreIDs` helper and `users.store_ids` array were removed as part of PF-198 so memberships come from `store_memberships` (internal/users/repo.go:12-70; internal/users/dto.go:11-52).

## internal/products
- `repo.Repository` (internal/products/repo/repository.go:60-208) bundles product, inventory, and discount persistence, exposing CRUD operations plus `GetProductDetail`/`ListProductsByStore` that preload `Inventory`, `VolumeDiscounts` (ordered by `min_qty DESC`), and `Media` (ordered by `position ASC`).
- Vendor summary helper selects `stores` metadata plus the latest `media_attachments` row for `entity_type='store'` via `vendorSummaryQuery`, returning `VendorSummary{StoreID,CompanyName,LogoMediaID,LogoGCSKey}` while relying on the `(entity_type,entity_id)` and `(media_id)` indexes for fast, tenant-scoped logo lookups (internal/products/repo/repository.go:12-208).
- Inventory/discount repositories reuse the same DB: `UpsertInventory`, `GetInventoryByProductID`, `CreateVolumeDiscount`, `ListVolumeDiscounts`, and `DeleteVolumeDiscount` keep the 1:1 and unique `(product_id,min_qty)` semantics intact (internal/products/repo/repository.go:133-175).
- `service.DeleteProduct` ensures the store is a vendor, the caller has an allowed membership role, the product belongs to the active store, and then deletes it so `inventory_items`, `product_volume_discounts`, and product media rows vanish via existing FK cascades (internal/products/service.go:317-338).

## internal/media
- `Service` operations `PresignUpload`, `ListMedia`, `DeleteMedia`, and `GenerateReadURL` validate roles, enforce mime/kind rules, persist `Media` rows, and sign URLs via GCS (internal/media/service.go:39-332; internal/media/list.go:15-139).
- `PresignInput`, `PresignOutput`, `ListParams`, `ListResult`, `ListItem`, `ReadURLParams`, `ReadURLOutput`, and `DeleteMediaParams` define the request/response contracts (internal/media/service.go:94-244; internal/media/list.go:15-139).
- `Repository` supports `Create`, `FindByID`, `List`, `MarkUploaded`, and `MarkDeleted` for metadata lifecycle updates (internal/media/repo.go:14-110).
- `consumer.Consumer.Run` processes GCS `OBJECT_FINALIZE` notifications, looks up media by GCS key, and calls `MarkUploaded` with retries/nacks for transient DB errors (internal/media/consumer/consumer.go:30-235).
- `NewAttachmentReconciler` plus `MediaAttachmentRepository` (`internal/media/attachment_reconciler.go`, `internal/media/attachment_repository.go`) diff `old_media_ids` vs `new_media_ids`, run inside the caller’s transaction, fetch each candidate `media` row for its `store_id`/`gcs_key`, refuse cross-store references, and create/delete the matching `media_attachments` rows so every domain write uses the same lifecycle rules without mutating historical attachments directly.
- `DeletionConsumer` + `cmd/media_deleted_worker/main` (`internal/media/consumer/deletion_consumer.go`, `cmd/media_deleted_worker/main.go`) bind to `pubsub.MediaDeletionSubscription()` (projects/packfinderz/subscriptions/media-deleted-sub), parse JSON_API_V1 `OBJECT_DELETE` payloads, resolve `object.name` → `gcs_key` → `media_id`, iterate attachments in deterministic order, trigger domain-specific detachment before deleting `media_attachments`, and keep the flow idempotent so duplicate Pub/Sub deliveries are safe while centralizing cleanup outside the API.

## internal/schedulers/licenses
- `Service` encapsulates the expiry warning/expiration workflow and exposes `Run`, which ticks every `schedulerInterval` (24h) before calling `process` so scheduler loops remain isolated from API traffic (`internal/schedulers/licenses/service.go`:1-220).
- `process` sequentially executes `warnExpiring` and `expireLicenses`, aggregates their errors, and leaves logging and retry policies to the caller instead of crashing the loop (`internal/schedulers/licenses/service.go`:94-142).
- `warnExpiring`/`expireLicenses` use `FindExpiringBetween` plus `FindExpiredByDate`, emit `license_status_changed` events via `outbox.Service.Emit` (warnings include the `expires on` reason plus `warningType=expiry_warning`), and keep each transition atomic inside `WithTx` so downstream consumers see consistent state (`internal/schedulers/licenses/service.go`:61-173).
- `expireLicense` reloads the row inside the same transaction, skips statuses that are already `expired`, updates the license status, reconciles the store `kyc_status` via `DetermineStoreKYCStatus`, and emits the `expired by scheduler` event so analytics/notifications observe the change before the KYC mirror flips (`internal/schedulers/licenses/service.go`:174-210; `internal/licenses/service.go`:405-416).
- Cron jobs booted from `cmd/cron-worker` should record `job_duration_seconds`, `job_success`, `job_failure`, and the structured fields (`job`, `duration_ms`, `event`) before/after invoking `warnExpiring` + `expireLicenses` so monitoring/alerting sees every run (`cmd/cron-worker/main.go`:69-112; `internal/cron/service.go`:14-154; `pkg/metrics/cron.go`:16-40).
- The only outbox event type currently emitted is `license_status_changed`, yet `pkg/enums/outbox.go` defines `license_expiring_soon` + `license_expired` so future iterations can switch without adding new enums (`pkg/enums/outbox.go`:16-84).
- MEDIA CLEANUP `UNKNOWN`: `internal/schedulers/licenses.Service` stops after `reconcileKYC` and does not yet delete licenses or their associated `media`/`media_attachments` rows, even though `media_attachments.media_id` is `ON DELETE RESTRICT` and `entity_type='license'` attachments must be removed before deleting the GCS object per `docs/media_attachments_lifecycle.md`. PF-137 adds the >30-day purge that deletes the license row plus the attached media artifacts deterministically (`internal/schedulers/licenses/service.go`:174-210; docs/media_attachments_lifecycle.md`).

## internal/cron
- `Job` is the unit of scheduled work: it exposes `Name()` and `Run(ctx context.Context) error`, letting the registry log every job start/end and keep failures contained (`internal/cron/registry.go`:5-34).
- `Registry` can be preloaded with `NewRegistry(jobs...)`, accepts `Register`, and returns a defensive copy via `Jobs()` so concurrent executions can iterate without races (`internal/cron/registry.go`:11-38).
- `Lock` ensures single-leader execution; `RedisLock` uses `SETNX`/TTL plus value verification on keys like `pf:cron-worker:lock:<env>` so another instance cannot steal the lease while a run is in-flight (`internal/cron/lock.go`:1-80).
- `Service` loops every 24h (customizable via `Interval`), attempts to acquire the shared lock, logs when the leader already holds it, iterates `Registry.Jobs()` with `WithField(job, ...)`, and records Prometheus metrics (`pkg/metrics.CronJobMetrics`) so `job_duration_seconds`, `job_success`, and `job_failure` exist per job; job failures never stop the next job or the next cycle (`internal/cron/service.go`:14-154; `pkg/metrics/cron.go`:16-40).

## cmd/cron-worker
- `main` boots the shared config/logger/DB/Redis stack, flips `cfg.Service.Kind` to `cron-worker`, and runs dev migrations when `PACKFINDERZ_APP_ENV=dev` plus `PACKFINDERZ_AUTO_MIGRATE=true` so the scheduler runs on the expected schema (`cmd/cron-worker/main.go`:22-67; `pkg/migrate/autorun.go`:12-34).
- Metrics are wired through `metrics.NewCronJobMetrics(prometheus.DefaultRegisterer)`, exposing `job_duration_seconds`, `job_success`, and `job_failure` before any concrete jobs exist (`cmd/cron-worker/main.go`:69-80; `pkg/metrics/cron.go`:16-40).
- A Redis lock keyed by `pf:cron-worker:lock:<env>` keeps leadership to a single instance; `cron.NewRedisLock` plus `cron.NewService` create the scheduler loop, and `cron.NewRegistry()` currently returns an empty job set so the process just exercises the lock/metrics plumbing until domain jobs register themselves (`cmd/cron-worker/main.go`:73-112; `internal/cron/service.go`:23-105).

## internal/licenses
- `Service` `CreateLicense` validates role/media ownership/mime, persists `License`, and `ListLicenses` applies cursor pagination plus signed downloads (internal/licenses/service.go:18-224).
- `CreateLicenseInput`, `ListParams`, `ListResult`, and `ListItem` describe license creation/listing payloads (internal/licenses/service.go:51-213; internal/licenses/list.go:12-59).
- `Repository` `Create` and `List` wrap GORM operations for license rows (internal/licenses/repo.go:10-43).
- `CreateLicense` and `VerifyLicense` both call `emitLicenseStatusEvent` so `license_status_changed` outbox events (payload: `licenseId`, `storeId`, `status`, optional `reason`) are queued in the same transaction as the license mutation, letting downstream consumers react to pending/approved/rejected transitions without extra polling (`internal/licenses/service.go`: lines 136-419).

## internal/notifications
- `Repository.Create` inserts `models.Notification` rows used by the compliance consumer (`internal/notifications/repo.go:1-23`).
- `Consumer` acquires `pubsub.NotificationSubscription()` plus an `idempotency.Manager`, filters for `license_status_changed` events, and writes `NotificationTypeCompliance` records via `handlePayload` after checking `pf:evt:processed:<consumer>:<event_id>` (internal/notifications/consumer.go:18-197; cmd/worker/main.go:83-116).
- `createStoreNotification` links `/stores/{storeId}/licenses/{licenseId}`, uses the optional rejection `reason`, and notifies stores when approvals/rejections land while `createAdminNotification` links `/admin/licenses/{licenseId}` when licenses return to pending review (internal/notifications/consumer.go:128-186).
- `Repository.MarkRead` updates `read_at` only when `NULL` for the provided `notification_id`/`store_id`, returns `Found`/`Updated` flags that surface idempotency, and `MarkAllRead` sets `read_at` for every unread row of the store while reporting the rows affected so bulk acknowledgements stay scoped to the tenant (internal/notifications/repo.go:54-113).
- `Repository.List` paginates store-scoped notifications ordered by `(created_at, id) DESC`, honors `UnreadOnly` filtering, normalizes the limit via `pagination.NormalizeLimit` (default 25, max 100) with `LimitWithBuffer` for next-cursor detection, and exposes `MarkRead`/`MarkAllRead` transitions that keep `read_at` updates scoped to the caller’s `store_id` (`internal/notifications/repo.go:34-80`; pkg/pagination/pagination.go:12-40).
- `Service.List` enforces a non-nil `StoreID`, accepts `Limit`/`Cursor`/`UnreadOnly`, decodes/encodes the cursor via `pagination.ParseCursor`/`EncodeCursor`, and exposes the `List`, `MarkRead`, and `MarkAllRead` operations that API controllers can reuse while validating store context, propagating `pkg/pagination` limits, and keeping the read-state transitions idempotent (`internal/notifications/service.go:1-109`; pkg/pagination/pagination.go:12-40).
- `repositoryImpl.DeleteOlderThan` supports cleanup by deleting rows whose `created_at` precedes the cutoff inside the caller’s transaction so the Cron job stays idempotent while scaling with table size (`internal/notifications/repo.go`:116-131).
- `internal/cron/notification_cleanup_job.go` (PF-139) runs daily after the license/order TTL jobs: it subtracts 30 days from `now`, calls `DeleteOlderThan` inside `db.WithTx`, and logs `rows_deleted`, `retention_days`, and `cutoff` so the retention job stays observable while purging stale notifications (`internal/cron/notification_cleanup_job.go`:1-102).

## internal/analytics
- `Service.Query(ctx, req)` resolves store-scoped BigQuery KPIs (orders, revenue, AOV, cash collected) and daily `marketplace_events` series using parameterized queries so both vendor and buyer dashboards read from the analytics warehouse (`internal/analytics/service.go`:1-200; `pkg/bigquery/client.go`:149-184).

## ads
- `Serve`: request-time selection (`GET /ads/serve`) filters `status=active`, placement, store gating (`subscription_active=true`, `kyc_status=verified`), and time windows, gates via Redis budgets, chooses the highest CPM bid with deterministic tie-breakers, and issues signed view/click tokens (token_id, buyer_store_id, target + event metadata, expiry≈30d) for attribution (`docs/AD_ENGINE.md`:30-128).
- Impression/click tracking validate tokens, enforce `buyer_store_id` matches JWT, dedupe via `impdedupe`/`clickdedupe`, increment Redis counters (`imps:<adId>:<day>`, `clicks:<adId>:<day>`, `spend:<adId>:<day>`), and redirect/call out without touching Postgres; tokens and counters fuel the hybrid attribution rules (`docs/AD_ENGINE.md`:106-170).
- Nightly scheduler reads Redis totals, upserts `ad_daily_rollups`, inserts `usage_charges(type=ad_spend, for_date=day)`, emits outbox events, and keeps BigQuery/Stripe bridges deterministic; checkout attribution uses the token bag to populate `vendor_orders.attribution` and `vendor_order_line_items.attribution`, letting analytics emit per-order/line-item attribution rows (`docs/AD_ENGINE.md`:176-260).
