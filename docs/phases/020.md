# Title [PF-168]: Drop `checkout_groups` table and migrate checkout anchor to `checkout_group_id` UUID on cart + orders

## Type

Task

## Description

Remove the `checkout_groups` table and refactor persistence to use `checkout_group_id` (UUID) as the grouping anchor stored on `cart_records` and `vendor_orders`. This aligns with the new architecture where **CartRecord is canonical**, and “checkout group” becomes an identifier rather than a separate persisted aggregate.

## Scope

* What is included

  * Goose migration that drops `checkout_groups` table (and any FKs that reference it)
  * Ensure `vendor_orders.checkout_group_id` remains as a UUID grouping anchor (not FK)
  * Ensure `cart_records.checkout_group_id` remains (already present) and is used as the canonical conversion id
  * Update any FK constraints that currently reference `checkout_groups(id)` (remove/replace)
* What is explicitly NOT included

  * Refactoring checkout service/controller logic (separate tickets)
  * Changing API response shapes
  * Rewriting outbox consumers

## Acceptance Criteria

* [ ] Migration runs cleanly on an existing DB (no orphaned FK constraints)
* [ ] `checkout_groups` table no longer exists
* [ ] `vendor_orders.checkout_group_id` is a plain UUID column (indexed), not a FK
* [ ] `cart_records.checkout_group_id` remains intact and nullable (until conversion)

## Dependencies

* Blocked by:

  * None (schema-only change; ensure downstream code tickets follow)
* Blocks:

  * Vendor order schema refactor tickets
  * Checkout service refactor tickets

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `checkout_groups` (drop), `vendor_orders`, `cart_records`
  * Constraints: remove `vendor_orders.checkout_group_id -> checkout_groups(id)` FK if present
  * Index: add/ensure `idx_vendor_orders_checkout_group_id` and `idx_cart_records_checkout_group_id`
* Assumptions (explicitly marked)

  * **ASSUMPTION:** Existing reads of checkout results can be re-anchored to `vendor_orders.checkout_group_id` without needing `checkout_groups`.

## Out of Scope

* Service-layer idempotency behavior and “return existing checkout result” logic

---

# Title [PF-169]: Extend `vendor_orders` to snapshot checkout-confirmed fields + vendor-group discounts/warnings/promo

## Type

Task

## Description

Modify `vendor_orders` to capture the **order-time snapshot** required by the new checkout flow, mirroring what exists on `CartRecord`/`CartVendorGroup`, plus checkout-confirmed extensions (payment/shipping). This reduces recomputation and prevents drift between the cart quote and the created orders.

## Scope

* What is included

  * Goose migration to add/rename columns on `vendor_orders` to support:

    * `cart_id` (UUID, not null) — link back to canonical cart snapshot
    * `currency` (text/enum) — align with cart currency
    * `shipping_address` (`shipping_address`) — confirmed/overwritten address at checkout time
    * `discounts_cents` (int) — align naming with cart (`discounts_cents` vs `discount_cents`)
    * `warnings` (jsonb) — vendor-level warnings (mirror `CartVendorGroup.Warnings`)
    * `promo` (jsonb) — mirror `CartVendorGroup.Promo` (code/amount)
    * `payment_method` (enum/payment_method) — snapshot of chosen method (also stored in PaymentIntent, but order should carry it)
    * `shipping_line` (jsonb) OR explicit fields (`shipping_code`, `shipping_title`, `shipping_price_cents`) — future-safe “Shopify-ish” line
    * `attributed_token` (jsonb, nullable) — selected attribution blob for vendor/store-level attribution
  * Update GORM `models.VendorOrder` accordingly
* What is explicitly NOT included

  * Checkout service computation logic for these fields
  * Attribution selection logic
  * Outbox payload changes

## Acceptance Criteria

* [ ] `vendor_orders` has `cart_id` and can be joined back to `cart_records(id)`
* [ ] `vendor_orders` can store vendor-level `warnings` + `promo` consistently with `CartVendorGroup`
* [ ] `vendor_orders` can store checkout-confirmed `shipping_address`, `payment_method`, and `shipping_line`
* [ ] Existing order creation still compiles after GORM updates (even if values are not populated yet)
* [ ] Columns are nullable where appropriate to avoid breaking existing rows

## Dependencies

* Blocked by:

  * PF-201 (drop checkout_groups + remove FK dependency)
* Blocks:

  * Checkout service refactor (needs these columns to persist final snapshot)

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `vendor_orders`, `cart_records`, `cart_vendor_groups`
  * Consider renaming `discount_cents` → `discounts_cents` (or keep both with a deprecation plan)
* Assumptions (explicitly marked)

  * **ASSUMPTION:** `address_t` already exists and is used by `cart_records.shipping_address`.
  * **ASSUMPTION:** `payment_method` enum already exists (used by `PaymentIntent.Method`) and can be reused on `vendor_orders`.

## Out of Scope

* Reconciliation/backfill of historical orders beyond minimal defaults

---

# Title [PF-170]: Extend `order_line_items` to reference cart items + persist item warnings/discount context + attribution

## Type

Task

## Description

Update `order_line_items` to faithfully represent the **cart item snapshot** used at checkout, including warnings/status context and deterministic attribution for product-level tokens. This supports analytics and “explainability” without recomputing cart logic after checkout.

## Scope

* What is included

  * Goose migration to add fields to `order_line_items`:

    * `cart_item_id` (uuid, nullable initially; ideally not null for new rows) — ties back to canonical cart line
    * `warnings` (jsonb) — mirror `CartItem.Warnings`
    * `applied_volume_discount` (jsonb) — mirror `CartItem.AppliedVolumeDiscount`
    * `moq` (int) and `max_qty` (int nullable) — optional snapshot (mirrors cart)
    * `line_subtotal_cents` (int) — optional but aligns with cart’s authoritative line subtotal (distinct from order line `total_cents`)
    * `attributed_token` (jsonb, nullable) — product-level attribution selection
  * Update GORM `models.OrderLineItem` accordingly
* What is explicitly NOT included

  * Reservation engine changes
  * Attribution decision rules implementation
  * New API response fields

## Acceptance Criteria

* [ ] `order_line_items` can store warnings and applied volume discount JSONB
* [ ] `order_line_items` can link to the originating `cart_items` row (via `cart_item_id`)
* [ ] Schema changes are non-breaking for existing rows (nullable additions + safe defaults)
* [ ] GORM model compiles and can read/write the new fields

## Dependencies

* Blocked by:

  * PF-202 (vendor_orders refactor is usually paired; not strictly required but strongly coupled)
* Blocks:

  * Checkout attribution materialization ticket
  * “build orders from cart snapshot” refactor ticket

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `order_line_items`, `cart_items`
  * JSONB types should reuse existing serializer patterns used in `CartItem` (`types.CartItemWarnings`, `types.AppliedVolumeDiscount`)
* Assumptions (explicitly marked)

  * **ASSUMPTION:** You want line items to remain a stable snapshot even if products later change (current model already does snapshotting via `Name`, `Category`, etc.).

## Out of Scope

* Migrating historical orders to backfill cart_item_id

---

### Quick “what fields should VendorOrder mirror from Cart?”

To keep order creation dumb and deterministic, the vendor order should be able to carry:

* **From CartRecord:** `cart_id`, `buyer_store_id`, `currency`, confirmed `shipping_address`, `ad attribution (materialized)`, and totals
* **From CartVendorGroup:** `subtotal_cents`, `promo`, `warnings`, `total_cents`, plus vendor-level `discounts_cents` if you want symmetry
* **Checkout confirmed:** `payment_method`, `shipping_line/transport_fee`, `converted_at`

That gives you: **cart → checkout → vendor orders** with minimal re-derivation and easy analytics.

---

# Title [PF-171]: Add checkout-confirmed fields to `cart_records` for finalized cart snapshot

## Type

Task

## Description

Extend `cart_records` so checkout can overwrite/confirm shipping address and persist checkout selections (payment method + shipping line) before flipping the cart to `converted`. This makes the cart the auditable source of truth **both pre- and post-checkout**.

## Scope

* What is included

  * Goose migration to add fields to `cart_records`:

    * `payment_method` (enum/text) — chosen at checkout
    * `shipping_line` (jsonb) OR explicit fields (`shipping_code`, `shipping_title`, `shipping_price_cents`)
    * `converted_at` (timestamptz nullable)
  * Update GORM `models.CartRecord` to include these fields
* What is explicitly NOT included

  * Checkout service logic changes
  * Cart quote service logic changes

## Acceptance Criteria

* [ ] `cart_records` can store payment method + shipping line selection
* [ ] `cart_records.converted_at` is settable at conversion time
* [ ] Existing cart quote read/write paths still compile after model updates

## Dependencies

* Blocked by:

  * None
* Blocks:

  * Checkout service refactor (finalize cart + convert status)

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Table: `cart_records`
  * Enum reuse: `payment_method` should reuse `PaymentIntent.Method` enum/type if present
* Assumptions (explicitly marked)

  * **ASSUMPTION:** Shipping line is persisted as a single selection (not multiple).

## Out of Scope

* Any pricing computation for shipping lines (MVP can store selection only)

--

# Title [PF-172]: Implement new Checkout API DTO, controller wiring, and idempotent request handling

## Type

Feature

## Description

Implement the new **checkout API contract and controller flow** aligned with the “cart-as-canonical-truth” model. This ticket updates the checkout request DTO, enforces idempotency at the API boundary, removes legacy `AttributedAdClickID` usage, and updates the controller to pass checkout-confirmed inputs into the checkout service. The controller must rely on `cart_records.ad_tokens` for attribution and return a post-checkout response that reflects confirmed checkout data (shipping address, payment method, shipping line) alongside created vendor orders.

This establishes a stable, idempotent API boundary before deeper service, attribution, and outbox work.

## Scope

### What is included

* Define a new checkout request DTO including:

  * `cart_id`
  * `shipping_address` (required; confirm or override cart address)
  * `payment_method` (enum)
  * optional `shipping_line` (future-safe, Shopify-like)
* Enforce presence of an **idempotency header** on `POST /checkout`
* Wire idempotency key from request headers into checkout service input
* Update checkout controller to:

  * Remove `AttributedAdClickID` from request handling
  * Rely exclusively on `cart_records.ad_tokens` (no ad data in request body)
  * Call a single checkout service method with the new input shape
* Update checkout response mapping to:

  * Return a `CartQuote`-like view post-checkout **or**
  * Extend existing checkout response to include confirmed `shipping_address`, `payment_method`, and `shipping_line`

### What is explicitly NOT included

* Checkout service refactor logic (order creation, reservation, attribution)
* Goose migrations or model changes
* Outbox event emission
* Attribution validation or materialization
* Payment processing behavior changes

## Acceptance Criteria

* [ ] `POST /checkout` rejects requests without a valid idempotency header
* [ ] Checkout request DTO validates required fields (`cart_id`, `shipping_address`, `payment_method`)
* [ ] Controller no longer accepts or references `AttributedAdClickID`
* [ ] Controller passes idempotency key and new checkout input into the checkout service
* [ ] Successful checkout response includes confirmed checkout fields (shipping address, payment method, shipping line) in a stable response shape (`CartQuote`-like repsonse)
* [ ] Existing checkout routes compile and pass request validation with the new DTO

## Dependencies

### Blocked by

* None (API-layer work only)

### Blocks

* Checkout service refactor (cart finalization, vendor order creation)
* Idempotent execution logic in checkout service
* Attribution materialization tickets
* Outbox emission tickets

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * API: `POST /checkout`
  * Controller: `Checkout` handler
  * DTOs: `checkoutRequest`, optional `ShippingLineInput`
  * Middleware: idempotency enforcement
* Assumptions (explicitly marked):

  * **ASSUMPTION:** An idempotency middleware exists or will accept a generic key (e.g. `Idempotency-Key`) without persistence yet.
  * **ASSUMPTION:** `enums.PaymentMethod` already exists and is reusable at the API boundary.
  * **ASSUMPTION:** Cart-derived `ad_tokens` are already persisted and available to the checkout service.

## Out of Scope

* Persisting checkout-confirmed fields to the database
* Changing checkout service behavior or repository interfaces
* Removing legacy database tables or adding new columns
* Actual execution service layer logic
* Attribution materialization tickets
* Outbox emission tickets

---

# Title [PF-173]: Refactor checkout execution to load and validate cart by `(buyer_store_id, cart_id)`

## Type

Task

## Description

Refactor `checkout.Service.Execute` to load the cart record using `(buyer_store_id, cart_id)` and treat the cart as the canonical source of truth. The service must validate that the cart is eligible for checkout before any mutations occur.

This establishes a single, correct entry point for checkout execution and removes legacy assumptions tied to prior checkout flows.

## Scope

### What is included

* Load `CartRecord` by `(buyer_store_id, cart_id)` inside checkout transaction
* Validate cart state:

  * `status == active`
  * Cart contains at least one orderable item (`cart_items.status = ok`)
* Return deterministic validation errors for invalid carts

### What is explicitly NOT included

* Cart mutation or status transitions
* Vendor order creation
* Inventory reservation
* Idempotency handling

## Acceptance Criteria

* [ ] Checkout fails if cart does not belong to buyer store
* [ ] Checkout fails if cart status is not `active`
* [ ] Checkout fails if no cart items have `status=ok`
* [ ] All validations occur before any database writes

## Dependencies

### Blocked by

* None

### Blocks

* Cart finalization logic
* Vendor order creation pipeline

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Service: `checkout.Service.Execute`
  * Tables: `cart_records`, `cart_items`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** `cart_items.status` is already authoritative and populated by quote flow.

## Out of Scope

* Updating cart fields
* Writing vendor orders or payment intents

---

# Title [PF-174]: Finalize cart during checkout and establish idempotent checkout anchor

## Type

Task

## Description

Implement the cart finalization step inside the checkout transaction. Checkout must overwrite or confirm checkout-specific fields on the cart, transition its status to `converted`, and establish a stable checkout grouping anchor via `checkout_group_id` that is reused on retries.

This ensures the cart remains the auditable source of truth before and after checkout.

## Scope

### What is included

* Overwrite `cart_records.shipping_address` with checkout-confirmed address
* Persist `payment_method` and optional `shipping_line` on cart
* Set `converted_at` timestamp
* Transition cart status from `active` → `converted`
* Generate `checkout_group_id` once if not present
* Reuse existing `checkout_group_id` on retry paths
* Propagate `checkout_group_id` to all created `vendor_orders`

### What is explicitly NOT included

* Vendor order creation logic
* Inventory reservation
* Outbox event emission

## Acceptance Criteria

* [ ] Cart fields are updated atomically within checkout transaction
* [ ] `checkout_group_id` is generated once and reused on retries
* [ ] Cart status is `converted` only after successful finalization
* [ ] No duplicate checkout anchors are created for the same cart

## Dependencies

### Blocks

* Vendor order creation
* Idempotent checkout behavior

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Tables: `cart_records`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** `checkout_group_id` exists on `cart_records` and is nullable pre-checkout.

## Out of Scope

* Returning checkout results
* Cleanup of legacy checkout artifacts

---

# Title [PF-175]: Build vendor order creation pipeline from cart vendor groups and items

## Type

Feature

## Description

Create vendor orders directly from the canonical cart snapshot. Vendor order totals must be sourced from `cart_vendor_groups`, and line-item pricing must come from persisted `cart_items`, with no recomputation of pricing or discounts.

## Scope

### What is included

* Group cart items by `vendor_store_id`
* Use `cart_vendor_groups` as the canonical source for:

  * Subtotal
  * Discounts
  * Total
* Create one `vendor_order` per vendor with eligible items
* Populate vendor order fields from cart snapshot + checkout-confirmed data

### What is explicitly NOT included

* Inventory reservation
* Attribution materialization
* Payment intent creation

## Acceptance Criteria

* [ ] Vendor orders are created only from cart snapshot data
* [ ] No pricing or discount recomputation occurs (pricing discrepencies handled in later ticket during reservation)
* [ ] Vendor order totals match `cart_vendor_groups` exactly
* [ ] Vendor orders reference `cart_id` and `checkout_group_id`

## Dependencies

### Blocked by

* PF-XXX

### Blocks

* Line item creation
* Payment intent creation

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Tables: `cart_vendor_groups`, `cart_items`, `vendor_orders`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** `cart_vendor_groups` always reflect the authoritative totals at quote time.

## Out of Scope

* Vendor rejection logic
* Partial fulfillment handling

---

# Title [PF-176]: Enforce vendor eligibility rules and create order line items from cart snapshots

## Type

Task

## Description

Implement vendor eligibility and line-item creation rules. Vendor orders must only be created if the vendor has at least one eligible cart item. Order line items must be created as snapshots of cart items, including warnings and volume discount context.

## Scope

### What is included

* Create vendor order only if vendor has ≥1 cart item with `status=ok`
* Skip vendor order creation entirely if no eligible items exist
* Create `order_line_items` from cart items:

  * Persist warnings and applied volume discounts where available
* Record vendor-level rejection reason in response when vendor has no eligible items

### What is explicitly NOT included

* Inventory reservation
* Payment intent creation
* Outbox events

## Acceptance Criteria

* [ ] No vendor order is created if all cart items are ineligible
    * [ ] If ineligible Vendor-level rejection/warning is returned in the `CartQuote`-like  response so client can see all orders including rejcted vendors
* [ ] Each order line item references its originating `cart_item_id`
* [ ] Line item warnings and discounts match cart snapshot
* [ ] Vendor-level rejection is surfaced deterministically

## Dependencies

### Blocked by

* PF-XXX

### Blocks

* Inventory reservation
* Payment intent creation

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Tables: `order_line_items`, `cart_items`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** Cart item warnings and discounts are already persisted correctly.

## Out of Scope

* Reservation failure handling
* Attribution logic

---
# Title [PF-177]: Create payment intents per vendor order using checkout-selected payment method

## Type

Task

## Description

Create a `payment_intent` for each vendor order using the vendor order totals and the payment method selected during checkout. This ensures payment tracking remains vendor-scoped and consistent with existing payment flows.

## Scope

### What is included

* Create one `payment_intent` per vendor order
* Use vendor order total cents as intent amount
* Set payment method from checkout-confirmed value
* Preserve existing default payment status behavior

### What is explicitly NOT included

* Payment processing or settlement logic
* ACH/CC integrations

## Acceptance Criteria

* [ ] Each vendor order has exactly one payment intent
* [ ] Payment intent amount matches vendor order total
* [ ] Payment method matches checkout selection
* [ ] Defaults for payment status remain unchanged

## Dependencies

### Blocked by

* PF-XXX

### Blocks

* Checkout completion
* Outbox event emission

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Tables: `payment_intents`, `vendor_orders`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** `payment_method` enum is shared between orders and payment intents.

## Out of Scope

* Handling of payment failures
* Refund logic

---

# Title [PF-178]: Perform inventory reservation at checkout and map failures to line items and vendors [UNDONE ❌]

## Type

Feature

## Description

Move inventory reservation exclusively to checkout execution. Only cart items marked as orderable should be reserved. Reservation failures must be reflected in order line item status and, when applicable, escalate to vendor-level rejection behavior.

## Scope

### What is included

* Generate reservation requests only for `cart_items.status=ok`
* Execute reservation inside checkout transaction
* Map reservation failure to:

  * `order_line_items.status = rejected`
  * `notes/reason` populated
* Apply vendor-level rejection when all items for a vendor fail reservation

### What is explicitly NOT included

* Re-quoting or cart mutation logic
* Notification or analytics events

## Acceptance Criteria

* [ ] Inventory is reserved only during checkout
* [ ] Reservation failures reject individual line items
* [ ] Vendors with all items rejected are marked rejected
* [ ] Successful reservations leave line items pending

## Dependencies

### Blocked by

* PF-XXX

### Blocks

* Checkout completion
* Attribution materialization

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Reservation engine
  * Tables: `inventory_items`, `order_line_items`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** Inventory reservation remains atomic at the DB level.

## Out of Scope

* Re-adding rejected items to cart
* Inventory release logic

---

# Title [PF-179]: Enforce cart-truth pricing and prevent recomputation during checkout execution [UNDONE ❌]

## Type

Task

## Description

Ensure checkout execution never recomputes pricing or discounts. Pricing, discounts, and totals must come exclusively from the cart snapshot. The only permitted invalidation at checkout time is inventory reservation failure, which may adjust effective totals by adding rejected items warnign and removing qunatiy. This will initiate a final check once all items are done to recaclulate totals.

## Scope

### What is included

* Remove or bypass any pricing/discount recomputation in checkout service
* Ensure vendor totals are adjusted only due to rejected line items (insufficient available quantity)
* Recalculate vendor totals only as a consequence of reservation failures

### What is explicitly NOT included

* Cart quote recalculation
* Discount or promo validation logic

## Acceptance Criteria

* [ ] Checkout does not recompute unit prices or discounts
* [ ] Vendor totals change only when items are rejected
* [ ] Checkout output remains deterministic for the same cart snapshot

## Dependencies

### Blocked by

* PF-XXX

### Blocks

* Attribution emission
* Outbox analytics accuracy

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * Service: `checkout.Service.Execute`
* Assumptions (explicitly marked):

  * **ASSUMPTION:** Cart snapshot pricing is always authoritative at checkout entry.

## Out of Scope

* Quote regeneration
* Price corrections post-checkout


---


# LATER TICKETS WITH AD INTEGRATION [UNDONE ❌]:
* [ ] **Ticket:** Implement ad token validation during checkout: decode/verify signature, expiry, enums, and `buyer_store_id` binding; deterministic drop-or-error policy

* [ ] **Ticket:** Materialize attribution deterministically at checkout:

  * order-level (store tokens → `vendor_orders.attributed_token`)
  * line-item-level (product tokens → `order_line_items.attributed_token`)
  * priority: click > impression, newest wins, stable tie-break

* [ ] **Ticket:** Persist attribution blobs onto vendor orders + line items within the checkout transaction


# IDEMOPTENCY & EMISSION [UNDONE ❌]:
* [ ] **Ticket:** Implement idempotent execution path: if cart already `converted`, return existing checkout result (lookup by `cart_records.checkout_group_id` + vendor_orders) and do not create duplicates & Ensure “exactly-once-ish” outbox emission: no duplicate outbox rows on retries for the same conversion anchor

* [ ] **Ticket:** Emit **Notifications** outbox event from conversion transaction (vendor orders created) including `checkout_group_id`, `cart_id`, buyer/vendor ids, vendor_order_ids & Emit **Analytics** outbox event from conversion transaction (checkout converted) including cart totals + attribution references/token_ids & Update outbox payload structs/enums and versioning for both events (no consumer work yet unless required)

# CLEANUP [UNDONE ❌]:
* [ ] **Ticket:** Remove legacy checkout artifacts in code: delete `CreateCheckoutGroup` usage and any references to dropped `checkout_groups` table & Remove `AttributedAdClickID` usage end-to-end (controller DTO, service input, event payloads) now that `ad_tokens` are canonical


# TESTS [UNDONE ❌]:
* [ ] **Ticket:** Add/Update regression tests for:

  * idempotent retry returns same result (no duplicate vendor orders/outbox)
  * cart expired / already converted
  * partial reservation failures (line-item rejected, vendor-level handling)
  * attribution selection rules
  * outbox emits exactly two events on successful conversion
