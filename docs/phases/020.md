# Title [PF-168]: Drop `checkout_groups` table and migrate checkout anchor to `checkout_group_id` UUID on cart + orders

## Type

Task

## Description

Remove the `checkout_groups` table and refactor persistence to use `checkout_group_id` (UUID) as the grouping anchor stored on `cart_records` and `vendor_orders`. This aligns with the new architecture where **CartRecord is canonical**, and “checkout group” becomes an identifier rather than a separate persisted aggregate.

## Scope

* What is included

  * Goose migration that drops `checkout_groups` table (and any FKs that reference it)
  * Ensure `vendor_orders.checkout_group_id` remains as a UUID grouping anchor (not FK)
  * Ensure `cart_records.checkout_group_id` remains (already present) and is used as the canonical conversion id
  * Update any FK constraints that currently reference `checkout_groups(id)` (remove/replace)
* What is explicitly NOT included

  * Refactoring checkout service/controller logic (separate tickets)
  * Changing API response shapes
  * Rewriting outbox consumers

## Acceptance Criteria

* [ ] Migration runs cleanly on an existing DB (no orphaned FK constraints)
* [ ] `checkout_groups` table no longer exists
* [ ] `vendor_orders.checkout_group_id` is a plain UUID column (indexed), not a FK
* [ ] `cart_records.checkout_group_id` remains intact and nullable (until conversion)

## Dependencies

* Blocked by:

  * None (schema-only change; ensure downstream code tickets follow)
* Blocks:

  * Vendor order schema refactor tickets
  * Checkout service refactor tickets

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `checkout_groups` (drop), `vendor_orders`, `cart_records`
  * Constraints: remove `vendor_orders.checkout_group_id -> checkout_groups(id)` FK if present
  * Index: add/ensure `idx_vendor_orders_checkout_group_id` and `idx_cart_records_checkout_group_id`
* Assumptions (explicitly marked)

  * **ASSUMPTION:** Existing reads of checkout results can be re-anchored to `vendor_orders.checkout_group_id` without needing `checkout_groups`.

## Out of Scope

* Service-layer idempotency behavior and “return existing checkout result” logic

---

# Title [PF-169]: Extend `vendor_orders` to snapshot checkout-confirmed fields + vendor-group discounts/warnings/promo

## Type

Task

## Description

Modify `vendor_orders` to capture the **order-time snapshot** required by the new checkout flow, mirroring what exists on `CartRecord`/`CartVendorGroup`, plus checkout-confirmed extensions (payment/shipping). This reduces recomputation and prevents drift between the cart quote and the created orders.

## Scope

* What is included

  * Goose migration to add/rename columns on `vendor_orders` to support:

    * `cart_id` (UUID, not null) — link back to canonical cart snapshot
    * `currency` (text/enum) — align with cart currency
    * `shipping_address` (`shipping_address`) — confirmed/overwritten address at checkout time
    * `discounts_cents` (int) — align naming with cart (`discounts_cents` vs `discount_cents`)
    * `warnings` (jsonb) — vendor-level warnings (mirror `CartVendorGroup.Warnings`)
    * `promo` (jsonb) — mirror `CartVendorGroup.Promo` (code/amount)
    * `payment_method` (enum/payment_method) — snapshot of chosen method (also stored in PaymentIntent, but order should carry it)
    * `shipping_line` (jsonb) OR explicit fields (`shipping_code`, `shipping_title`, `shipping_price_cents`) — future-safe “Shopify-ish” line
    * `attributed_token` (jsonb, nullable) — selected attribution blob for vendor/store-level attribution
  * Update GORM `models.VendorOrder` accordingly
* What is explicitly NOT included

  * Checkout service computation logic for these fields
  * Attribution selection logic
  * Outbox payload changes

## Acceptance Criteria

* [ ] `vendor_orders` has `cart_id` and can be joined back to `cart_records(id)`
* [ ] `vendor_orders` can store vendor-level `warnings` + `promo` consistently with `CartVendorGroup`
* [ ] `vendor_orders` can store checkout-confirmed `shipping_address`, `payment_method`, and `shipping_line`
* [ ] Existing order creation still compiles after GORM updates (even if values are not populated yet)
* [ ] Columns are nullable where appropriate to avoid breaking existing rows

## Dependencies

* Blocked by:

  * PF-201 (drop checkout_groups + remove FK dependency)
* Blocks:

  * Checkout service refactor (needs these columns to persist final snapshot)

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `vendor_orders`, `cart_records`, `cart_vendor_groups`
  * Consider renaming `discount_cents` → `discounts_cents` (or keep both with a deprecation plan)
* Assumptions (explicitly marked)

  * **ASSUMPTION:** `address_t` already exists and is used by `cart_records.shipping_address`.
  * **ASSUMPTION:** `payment_method` enum already exists (used by `PaymentIntent.Method`) and can be reused on `vendor_orders`.

## Out of Scope

* Reconciliation/backfill of historical orders beyond minimal defaults

---

# Title [PF-170]: Extend `order_line_items` to reference cart items + persist item warnings/discount context + attribution

## Type

Task

## Description

Update `order_line_items` to faithfully represent the **cart item snapshot** used at checkout, including warnings/status context and deterministic attribution for product-level tokens. This supports analytics and “explainability” without recomputing cart logic after checkout.

## Scope

* What is included

  * Goose migration to add fields to `order_line_items`:

    * `cart_item_id` (uuid, nullable initially; ideally not null for new rows) — ties back to canonical cart line
    * `warnings` (jsonb) — mirror `CartItem.Warnings`
    * `applied_volume_discount` (jsonb) — mirror `CartItem.AppliedVolumeDiscount`
    * `moq` (int) and `max_qty` (int nullable) — optional snapshot (mirrors cart)
    * `line_subtotal_cents` (int) — optional but aligns with cart’s authoritative line subtotal (distinct from order line `total_cents`)
    * `attributed_token` (jsonb, nullable) — product-level attribution selection
  * Update GORM `models.OrderLineItem` accordingly
* What is explicitly NOT included

  * Reservation engine changes
  * Attribution decision rules implementation
  * New API response fields

## Acceptance Criteria

* [ ] `order_line_items` can store warnings and applied volume discount JSONB
* [ ] `order_line_items` can link to the originating `cart_items` row (via `cart_item_id`)
* [ ] Schema changes are non-breaking for existing rows (nullable additions + safe defaults)
* [ ] GORM model compiles and can read/write the new fields

## Dependencies

* Blocked by:

  * PF-202 (vendor_orders refactor is usually paired; not strictly required but strongly coupled)
* Blocks:

  * Checkout attribution materialization ticket
  * “build orders from cart snapshot” refactor ticket

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Tables: `order_line_items`, `cart_items`
  * JSONB types should reuse existing serializer patterns used in `CartItem` (`types.CartItemWarnings`, `types.AppliedVolumeDiscount`)
* Assumptions (explicitly marked)

  * **ASSUMPTION:** You want line items to remain a stable snapshot even if products later change (current model already does snapshotting via `Name`, `Category`, etc.).

## Out of Scope

* Migrating historical orders to backfill cart_item_id

---

### Quick “what fields should VendorOrder mirror from Cart?”

To keep order creation dumb and deterministic, the vendor order should be able to carry:

* **From CartRecord:** `cart_id`, `buyer_store_id`, `currency`, confirmed `shipping_address`, `ad attribution (materialized)`, and totals
* **From CartVendorGroup:** `subtotal_cents`, `promo`, `warnings`, `total_cents`, plus vendor-level `discounts_cents` if you want symmetry
* **Checkout confirmed:** `payment_method`, `shipping_line/transport_fee`, `converted_at`

That gives you: **cart → checkout → vendor orders** with minimal re-derivation and easy analytics.

---

# Title [PF-171]: Add checkout-confirmed fields to `cart_records` for finalized cart snapshot

## Type

Task

## Description

Extend `cart_records` so checkout can overwrite/confirm shipping address and persist checkout selections (payment method + shipping line) before flipping the cart to `converted`. This makes the cart the auditable source of truth **both pre- and post-checkout**.

## Scope

* What is included

  * Goose migration to add fields to `cart_records`:

    * `payment_method` (enum/text) — chosen at checkout
    * `shipping_line` (jsonb) OR explicit fields (`shipping_code`, `shipping_title`, `shipping_price_cents`)
    * `converted_at` (timestamptz nullable)
  * Update GORM `models.CartRecord` to include these fields
* What is explicitly NOT included

  * Checkout service logic changes
  * Cart quote service logic changes

## Acceptance Criteria

* [ ] `cart_records` can store payment method + shipping line selection
* [ ] `cart_records.converted_at` is settable at conversion time
* [ ] Existing cart quote read/write paths still compile after model updates

## Dependencies

* Blocked by:

  * None
* Blocks:

  * Checkout service refactor (finalize cart + convert status)

## Technical Notes

* Relevant services, tables, APIs, queues, or workers

  * Table: `cart_records`
  * Enum reuse: `payment_method` should reuse `PaymentIntent.Method` enum/type if present
* Assumptions (explicitly marked)

  * **ASSUMPTION:** Shipping line is persisted as a single selection (not multiple).

## Out of Scope

* Any pricing computation for shipping lines (MVP can store selection only)

--

# Title [PF-172]: Implement new Checkout API DTO, controller wiring, and idempotent request handling

## Type

Feature

## Description

Implement the new **checkout API contract and controller flow** aligned with the “cart-as-canonical-truth” model. This ticket updates the checkout request DTO, enforces idempotency at the API boundary, removes legacy `AttributedAdClickID` usage, and updates the controller to pass checkout-confirmed inputs into the checkout service. The controller must rely on `cart_records.ad_tokens` for attribution and return a post-checkout response that reflects confirmed checkout data (shipping address, payment method, shipping line) alongside created vendor orders.

This establishes a stable, idempotent API boundary before deeper service, attribution, and outbox work.

## Scope

### What is included

* Define a new checkout request DTO including:

  * `cart_id`
  * `shipping_address` (required; confirm or override cart address)
  * `payment_method` (enum)
  * optional `shipping_line` (future-safe, Shopify-like)
* Enforce presence of an **idempotency header** on `POST /checkout`
* Wire idempotency key from request headers into checkout service input
* Update checkout controller to:

  * Remove `AttributedAdClickID` from request handling
  * Rely exclusively on `cart_records.ad_tokens` (no ad data in request body)
  * Call a single checkout service method with the new input shape
* Update checkout response mapping to:

  * Return a `CartQuote`-like view post-checkout **or**
  * Extend existing checkout response to include confirmed `shipping_address`, `payment_method`, and `shipping_line`

### What is explicitly NOT included

* Checkout service refactor logic (order creation, reservation, attribution)
* Goose migrations or model changes
* Outbox event emission
* Attribution validation or materialization
* Payment processing behavior changes

## Acceptance Criteria

* [ ] `POST /checkout` rejects requests without a valid idempotency header
* [ ] Checkout request DTO validates required fields (`cart_id`, `shipping_address`, `payment_method`)
* [ ] Controller no longer accepts or references `AttributedAdClickID`
* [ ] Controller passes idempotency key and new checkout input into the checkout service
* [ ] Successful checkout response includes confirmed checkout fields (shipping address, payment method, shipping line) in a stable response shape (`CartQuote`-like repsonse)
* [ ] Existing checkout routes compile and pass request validation with the new DTO

## Dependencies

### Blocked by

* None (API-layer work only)

### Blocks

* Checkout service refactor (cart finalization, vendor order creation)
* Idempotent execution logic in checkout service
* Attribution materialization tickets
* Outbox emission tickets

## Technical Notes

* Relevant services, tables, APIs, queues, or workers:

  * API: `POST /checkout`
  * Controller: `Checkout` handler
  * DTOs: `checkoutRequest`, optional `ShippingLineInput`
  * Middleware: idempotency enforcement
* Assumptions (explicitly marked):

  * **ASSUMPTION:** An idempotency middleware exists or will accept a generic key (e.g. `Idempotency-Key`) without persistence yet.
  * **ASSUMPTION:** `enums.PaymentMethod` already exists and is reusable at the API boundary.
  * **ASSUMPTION:** Cart-derived `ad_tokens` are already persisted and available to the checkout service.

## Out of Scope

* Persisting checkout-confirmed fields to the database
* Changing checkout service behavior or repository interfaces
* Removing legacy database tables or adding new columns
* Actual execution service layer logic
* Attribution materialization tickets
* Outbox emission tickets

---

ORDER / CHECKOUT SERVICE
* [ ] **Ticket:** Refactor `checkout.Service.Execute` to load cart by `(buyer_store_id, cart_id)` and validate `status=active`, `valid_until`, and presence of orderable items (`cart_items.status=ok`)

* [ ] **Ticket:** Implement “finalize cart” step inside checkout transaction: overwrite `cart_records.shipping_address`, persist `payment_method`, persist `shipping_line`, set `converted_at`, and transition status to `converted` & Implement checkout grouping anchor behavior: generate/set `cart_records.checkout_group_id` once and reuse on retries; propagate to created `vendor_orders.checkout_group_id`

* [ ] **Ticket:** Build vendor order creation pipeline from `cart_vendor_groups` (canonical totals) + `cart_items` (canonical pricing)

* [ ] **Ticket:** Implement vendor-order creation rule: create vendor order only if vendor has ≥1 eligible cart item (`status=ok`); otherwise record vendor-level rejection in response & Create `order_line_items` from cart item snapshots (including warnings/volume discount fields where added) and persist `cart_item_id` reference

* [ ] **Ticket:** Create `payment_intents` per vendor order using vendor group totals + chosen payment method (status defaults unchanged)

* [ ] **Ticket:** Update inventory reservation to operate only at checkout time and only for `cart_items.status=ok` & Map reservation failures to `order_line_items` (`rejected` + notes/reason) and apply vendor-level rejection behavior when all items fail reservation

* [ ] **Ticket:** Ensure checkout does **not** recompute pricing/discounts; only reservation can invalidate an item at execution time. If inventory reservation fails recaclulate price for line item(s) & vendor totals. 


LATER TICKETS WITH AD INTEGRATION:
* [ ] **Ticket:** Implement ad token validation during checkout: decode/verify signature, expiry, enums, and `buyer_store_id` binding; deterministic drop-or-error policy

* [ ] **Ticket:** Materialize attribution deterministically at checkout:

  * order-level (store tokens → `vendor_orders.attributed_token`)
  * line-item-level (product tokens → `order_line_items.attributed_token`)
  * priority: click > impression, newest wins, stable tie-break

* [ ] **Ticket:** Persist attribution blobs onto vendor orders + line items within the checkout transaction


IDEMOPTENCY & EMISSION
* [ ] **Ticket:** Implement idempotent execution path: if cart already `converted`, return existing checkout result (lookup by `cart_records.checkout_group_id` + vendor_orders) and do not create duplicates & Ensure “exactly-once-ish” outbox emission: no duplicate outbox rows on retries for the same conversion anchor

* [ ] **Ticket:** Emit **Notifications** outbox event from conversion transaction (vendor orders created) including `checkout_group_id`, `cart_id`, buyer/vendor ids, vendor_order_ids & Emit **Analytics** outbox event from conversion transaction (checkout converted) including cart totals + attribution references/token_ids & Update outbox payload structs/enums and versioning for both events (no consumer work yet unless required)

CLEANUP 
* [ ] **Ticket:** Remove legacy checkout artifacts in code: delete `CreateCheckoutGroup` usage and any references to dropped `checkout_groups` table & Remove `AttributedAdClickID` usage end-to-end (controller DTO, service input, event payloads) now that `ad_tokens` are canonical


TESTS
* [ ] **Ticket:** Add/Update regression tests for:

  * idempotent retry returns same result (no duplicate vendor orders/outbox)
  * cart expired / already converted
  * partial reservation failures (line-item rejected, vendor-level handling)
  * attribution selection rules
  * outbox emits exactly two events on successful conversion
