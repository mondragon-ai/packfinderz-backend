# Title [PF-146]:  Migrate cart schema to authoritative quote model (CartRecord, CartItem, Vendor Groups)

## Type

Task

## Description

Update the persistence layer to align with the new **authoritative cart quote model**.
This migration replaces legacy cart fields that no longer match the quote-based flow, introduces new enums and columns required for item/vendor status and warnings, and adds support for checkout conversion via `checkout_group_id`.

`cart_records` becomes the single auditable source of truth for cart quotes, storing validated quantities, authoritative pricing, warnings, and attribution metadata. No parallel tables should be introduced beyond what is explicitly required.

All changes must be implemented in **one Goose migration**, modifying existing tables in place.

## Scope

### Included

* Create required Postgres enums for cart, item, and vendor-group status/warnings
* Modify `cart_records` table:

  * Add new fields (`checkout_group_id`, `valid_until`, `discounts_cents`, `ad_tokens`)
  * Remove deprecated fields (`session_id`, `fees`, `total_discount`, `cart_level_discount`)
  * Ensure schema matches authoritative cart quote model
* Modify `cart_items` table:

  * Add vendor grouping, authoritative pricing, constraints, status, and warnings fields
  * Remove or deprecate fields that conflict with the new model
* Create new `cart_vendor_groups` table to persist vendor-level aggregation and warnings
* Add all required indexes and unique constraints
* Ensure migration is safe for existing data (nullable additions, defaults where needed)

### Explicitly NOT Included

* Any repository, service, DTO, or API-layer changes
* Checkout execution, inventory reservation, or payment logic
* Client-side cart shape or UI concerns
* Data backfill beyond defaults/nullability required for migration safety

## Acceptance Criteria

* [ ] All required Postgres enums (`cart_status`, `cart_item_status`, `vendor_group_status`, warning enums) are created and usable
* [ ] `cart_records` schema matches the new authoritative model, with deprecated columns removed
* [ ] `cart_items` schema includes vendor grouping, pricing, constraints, status, and warnings fields
* [ ] `cart_vendor_groups` table exists with correct fields and `(cart_id, vendor_store_id)` unique constraint
* [ ] All specified indexes are present and valid
* [ ] Migration runs successfully on an existing database without data loss or runtime errors
* [ ] No parallel or duplicate cart tables are introduced

## Dependencies

* Blocked by: Final approval of authoritative cart quote schema (DTO + domain model)
* Blocks:

  * Phase 2: Domain Models & Repositories
  * Phase 3: DTOs & Mapping Helpers
  * Phase 4: Cart Quote Service

## Technical Notes

* Migration tool: **Goose**
* ORM: **GORM**
* Affected tables:

  * `cart_records`
  * `cart_items`
  * `cart_vendor_groups` (new)
* Enums must be created before columns that depend on them
* JSON fields (`warnings`, `applied_volume_discount`, `promo`) must use `jsonb`
* **ASSUMPTION:** Existing `address_t` composite type is already defined and reusable for `shipping_address`
* **ASSUMPTION:** Platform currency default is `USD` unless otherwise specified


### Target DB Schema (authoritative)

#### Postgres enums (MUST exist)

* `cart_status`: `active`, `converted`
* `cart_item_status`: `ok`, `not_available`, `invalid`
* `cart_item_warning_type`:

  * `clamped_to_moq`
  * `clamped_to_max`
  * `price_changed`
  * `not_available`
  * `vendor_invalid`
  * `vendor_mismatch`
  * `invalid_promo`
* `vendor_group_status`: `ok`, `invalid`
* `vendor_group_warning_type`:

  * `vendor_invalid`
  * `vendor_suspended`
  * `license_invalid`
  * `invalid_promo`

#### JSON shapes (stored as `jsonb`)

We’ll store warnings as JSONB arrays for flexibility and forward compatibility.

**`cart_item_warning` JSON element**

```json
{ "type": "clamped_to_moq", "message": "..." }
```

**`vendor_group_warning` JSON element**

```json
{ "type": "license_invalid", "message": "..." }
```

**`applied_volume_discount` JSON object**

```json
{ "label": "10% off 1lb+", "amount_cents": 500 }
```

**`vendor_group_promo` JSON object**

```json
{ "code": "SAVE20", "amount_cents": 2000 }
```

---

### Tables

#### `cart_records` (UPDATED)

Fields (proposed canonical persistence shape):

* `id uuid pk default gen_random_uuid()`
* `buyer_store_id uuid not null`
* `status cart_status not null default 'active'`
* `checkout_group_id uuid null`  ✅ NEW
* `shipping_address address_t null or not null` (your call; quote response requires it, but DB can keep nullable if buyer store missing address)
* `currency text not null default 'USD'` (or `'BRL'` if your platform currency is BRL—pick one)
* `valid_until timestamptz not null` ✅ NEW
* `subtotal_cents int not null default 0`
* `discounts_cents int not null default 0` ✅ NEW (replaces total_discount)
* `total_cents int not null default 0`
* `ad_tokens text[] null` ✅ NEW (pass-through)
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

**Fields to REMOVE from current model**

* `session_id` (not mentioned in new flow)
* `fees` (not in CartQuote)
* `total_discount` (replace with `discounts_cents`)
* `cart_level_discount[]` composite (replaced by vendor_groups + promo in new shape)

#### `cart_items` (UPDATED)

Fields:

* `id uuid pk default gen_random_uuid()`
* `cart_id uuid not null fk cart_records(id) on delete cascade`
* `product_id uuid not null`
* `vendor_store_id uuid not null` ✅ NEW (required for grouping without N product fetches)
* `quantity int not null`
* `moq int not null`
* `max_qty int null`
* `unit_price_cents int not null` ✅ REQUIRED
* `applied_volume_discount jsonb null` ✅ NEW
* `line_subtotal_cents int not null` ✅ REQUIRED
* `status cart_item_status not null default 'ok'` ✅ REQUIRED
* `warnings jsonb null` ✅ REQUIRED (array)
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

#### `cart_vendor_groups` (NEW TABLE — recommended)

Because vendor_groups are part of the persisted authoritative quote, don’t hide them as “computed on read” if you want auditability and clean checkout fan-out.

Fields:

* `id uuid pk default gen_random_uuid()`
* `cart_id uuid not null fk cart_records(id) on delete cascade`
* `vendor_store_id uuid not null`
* `status vendor_group_status not null default 'ok'`
* `warnings jsonb null`
* `subtotal_cents int not null default 0`
* `promo jsonb null`
* `total_cents int not null default 0`
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

Unique constraint:

* `(cart_id, vendor_store_id)` unique

---

### Indexes (MUST)

* `cart_records(buyer_store_id, status)`
* `cart_records(checkout_group_id)` (optional but likely)
* `cart_items(cart_id)`
* `cart_items(vendor_store_id)`
* `cart_items(product_id)`
* `cart_vendor_groups(cart_id)`
* `cart_vendor_groups(vendor_store_id)`
* `cart_vendor_groups(cart_id, vendor_store_id)` unique


## Out of Scope

* Writing or updating GORM models
* Writing conversion/backfill scripts beyond schema defaults
* Any logic related to cart quoting, validation, promos, attribution, or checkout
Here’s the rearranged plan with your requested consolidation, plus the **exact target DB/GORM shapes + Postgres enums/types** so Goose knows what to change. I’m staying strictly within this thread’s scope.

---

#  Title [PF-147]:  Update and add GORM models to match authoritative cart quote schema

## Type

Task

## Description

Update existing GORM models and introduce new models to reflect the authoritative cart quote schema introduced in Phase 1 (see the GOose migration `pkg/migrate/migrations/20260306000000_cart_modifications.sql`).
Models must align **exactly** with the new database structure created by the Goose migration, including enums, JSON fields, and relationships.

This ensures the ORM layer accurately represents persisted cart records, cart items, and vendor group aggregates used for quoting and later checkout conversion.

## Scope

### Included

* Update `CartRecord` GORM model to reflect new schema:

  * Add `checkout_group_id`, `valid_until`, `discounts_cents`, `currency`, `ad_tokens`
  * Remove deprecated fields (`session_id`, `fees`, `total_discount`, `cart_level_discount`)
  * Add `vendor_groups` referncing the new table (see the GOose migration `pkg/migrate/migrations/20260306000000_cart_modifications.sql`).
* Update `CartItem` GORM model:

  * Add `vendor_store_id`, `applied_volume_discount`, pricing fields, constraints, status enum, warnings JSON {
      type:
        | "clamped_to_moq"
        | "clamped_to_max"
        | "price_changed"
        | "not_available"
        | "vendor_invalid"
        | "vendor_mismatch"
        | "invalid_promo"
      message: string
    }
  * Align field names (`quantity`, `line_subtotal_cents`) with DB schema

* Create new `CartVendorGroup` GORM model mapped to `cart_vendor_groups` 
* Map Postgres enums (`cart_item_status`, `vendor_group_status`) to Go enums
* Ensure JSONB fields are correctly typed (`json.RawMessage` or typed structs)

### Explicitly NOT Included

* Repository logic or persistence behavior
* DTOs or API contracts
* Business logic, validation, or pricing rules
* Database migrations (already completed in Phase 1)

## Acceptance Criteria

* [ ] `CartRecord` GORM model fields exactly match `cart_records` table schema
* [ ] `CartItem` GORM model fields exactly match `cart_items` table schema
* [ ] New `CartVendorGroup` GORM model exists and maps to `cart_vendor_groups`
* [ ] Enum fields use strongly typed Go enums corresponding to Postgres enums
* [ ] JSONB fields are correctly marshaled/unmarshaled without runtime errors

## Dependencies

* Blocked by:

  * PF-101: Cart schema Goose migration
* Blocks:

  * Cart repositories
  * Cart quote service

## Technical Notes

* Location: `pkg/db/models/*`
* ORM: **GORM**
* Enum definitions should live alongside existing enum patterns
* JSON fields (`warnings`, `promo`, `applied_volume_discount`) must not assume schema rigidity
* **ASSUMPTION:** Existing enum handling patterns are already established in `pkg/enums`

## Out of Scope

* Writing or updating repository logic
* Any cart quote computation or validation logic
* API exposure or DTO mapping

---

# Jira Ticket Template

## Title [PF-202]:  Update CartRecord repository for authoritative quote upsert semantics

## Type

Task

## Description

Update the CartRecord repository layer to support creating and updating authoritative cart quote records based on the new schema.
The repository must support deterministic upsert behavior for active carts scoped by buyer store, without introducing checkout or inventory concerns.

## Scope

### Included

* Update CartRecord repository methods to:

  * Create a new active cart record when none exists
  * Update existing active cart records with new quote snapshots
* Persist authoritative fields:

  * Totals, discounts, currency, valid_until
  * `checkout_group_id` (nullable)
  * `ad_tokens`
* Ensure status remains `active` during quote lifecycle

### Explicitly NOT Included

* CartItem or vendor group persistence
* Quote validation or pricing logic
* Cart conversion or checkout behavior

## Acceptance Criteria

* [ ] Repository can create a new `cart_records` row for a buyer store
* [ ] Repository can update an existing active cart record deterministically
* [ ] Deprecated fields are no longer read or written
* [ ] Repository operations are safe to call repeatedly with the same inputs

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * API layer

## Technical Notes

* Location: `pkg/db/repositories/cart_record_repo.go` (or equivalent)
* Must not assume cart uniqueness beyond `(buyer_store_id, status='active')`
* **ASSUMPTION:** Only one active cart per buyer store is enforced at service level

## Out of Scope

* Transaction coordination with cart items or vendor groups
* Idempotency handling (middleware concern)
* Checkout group assignment

---

# Jira Ticket Template

## Title [PF-203]:  Update CartItem repository to support replace-on-quote persistence

## Type

Task

## Description

Update the CartItem repository to support **replace-on-quote** semantics, where all cart items for a cart are replaced atomically based on the latest authoritative quote.

This ensures cart items always reflect server-validated quantities, pricing, statuses, and warnings.

## Scope

### Included

* Implement repository method to:

  * Delete existing cart items for a cart
  * Insert new cart items from the quote snapshot
* Persist all authoritative fields:

  * Quantity, MOQ, max_qty
  * Unit price, line subtotal
  * Status and warnings JSON
  * Vendor store linkage
* Support execution within an existing transaction

### Explicitly NOT Included

* CartRecord updates
* Vendor group persistence
* Quote computation logic

## Acceptance Criteria

* [ ] Existing cart items are fully replaced on each quote write
* [ ] All authoritative pricing and status fields are persisted correctly
* [ ] Repository functions correctly when executed inside a transaction
* [ ] No orphaned cart item rows remain after replacement

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * Vendor group persistence

## Technical Notes

* Location: `pkg/db/repositories/cart_item_repo.go`
* Must accept `*gorm.DB` transaction handle
* **ASSUMPTION:** Cart items are not incrementally updated; always replaced wholesale

## Out of Scope

* Item-level validation or warning generation
* Vendor grouping logic
* API or DTO concerns

---

# Jira Ticket Template

## Title [PF-204]:  Add CartVendorGroup repository with replace-on-quote behavior

## Type

Task

## Description

Introduce a repository for persisting vendor-level cart group aggregates (`cart_vendor_groups`).
These records store authoritative per-vendor totals, statuses, warnings, and applied promos as part of the cart quote snapshot.

## Scope

### Included

* Create repository for `cart_vendor_groups`
* Implement replace-on-quote behavior:

  * Delete existing vendor groups for cart
  * Insert new vendor groups from quote snapshot
* Persist:

  * Vendor status and warnings
  * Subtotals, promos, totals
* Support execution inside an existing transaction

### Explicitly NOT Included

* Promo validation logic
* Checkout order creation
* CartRecord or CartItem persistence

## Acceptance Criteria

* [ ] Vendor group rows are fully replaced per quote
* [ ] `(cart_id, vendor_store_id)` uniqueness is respected
* [ ] JSONB fields persist without schema assumptions
* [ ] Repository supports transactional execution

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * Cart conversion logic

## Technical Notes

* Location: `pkg/db/repositories/cart_vendor_group_repo.go`
* Must not assume vendor validity; status is authoritative input
* **ASSUMPTION:** Vendor group totals are computed upstream in service layer

## Out of Scope

* Vendor validation
* Promo code evaluation
* API exposure

---

# Jira Ticket Template

## Title [PF-205]:  Ensure atomic persistence of cart records, items, and vendor groups

## Type

Task

## Description

Ensure cart persistence is performed atomically by coordinating CartRecord, CartItem, and CartVendorGroup repositories within a single database transaction.

This guarantees that each cart quote snapshot is either fully written or not written at all.

## Scope

### Included

* Implement transactional wrapper coordinating:

  * CartRecord upsert
  * CartItem replace
  * CartVendorGroup replace
* Ensure transaction rollback on any failure
* Provide reusable helper or service-level transaction pattern

### Explicitly NOT Included

* Quote calculation or validation
* Checkout conversion
* API request handling

## Acceptance Criteria

* [ ] All cart-related writes occur within a single DB transaction
* [ ] Partial writes do not persist on failure
* [ ] Transaction boundaries are explicit and testable
* [ ] Repositories accept transaction handles consistently

## Dependencies

* Blocked by:

  * PF-202, PF-203, PF-204
* Blocks:

  * Cart quote service
  * API layer

## Technical Notes

* ORM: **GORM**
* Use `db.Transaction(func(tx *gorm.DB) error { ... })`
* **ASSUMPTION:** Service layer orchestrates transactional boundaries

## Out of Scope

* Retry or idempotency logic
* Performance optimization
* Metrics or logging instrumentation


---

# Phase 3 — DTOs & Mapping Helpers

**Goal:** Cleanly separate API contracts from persistence models.

* [ ] **Ticket:** Implement `QuoteCartRequest` DTO (minimal intent)
* [ ] **Ticket:** Implement `CartQuote` response DTO (authoritative quote)
* [ ] **Ticket:** Implement DB → CartQuote mapping helpers
* [ ] **Ticket:** Implement request → domain quote mapping helpers
* [ ] **Ticket:** Preserve item-level warnings, status, discounts end-to-end

---

# Phase 4 — Cart Quote Service (Core Logic)

**Goal:** Produce authoritative cart quotes without reserving inventory.

(Combined into fewer, cohesive tickets)

* [ ] **Ticket:** Implement buyer store validation + shipping address derivation
* [ ] **Ticket:** Implement product fetch + vendor ownership verification
* [ ] **Ticket:** Implement quantity normalization (MOQ / max) + warnings
* [ ] **Ticket:** Implement volume discount resolution + pricing calculation
* [ ] **Ticket:** Implement item-level status + warnings assignment
* [ ] **Ticket:** Implement vendor grouping + vendor invalidation logic
* [ ] **Ticket:** Implement cart totals calculation (exclude invalid items)
* [ ] **Ticket:** Enforce no inventory mutation in quote flow

---

# Phase 5 — Vendor Promo Plumbing (Future-Safe)

**Goal:** Support vendor-scoped discounts without enforcing redemption logic.

* [ ] **Ticket:** Accept vendor promo codes in quote request
* [ ] **Ticket:** Validate promo ownership per vendor
* [ ] **Ticket:** Apply promo to vendor group totals (or reject)
* [ ] **Ticket:** Emit vendor-level warnings for invalid promos

---

# Phase 6 — Attribution Pass-through (Cart-Level)

**Goal:** Preserve attribution context for checkout + analytics.

* [ ] **Ticket:** Accept ad_tokens in quote request
* [ ] **Ticket:** Validate token structure (signature + expiry)
* [ ] **Ticket:** Persist valid ad_tokens on CartRecord
* [ ] **Ticket:** Echo ad_tokens in CartQuote response
* [ ] **Ticket:** Ensure attribution does not affect pricing

---

# Phase 7 — API Layer (Controllers & Routes)

**Goal:** Expose cart quote via a stable, idempotent endpoint.

* [ ] **Ticket:** Wire new DTOs, service, and response into `POST /cart`
* [ ] **Ticket:** Add request validation for QuoteCartRequest
* [ ] **Ticket:** Integrate header-based idempotency middleware
* [ ] **Ticket:** Implement hard errors vs soft warnings behavior
* [ ] **Ticket:** Normalize HTTP semantics (400 vs 200-with-warnings)

---

# Phase 8 — Cart Conversion Readiness (No Checkout Execution)

**Goal:** Prepare CartRecord for checkout fan-out.

* [ ] **Ticket:** Implement cart state transition (`active → converted`)
* [ ] **Ticket:** Generate checkout_group_id on conversion
* [ ] **Ticket:** Persist checkout_group_id on CartRecord
* [ ] **Ticket:** Ensure idempotent reuse of checkout_group_id
* [ ] **Ticket:** Expose converted state via CartRecord fetch (if needed)

---

# Phase 9 — Observability, Safety & Regression

**Goal:** Make cart quote production-safe.

* [ ] **Ticket:** Add structured logging to quote service
* [ ] **Ticket:** Add metrics (latency, item count, vendor count, warnings)
* [ ] **Ticket:** Add rate limiting to cart quote endpoint
* [ ] **Ticket:** Update tests for new schema + DTOs
* [ ] **Ticket:** Add regression tests (MOQ clamp, vendor invalid, mismatch, promo invalid)
* [ ] **Ticket:** Add guard tests ensuring no inventory mutation
