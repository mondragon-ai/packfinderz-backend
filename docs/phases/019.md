# Title [PF-146]:  Migrate cart schema to authoritative quote model (CartRecord, CartItem, Vendor Groups)

## Type

Task

## Description

Update the persistence layer to align with the new **authoritative cart quote model**.
This migration replaces legacy cart fields that no longer match the quote-based flow, introduces new enums and columns required for item/vendor status and warnings, and adds support for checkout conversion via `checkout_group_id`.

`cart_records` becomes the single auditable source of truth for cart quotes, storing validated quantities, authoritative pricing, warnings, and attribution metadata. No parallel tables should be introduced beyond what is explicitly required.

All changes must be implemented in **one Goose migration**, modifying existing tables in place.

## Scope

### Included

* Create required Postgres enums for cart, item, and vendor-group status/warnings
* Modify `cart_records` table:

  * Add new fields (`checkout_group_id`, `valid_until`, `discounts_cents`, `ad_tokens`)
  * Remove deprecated fields (`session_id`, `fees`, `total_discount`, `cart_level_discount`)
  * Ensure schema matches authoritative cart quote model
* Modify `cart_items` table:

  * Add vendor grouping, authoritative pricing, constraints, status, and warnings fields
  * Remove or deprecate fields that conflict with the new model
* Create new `cart_vendor_groups` table to persist vendor-level aggregation and warnings
* Add all required indexes and unique constraints
* Ensure migration is safe for existing data (nullable additions, defaults where needed)

### Explicitly NOT Included

* Any repository, service, DTO, or API-layer changes
* Checkout execution, inventory reservation, or payment logic
* Client-side cart shape or UI concerns
* Data backfill beyond defaults/nullability required for migration safety

## Acceptance Criteria

* [ ] All required Postgres enums (`cart_status`, `cart_item_status`, `vendor_group_status`, warning enums) are created and usable
* [ ] `cart_records` schema matches the new authoritative model, with deprecated columns removed
* [ ] `cart_items` schema includes vendor grouping, pricing, constraints, status, and warnings fields
* [ ] `cart_vendor_groups` table exists with correct fields and `(cart_id, vendor_store_id)` unique constraint
* [ ] All specified indexes are present and valid
* [ ] Migration runs successfully on an existing database without data loss or runtime errors
* [ ] No parallel or duplicate cart tables are introduced

## Dependencies

* Blocked by: Final approval of authoritative cart quote schema (DTO + domain model)
* Blocks:

  * Phase 2: Domain Models & Repositories
  * Phase 3: DTOs & Mapping Helpers
  * Phase 4: Cart Quote Service

## Technical Notes

* Migration tool: **Goose**
* ORM: **GORM**
* Affected tables:

  * `cart_records`
  * `cart_items`
  * `cart_vendor_groups` (new)
* Enums must be created before columns that depend on them
* JSON fields (`warnings`, `applied_volume_discount`, `promo`) must use `jsonb`
* **ASSUMPTION:** Existing `address_t` composite type is already defined and reusable for `shipping_address`
* **ASSUMPTION:** Platform currency default is `USD` unless otherwise specified


### Target DB Schema (authoritative)

#### Postgres enums (MUST exist)

* `cart_status`: `active`, `converted`
* `cart_item_status`: `ok`, `not_available`, `invalid`
* `cart_item_warning_type`:

  * `clamped_to_moq`
  * `clamped_to_max`
  * `price_changed`
  * `not_available`
  * `vendor_invalid`
  * `vendor_mismatch`
  * `invalid_promo`
* `vendor_group_status`: `ok`, `invalid`
* `vendor_group_warning_type`:

  * `vendor_invalid`
  * `vendor_suspended`
  * `license_invalid`
  * `invalid_promo`

#### JSON shapes (stored as `jsonb`)

We’ll store warnings as JSONB arrays for flexibility and forward compatibility.

**`cart_item_warning` JSON element**

```json
{ "type": "clamped_to_moq", "message": "..." }
```

**`vendor_group_warning` JSON element**

```json
{ "type": "license_invalid", "message": "..." }
```

**`applied_volume_discount` JSON object**

```json
{ "label": "10% off 1lb+", "amount_cents": 500 }
```

**`vendor_group_promo` JSON object**

```json
{ "code": "SAVE20", "amount_cents": 2000 }
```

---

### Tables

#### `cart_records` (UPDATED)

Fields (proposed canonical persistence shape):

* `id uuid pk default gen_random_uuid()`
* `buyer_store_id uuid not null`
* `status cart_status not null default 'active'`
* `checkout_group_id uuid null`  ✅ NEW
* `shipping_address address_t null or not null` (your call; quote response requires it, but DB can keep nullable if buyer store missing address)
* `currency text not null default 'USD'` (or `'BRL'` if your platform currency is BRL—pick one)
* `valid_until timestamptz not null` ✅ NEW
* `subtotal_cents int not null default 0`
* `discounts_cents int not null default 0` ✅ NEW (replaces total_discount)
* `total_cents int not null default 0`
* `ad_tokens text[] null` ✅ NEW (pass-through)
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

**Fields to REMOVE from current model**

* `session_id` (not mentioned in new flow)
* `fees` (not in CartQuote)
* `total_discount` (replace with `discounts_cents`)
* `cart_level_discount[]` composite (replaced by vendor_groups + promo in new shape)

#### `cart_items` (UPDATED)

Fields:

* `id uuid pk default gen_random_uuid()`
* `cart_id uuid not null fk cart_records(id) on delete cascade`
* `product_id uuid not null`
* `vendor_store_id uuid not null` ✅ NEW (required for grouping without N product fetches)
* `quantity int not null`
* `moq int not null`
* `max_qty int null`
* `unit_price_cents int not null` ✅ REQUIRED
* `applied_volume_discount jsonb null` ✅ NEW
* `line_subtotal_cents int not null` ✅ REQUIRED
* `status cart_item_status not null default 'ok'` ✅ REQUIRED
* `warnings jsonb null` ✅ REQUIRED (array)
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

#### `cart_vendor_groups` (NEW TABLE — recommended)

Because vendor_groups are part of the persisted authoritative quote, don’t hide them as “computed on read” if you want auditability and clean checkout fan-out.

Fields:

* `id uuid pk default gen_random_uuid()`
* `cart_id uuid not null fk cart_records(id) on delete cascade`
* `vendor_store_id uuid not null`
* `status vendor_group_status not null default 'ok'`
* `warnings jsonb null`
* `subtotal_cents int not null default 0`
* `promo jsonb null`
* `total_cents int not null default 0`
* `created_at timestamptz not null default now()`
* `updated_at timestamptz not null default now()`

Unique constraint:

* `(cart_id, vendor_store_id)` unique

---

### Indexes (MUST)

* `cart_records(buyer_store_id, status)`
* `cart_records(checkout_group_id)` (optional but likely)
* `cart_items(cart_id)`
* `cart_items(vendor_store_id)`
* `cart_items(product_id)`
* `cart_vendor_groups(cart_id)`
* `cart_vendor_groups(vendor_store_id)`
* `cart_vendor_groups(cart_id, vendor_store_id)` unique


## Out of Scope

* Writing or updating GORM models
* Writing conversion/backfill scripts beyond schema defaults
* Any logic related to cart quoting, validation, promos, attribution, or checkout
Here’s the rearranged plan with your requested consolidation, plus the **exact target DB/GORM shapes + Postgres enums/types** so Goose knows what to change. I’m staying strictly within this thread’s scope.

---

#  Title [PF-147]:  Update and add GORM models to match authoritative cart quote schema

## Type

Task

## Description

Update existing GORM models and introduce new models to reflect the authoritative cart quote schema introduced in Phase 1 (see the GOose migration `pkg/migrate/migrations/20260306000000_cart_modifications.sql`).
Models must align **exactly** with the new database structure created by the Goose migration, including enums, JSON fields, and relationships.

This ensures the ORM layer accurately represents persisted cart records, cart items, and vendor group aggregates used for quoting and later checkout conversion.

## Scope

### Included

* Update `CartRecord` GORM model to reflect new schema:

  * Add `checkout_group_id`, `valid_until`, `discounts_cents`, `currency`, `ad_tokens`
  * Remove deprecated fields (`session_id`, `fees`, `total_discount`, `cart_level_discount`)
  * Add `vendor_groups` referncing the new table (see the GOose migration `pkg/migrate/migrations/20260306000000_cart_modifications.sql`).
* Update `CartItem` GORM model:

  * Add `vendor_store_id`, `applied_volume_discount`, pricing fields, constraints, status enum, warnings JSON {
      type:
        | "clamped_to_moq"
        | "clamped_to_max"
        | "price_changed"
        | "not_available"
        | "vendor_invalid"
        | "vendor_mismatch"
        | "invalid_promo"
      message: string
    }
  * Align field names (`quantity`, `line_subtotal_cents`) with DB schema

* Create new `CartVendorGroup` GORM model mapped to `cart_vendor_groups` 
* Map Postgres enums (`cart_item_status`, `vendor_group_status`) to Go enums
* Ensure JSONB fields are correctly typed (`json.RawMessage` or typed structs)

### Explicitly NOT Included

* Repository logic or persistence behavior
* DTOs or API contracts
* Business logic, validation, or pricing rules
* Database migrations (already completed in Phase 1)

## Acceptance Criteria

* [ ] `CartRecord` GORM model fields exactly match `cart_records` table schema
* [ ] `CartItem` GORM model fields exactly match `cart_items` table schema
* [ ] New `CartVendorGroup` GORM model exists and maps to `cart_vendor_groups`
* [ ] Enum fields use strongly typed Go enums corresponding to Postgres enums
* [ ] JSONB fields are correctly marshaled/unmarshaled without runtime errors

## Dependencies

* Blocked by:

  * PF-101: Cart schema Goose migration
* Blocks:

  * Cart repositories
  * Cart quote service

## Technical Notes

* Location: `pkg/db/models/*`
* ORM: **GORM**
* Enum definitions should live alongside existing enum patterns
* JSON fields (`warnings`, `promo`, `applied_volume_discount`) must not assume schema rigidity
* **ASSUMPTION:** Existing enum handling patterns are already established in `pkg/enums`

## Out of Scope

* Writing or updating repository logic
* Any cart quote computation or validation logic
* API exposure or DTO mapping

---

# Title [PF-148]:  Update CartRecord repository for authoritative quote upsert semantics

## Type

Task

## Description

Update the CartRecord repository layer to support creating and updating authoritative cart quote records based on the new schema.
The repository must support deterministic upsert behavior for active carts scoped by buyer store, without introducing checkout or inventory concerns.

## Scope

### Included

* Update CartRecord repository methods to:

  * Create a new active cart record when none exists
  * Update existing active cart records with new quote snapshots
* Persist authoritative fields:

  * Totals, discounts, currency, valid_until
  * `checkout_group_id` (nullable)
  * `ad_tokens`
* Ensure status remains `active` during quote lifecycle

### Explicitly NOT Included

* CartItem or vendor group persistence
* Quote validation or pricing logic
* Cart conversion or checkout behavior

## Acceptance Criteria

* [ ] Repository can create a new `cart_records` row for a buyer store
* [ ] Repository can update an existing active cart record deterministically
* [ ] Deprecated fields are no longer read or written
* [ ] Repository operations are safe to call repeatedly with the same inputs

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * API layer

## Technical Notes

* Location: `pkg/db/repositories/cart_record_repo.go` (or equivalent)
* Must not assume cart uniqueness beyond `(buyer_store_id, status='active')`
* **ASSUMPTION:** Only one active cart per buyer store is enforced at service level

## Out of Scope

* Transaction coordination with cart items or vendor groups
* Idempotency handling (middleware concern)
* Checkout group assignment

---

#  Title [PF-149]:  Update CartItem repository to support replace-on-quote persistence

## Type

Task

## Description

Update the CartItem repository to support **replace-on-quote** semantics, where all cart items for a cart are replaced atomically based on the latest authoritative quote.

This ensures cart items always reflect server-validated quantities, dicsounts, pricing, statuses, and warnings.

## Scope

### Included

* Implement repository method to:

  * Delete existing cart items for a cart
  * Insert new cart items from the quote snapshot
* Persist all authoritative fields:

  * Quantity, MOQ, max_qty
  * Unit price, line subtotal
  * Status and warnings JSON
  * Vendor store linkage
* Support execution within an existing transaction

### Explicitly NOT Included

* CartRecord updates
* Vendor group persistence
* Quote computation logic

## Acceptance Criteria

* [ ] Existing cart items are fully replaced on each quote write
* [ ] All authoritative pricing and status fields are persisted correctly
* [ ] Repository functions correctly when executed inside a transaction
* [ ] No orphaned cart item rows remain after replacement

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * Vendor group persistence

## Technical Notes

* Location: `pkg/db/repositories/cart_item_repo.go` (or equivalant)
* Must accept `*gorm.DB` transaction handle
* **ASSUMPTION:** Cart items are not incrementally updated; always replaced wholesale

## Out of Scope

* Item-level validation or warning generation
* Vendor grouping logic
* API or DTO concerns

---

# Title [PF-150]:  Add CartVendorGroup repository with replace-on-quote behavior

## Type

Task

## Description

Introduce a repository for persisting vendor-level cart group aggregates (`cart_vendor_groups`).
These records store authoritative per-vendor totals, statuses, warnings, and applied promos as part of the cart quote snapshot.

## Scope

### Included

* Create repository for `cart_vendor_groups`
* Implement replace-on-quote behavior:

  * Delete existing vendor groups for cart
  * Insert new vendor groups from quote snapshot
* Persist:

  * Vendor status and warnings
  * Subtotals, promos, totals
* Support execution inside an existing transaction

### Explicitly NOT Included

* Promo validation logic
* Checkout order creation
* CartRecord or CartItem persistence

## Acceptance Criteria

* [ ] Vendor group rows are fully replaced per quote
* [ ] `(cart_id, vendor_store_id)` uniqueness is respected
* [ ] JSONB fields persist without schema assumptions
* [ ] Repository supports transactional execution

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
* Blocks:

  * Cart quote service
  * Cart conversion logic

## Technical Notes

* Location: `pkg/db/repositories/cart_vendor_group_repo.go`
* Must not assume vendor validity; status is authoritative input
* **ASSUMPTION:** Vendor group totals are computed upstream in service layer

## Out of Scope

* Vendor validation
* Promo code evaluation
* API exposure

---

# Title [PF-151]:  Ensure atomic persistence of cart records, items, and vendor groups

## Type

Task

## Description
Existing functions etc may exist. so modify existing ones by extending ro creating new ones for this ticket. 
Ensure cart persistence is performed atomically by coordinating CartRecord, CartItem, and CartVendorGroup repositories within a single database transaction.

This guarantees that each cart quote snapshot is either fully written or not written at all.

## Scope

### Included

* Implement transactional wrapper coordinating:

  * CartRecord upsert
  * CartItem replace
  * CartVendorGroup replace
* Ensure transaction rollback on any failure
* Provide reusable helper or service-level transaction pattern

### Explicitly NOT Included

* Quote calculation or validation
* Checkout conversion
* API request handling

## Acceptance Criteria

* [ ] All cart-related writes occur within a single DB transaction
* [ ] Partial writes do not persist on failure
* [ ] Transaction boundaries are explicit and testable
* [ ] Repositories accept transaction handles consistently

## Dependencies

* Blocked by:

  * PF-202, PF-203, PF-204
* Blocks:

  * Cart quote service
  * API layer

## Technical Notes

* ORM: **GORM**
* Use `db.Transaction(func(tx *gorm.DB) error { ... })`
* **ASSUMPTION:** Service layer orchestrates transactional boundaries

## Out of Scope

* Retry or idempotency logic
* Performance optimization
* Metrics or logging instrumentation

---

#  Title [PF-152]:  Implement cart quote API DTOs (QuoteCartRequest and CartQuote)

## Type

Task

## Description

Define and implement the API-layer Data Transfer Objects (DTOs) for the cart quote flow, cleanly separating external API contracts from persistence and domain models.

This includes:

* The **minimal intent request DTO** used for cart creation/upsert
* The **authoritative cart quote response DTO** used when creating, updating, or fetching a cart

These DTOs act as the stable contract between clients and the backend and must reflect the authoritative quote model agreed in the master document.

## Scope

### Included

* Implement `QuoteCartRequest` DTO:

  * Minimal intent payload (buyer_store_id, items, vendor promos, ad tokens)
  * Explicitly excludes pricing, validation, or UI-derived fields
* Implement `CartQuote` response DTO:

  * Authoritative cart snapshot (items, vendor groups, totals)
  * Includes item-level status, warnings, discounts
  * Includes cart-level metadata (currency, valid_until, checkout_group_id, ad_tokens)
* Place DTOs in appropriate API/transport layer package
* Ensure DTO field names, types, and optionality match the agreed contract exactly

### Explicitly NOT Included

* Mapping logic to or from database/domain models
* Validation, pricing, or business logic
* Controller or route wiring
* Client-side DTOs or UI models

## Acceptance Criteria

* [ ] `QuoteCartRequest` DTO matches the agreed minimal intent shape exactly
* [ ] `CartQuote` DTO matches the authoritative quote response shape exactly
* [ ] DTOs compile cleanly and can be serialized/deserialized without runtime errors
* [ ] No persistence-layer or GORM models are referenced directly in DTO definitions

## Dependencies

* Blocked by:

  * Phase 1: Cart schema migration (PF-101)
* Blocks:

  * Phase 4: Cart Quote Service
  * Phase 7: API Layer (Controllers & Routes)

## Technical Notes

* DTOs should live in the API/transport layer (e.g. `api/controller/cart/dto` or equivalent)
* JSON field naming must be stable and explicit
* Optional fields should be pointer-based where needed
* **ASSUMPTION:** Existing project conventions for DTO placement and JSON tags apply
* currently controller DTOs live inside `api/controllers/cart.go` lets move that and its test into a sub folder and seperate helpers, dtos, etc in their seperate files in the sub folder.

## Out of Scope

* Mapping helpers
* Domain or persistence model changes
* Request validation logic

---


# Title [PF-153]:  Implement cart quote mapping helpers (DB ↔ domain ↔ DTO)

## Type

Task

## Description

Implement mapping helpers to translate between persistence models, domain quote representations, and API DTOs for the cart quote flow.

These helpers ensure a clean separation of concerns and guarantee that **authoritative cart data** (including item status, warnings, and discounts) is preserved end-to-end without leaking database models into the API layer.

## Scope

### Included

* Implement mapping from database models → `CartQuote` DTO:

  * `CartRecord` → cart-level fields
  * `CartItem` → item-level fields (status, warnings, discounts)
  * `CartVendorGroup` → vendor group fields
* Implement mapping from `QuoteCartRequest` DTO → internal domain quote intent model
* Ensure item-level warnings, status, and discount fields are preserved without loss
* Keep mapping logic deterministic and side-effect free

### Explicitly NOT Included

* Quote calculation or validation logic
* Repository or transaction logic
* API controllers or handlers
* Checkout or order conversion logic

## Acceptance Criteria

* [ ] Mapping helpers correctly transform DB models into a valid `CartQuote` DTO
* [ ] Mapping helpers correctly transform `QuoteCartRequest` into an internal domain intent structure
* [ ] Item-level `status`, `warnings`, and `applied_volume_discount` are preserved end-to-end
* [ ] No GORM models are exposed directly to API layers
* [ ] Mapping helpers are unit-testable in isolation

## Dependencies

* Blocked by:

  * PF-201: GORM model updates
  * PF-301: Cart quote DTOs
* Blocks:

  * Cart Quote Service
  *  API Layer (Controllers & Routes)

## Technical Notes

* Likely locations:

  * `internal/cart/mappers`
  * `internal/cart/helpers`
* Prefer explicit mapping over reflection or auto-mapping
* JSONB fields should be unmarshaled into typed structs or pass-through maps as appropriate
* **ASSUMPTION:** Domain quote intent model exists or will be introduced in Phase 4

## Out of Scope

* Business rules or validation
* Persistence or transaction handling
* Logging, metrics, or observability

---

# Title [PF-154]: Refactor cart service/controller to quote-based contract (replace UpsertCart entrypoint)

## Type

Task

## Description

Replace the current cart “upsert snapshot” contract (which trusts client-supplied totals/pricing fields) with a **server-authoritative quote contract**.

This ticket establishes the new boundary:

* Controller accepts `cartdto.QuoteCartRequest` (minimal intent payload).
* Cart service exposes a quote-oriented method and returns `cartdto.CartQuote` via `newCartQuote(record *models.CartRecord)`.

This is the first refactor step that allows subsequent tickets to change validation, pricing, warnings, vendor groups, and totals while keeping the API contract stable.

## Scope

* **Included**

  * Add/introduce a quote-oriented cart service method that accepts `cartdto.QuoteCartRequest` (or an internal input derived from it).
  * Update the cart controller(s) to use `QuoteCartRequest` instead of the legacy `upsertCartRequest`.
  * Ensure response uses `cartdto.CartQuote` generated by `newCartQuote(record)`.
  * Maintain DB writes using existing repository transaction pattern (no logic changes yet; this ticket is contract/wiring focused).
  * Ensure `buyer_store_id` is sourced from request DTO (and/or existing auth middleware if already used) consistently.

* **Explicitly NOT Included**

  * Business logic changes for server-authoritative pricing/totals (handled in later tickets).
  * Warning/status generation logic changes (handled in later tickets).
  * Vendor group persistence logic changes (handled in later tickets).
  * Inventory reservation/mutation changes (handled in later tickets).
  * Schema/migration work (Phase 1/2).

## Acceptance Criteria

* [ ] Cart controller accepts `cartdto.QuoteCartRequest` payload and no longer depends on `upsertCartRequest` / `UpsertCartInput` shape from the client-supplied totals flow.
* [ ] Controller returns `cartdto.CartQuote` using `newCartQuote(record)` where `record` is loaded/persisted via the repo layer.

## Dependencies

* Blocked by:

  * Phase 1 migration applied (updated `cart_records`, `cart_items`, and `cart_vendor_groups` columns/tables exist).
  * Phase 2 GORM models + repo updates available for `models.CartRecord`, `models.CartItem`, and `models.CartVendorGroup` (or equivalent).
* Blocks:

  * PF-XXX: Refactor quote validation to be server-authoritative
  * PF-XXX: Implement vendor pre-loading + product fetch pipeline optimized for grouping
  * PF-XXX: Implement authoritative pricing/discounts/totals and persistence

## Technical Notes

* Relevant packages / files (current examples from thread):

  * Controller DTOs:

    * `api/controllers/cart/dto/QuoteCartRequest` (incoming)
    * `api/controllers/cart/dto/CartQuote` (outgoing)
  * Controller mapping:

    * `api/controllers/cart/newCartQuote(record *models.CartRecord) cartdto.CartQuote`
  * Existing service needing refactor:

    * `internal/cart/service.go` (contains `UpsertCart`, `GetActiveCart`)
  * Existing controller DTO to stop using:

    * `upsertCartRequest` + `toInput()` mapping into `cartsvc.UpsertCartInput`
* Recommended contract change (example):

  * Add `QuoteCart(ctx context.Context, req cartdto.QuoteCartRequest) (*models.CartRecord, error)` on `internal/cart.Service`
  * Keep `GetActiveCart` as-is for now, but ensure it returns `models.CartRecord` compatible with `newCartQuote`
* **ASSUMPTION:** The controller already has a stable route (e.g. `POST /cart`) that can be repointed to quote semantics without changing the path in this ticket.
* **ASSUMPTION:** Buyer store identity remains validated server-side via `validateBuyerStore()` (or equivalent) after wiring changes.

## Out of Scope

* Any change to quote computation rules (MOQ clamp, tier selection, warnings, totals).
* Any implementation of vendor promo redemption logic.
* Any inventory reservation or checkout conversion logic.

---

# Title [PF-155]: Remove client-supplied totals/pricing assertions and make quote validation server-authoritative

## Type

Task

## Description

Refactor the cart quote flow to be **server-authoritative** by removing any validation that assumes the client calculated totals, line subtotals, or pricing correctly.

Instead, the server will:

* Treat the request as **intent** only (`buyer_store_id` + items with quantity/vendor/product).
* Compute authoritative pricing/totals later in the flow.
* Convert “inventory insufficient / not active” conditions into **soft quote results** (status/warnings) instead of hard errors, where appropriate for quoting.

This ticket specifically removes legacy checks that block quoting when client-supplied monetary fields don’t match server calculations.

## Scope

* **Included**

  * Remove/disable client assertion checks in the quote flow:

    * `verifyTotals(...)`
    * comparisons of payload `unit_price_cents` vs product price (if present in any remaining request path)
    * comparisons of payload line subtotal vs computed value
  * Update validation to only enforce structural/semantic constraints:

    * buyer_store_id required and valid buyer store
    * at least one item present
    * quantities must be positive integers
    * product/vendor ids required per item
  * Change inventory shortage handling from hard failure to soft quote result:

    * Do not return 409 for insufficient inventory during quote.
    * Mark item as `not_available` and attach warning type `not_available` (exact warning emission implemented in later ticket, but this ticket ensures no hard error path remains for quote).
  * Ensure errors are reserved for:

    * malformed request
    * missing buyer store (kyc/active subscription/state/type) / invalid buyer store (kyc/state/type)
    * dependency failures (DB down, product loader failure not-notfound, etc.)

* **Explicitly NOT Included**

  * Implementation of pricing calculations, tiers, and totals persistence (later tickets).
  * Full warning/status mapping logic (later tickets).
  * Vendor group aggregation (later tickets).
  * Any API contract changes beyond removing required monetary fields from request semantics.

## Acceptance Criteria

* [ ] Quote flow no longer calls `verifyTotals(...)` and no longer requires client-calculated totals/line-subtotals/pricing fields to be present or correct.
* [ ] When product inventory is insufficient for requested quantity, the quote flow does **not** return HTTP 409 / `pkgerrors.CodeConflict`; it proceeds and allows the item to be represented as non-purchasable in the quote (soft handling).

## Dependencies

* Blocked by:

  * PF-XXX: Refactor cart service/controller to quote-based contract (replace UpsertCart entrypoint)
* Blocks:

  * PF-XXX: Implement authoritative quantity normalization + item warnings/status assignment
  * PF-XXX: Implement authoritative pricing + volume discount resolution

## Technical Notes

* Existing code paths to remove/modify (from provided `UpsertCart` service):

  * `verifyTotals(input, subtotalSum)`
  * Unit price validation and subtotal mismatch validation:

    * `if payload.SubTotalPrice == nil { ... }`
    * `if *payload.SubTotalPrice != lineTotal { ... }`
    * commented out SKU/price assertions may be deleted or remain irrelevant
  * Inventory shortage currently triggers:

    * `pkgerrors.New(pkgerrors.CodeConflict, "insufficient inventory for product")`
    * Replace with soft-path (no error return) for quote
* **ASSUMPTION:** Product “not found” remains a hard error (404) for quote, as the item cannot be represented without a product record.
* **ASSUMPTION:** “product inactive” is treated as soft `not_available` rather than a hard validation error (consistent with quote UX described in thread).

## Out of Scope

* Producing the actual warnings JSON payloads (types/messages) and persisting them.
* Any changes to DB schemas or repo transactional behavior.

---

# Title [PF-156]: Implement vendor pre-loading and product fetch pipeline optimized for vendor_store_id grouping

## Type

Task

## Description

Implement an efficient quote input processing pipeline that leverages `vendor_store_id` provided per item to minimize store calls and correctly group items by vendor.

The server should:

* Pre-load vendor stores once per unique `vendor_store_id` (N vendors).
* Fetch products per item (M products), but avoid redundant vendor validation calls.
* Verify product/vendor association (product.StoreID matches the item’s vendor_store_id) as part of the pipeline.

This ticket focuses on reducing dependency calls and preparing grouped data structures used by subsequent normalization/pricing/group aggregation tickets.

## Scope

* **Included**

  * 1. Maintain existing buyer store validation (`validateBuyerStore`) to obtain buyer state and eligibility.
  * 2. Build a preprocessing step in the quote flow:

    * Extract unique vendor IDs from request items.
    * Fetch/validate vendors via `storeLoader.GetByID` once per vendor and cache results.
  * 3. For each item:

    * Fetch product via `productLoader.GetProductDetail(ctx, productID)`.
    * Verify vendor ownership:

      * If `product.StoreID != vendor_store_id`, mark for invalid handling (actual warnings/status persistence may be in later ticket, but mismatch must be detected here).
    * Verify product availability flag (`IsActive`) for downstream status assignment.
  * Ensure the data structures produced support:

    * grouping items by vendor_store_id
    * per-item product metadata needed for pricing/tier selection later

* **Explicitly NOT Included**

  * MOQ/max clamping logic and warnings emission (later ticket).
  * Volume discount resolution and pricing calculations (later ticket).
  * Vendor group persistence (later ticket).
  * Totals computation (later ticket).

## Acceptance Criteria

* [ ] For a quote request with multiple items across the same vendor, vendor store validation is performed once per vendor (cache hit behavior verified via unit test or measurable call count in mocks).
* [ ] The quote flow detects product/vendor mismatches (product.StoreID != request vendor_store_id) and does not require additional vendor fetches per item.

## Dependencies

* Blocked by:

  * PF-XXX: Refactor cart service/controller to quote-based contract (replace UpsertCart entrypoint)
  * PF-XXX: Remove client-supplied totals/pricing assertions and make quote validation server-authoritative
* Blocks:

  * PF-XXX: Implement authoritative quantity normalization + item warnings/status assignment
  * PF-XXX: Implement authoritative pricing + volume discount resolution
  * PF-XXX: Build vendor-group aggregation

## Technical Notes

* Reuse existing helpers where applicable:

  * `ensureVendor(ctx, vendorID, buyerState, cache)` already implements caching + `checkouthelpers.ValidateVendorStore`
  * Current product fetch:

    * `productRepo.GetProductDetail(ctx, payload.ProductID)`
* Replace request item type usage:

  * Use `cartdto.QuoteCartItem` fields: `product_id`, `vendor_store_id`, `quantity`
* **ASSUMPTION:** `checkouthelpers.ValidateVendorStore` remains the canonical vendor eligibility validator for buyerState (state restrictions / licensing / subscription / etc.).
* **ASSUMPTION:** `productRepo.GetProductDetail` continues returning `*models.Product` with `StoreID`, `IsActive`, `Inventory`, `MOQ`, and `VolumeDiscounts`.

## Out of Scope

* Persisting warnings/status into DB.
* Persisting vendor groups and totals.
* Changing store/product dependency interfaces beyond needed parameter shape updates.

---

# Title [PF-157]: Implement authoritative quantity normalization and item warnings/status (MOQ/max/vendor/product availability)

## Type

Task

## Description

Implement authoritative normalization of requested quantities and determination of item status/warnings based on server truth.

The quote flow must:

* Enforce MOQ and max quantity rules using server-side product data.
* Clamp quantities when allowed and emit warnings.
* Mark items as `ok`, `not_available`, or `invalid` based on vendor/product conditions.
* Persist the resulting authoritative fields into `cart_items` (moq, max_qty, quantity, status, warnings).

## Scope

* **Included**

  * For each quote item:

    * Determine authoritative MOQ (`product.MOQ`) and max_qty (if product has it; **ASSUMPTION** below).
    * Normalize requested quantity:

      * If qty < MOQ: clamp up to MOQ and add warning `clamped_to_moq`
      * If max_qty exists and qty > max_qty: clamp down to max_qty and add warning `clamped_to_max`
  * Determine item status:

    * `not_available` when product is inactive or inventory is insufficient for normalized qty
    * `invalid` when vendor mismatch or vendor invalid (as detected in pipeline)
    * `ok` otherwise
  * Populate and persist `cart_items.warnings` as JSONB array elements shaped:

    * `{ "type": "<warning_type>", "message": "..." }`
  * Ensure persistence uses updated columns (Phase 1 migration):

    * `quantity`, `moq`, `max_qty`, `status`, `warnings`

* **Explicitly NOT Included**

  * Pricing and discount computations (later ticket).
  * Vendor group creation/aggregation (later ticket).
  * Cart totals computation (later ticket).
  * Promo code application (Phase 5).

## Acceptance Criteria

* [ ] Given a request quantity below MOQ, the persisted cart item has `quantity == moq`, includes a `clamped_to_moq` warning, and does not hard-fail the quote.
* [ ] Given insufficient inventory, the quote does not return a conflict error; the item is persisted/returned with `status=not_available` and includes a `not_available` warning.

## Dependencies

* Blocked by:

  * PF-XXX: Implement vendor pre-loading and product fetch pipeline optimized for vendor_store_id grouping
* Blocks:

  * PF-XXX: Implement authoritative pricing + volume discount resolution and persist results
  * PF-XXX: Compute cart totals from authoritative items/groups

## Technical Notes

* DB enums involved (must already exist from Phase 1):

  * `cart_item_status` = `ok | not_available | invalid`
  * `cart_item_warning_type` includes clamp + availability + vendor mismatch types
* JSON shape stored in `cart_items.warnings` (`jsonb`):

  * array of `{type, message}`
* **ASSUMPTION:** Product max quantity is available from product detail (e.g., `product.Inventory.MaxQty` or similar). If not available, treat `max_qty` as null and skip max clamping.
* **ASSUMPTION:** Inventory check during quote uses available quantity without reserving it; exact check can remain `product.Inventory.AvailableQty < qty` as soft `not_available`.

## Out of Scope

* Tier selection and applied volume discount fields.
* Vendor group invalidation persistence.
* Any checkout reservation behavior.

---

# Title [PF-158]: Compute authoritative pricing and volume discount resolution and persist quote fields on cart_items

## Type

Task

## Description

Compute authoritative per-item pricing on the server using product price data and volume discount tiers, and persist the results in `cart_items`.

This replaces any notion of trusting client-supplied pricing, and ensures the quote record is auditable and convertible to checkout later.

## Scope

* **Included**

  * For each normalized cart item:

    * Resolve the applicable volume discount tier based on authoritative quantity and `product.VolumeDiscounts` (use the “highest MinQty <= qty” rule).
    * Determine authoritative `unit_price_cents`:

      * default to product base price
      * override with tier unit price if a tier applies
    * Compute `line_subtotal_cents = unit_price_cents * quantity`
    * Populate `applied_volume_discount` JSONB when a tier applies:

      * `{ "label": "<tier label>", "amount_cents": <discount_amount> }`
      * (label/amount derivation must be deterministic and consistent)
  * Persist into `cart_items` columns:

    * `unit_price_cents`
    * `applied_volume_discount`
    * `line_subtotal_cents`
  * If server price differs from any previously stored price for the same cart item, add `price_changed` warning (if applicable in your replace semantics).

* **Explicitly NOT Included**

  * Vendor group aggregation/totals (later ticket).
  * Cart totals persistence (later ticket).
  * Promo redemption rules (Phase 5).
  * Any inventory mutation/reservation.

## Acceptance Criteria

* [ ] For an item with no applicable tier, `unit_price_cents` equals the product base price and `applied_volume_discount` is null; `line_subtotal_cents` equals `unit_price_cents * quantity`.
* [ ] For an item where a tier applies, `unit_price_cents` equals the tier price and `applied_volume_discount` is non-null and persisted as JSONB.

## Dependencies

* Blocked by:

  * PF-XXX: Implement authoritative quantity normalization and item warnings/status (MOQ/max/vendor/product availability)
* Blocks:

  * PF-XXX: Build vendor-group aggregation + persist cart_vendor_groups
  * PF-XXX: Compute cart totals (subtotal/discounts/total) and persist to cart_records

## Technical Notes

* Existing helper that resolves tiers can be adapted:

  * `selectVolumeDiscount(qty, product.VolumeDiscounts)`
* Applied discount structure:

  * DB column: `cart_items.applied_volume_discount jsonb`
  * DTO field: `*types.AppliedVolumeDiscount`
* **ASSUMPTION:** `types.AppliedVolumeDiscount` can represent label + amount cents (or can be adjusted already in Phase 2).
* Warning addition:

  * `price_changed` warning type exists in enum; message should be human-readable and stable.

## Out of Scope

* Any vendor promo code handling.
* Any grouping/persistence into `cart_vendor_groups`.

---

# Title [PF-159]: Aggregate vendor groups and persist cart_vendor_groups (status/warnings/subtotal/promo/total)

## Type

Task

## Description

Persist vendor-level aggregation as part of the authoritative cart quote by creating/updating `cart_vendor_groups` (conocal DB model `CartVendorGroup`) for each vendor in the cart.

Each vendor group represents the per-vendor “card” concept used by the client and is required for clean checkout fan-out later.

## Scope

* **Included**

  * For each vendor_store_id in the quote:

    * Aggregate vendor group subtotal from that vendor’s valid/ok items (define rule explicitly).
    * Determine vendor group status:

      * `ok` if vendor is valid and has at least one ok item
      * `invalid` if vendor invalid/suspended/license/inactive subscription invalid (based on store validation) or all items invalid
    * Populate vendor group warnings JSONB array when invalid:

      * `{ "type": "<vendor_group_warning_type>", "message": "..." }`
    * Persist to `cart_vendor_groups`:

      * `status`, `warnings`, `subtotal_cents` (line items total), `promo` (nullable), `total_cents` (`vendor_group_subtotal_cents` - promo discounts)
  * Ensure `(cart_id, vendor_store_id)` unique constraint is respected:

    * use replace/update semantics for groups when re-quoting.

* **Explicitly NOT Included**

  * Promo redemption enforcement beyond attaching placeholder promo objects if present (Phase 5 owns this).
  * Cart-level totals computation (next ticket).
  * Checkout conversion.

## Acceptance Criteria

* [ ] For a cart containing items from multiple vendors, the persisted quote includes one `cart_vendor_groups` row per vendor_store_id with correct subtotal/total fields and status.
* [ ] Re-quoting the same cart replaces/updates vendor group rows without violating the `(cart_id, vendor_store_id)` unique constraint.

## Dependencies

* Blocked by:

  * PF-XXX: Compute authoritative pricing and volume discount resolution and persist quote fields on cart_items
* Blocks:

  * PF-XXX: Compute cart totals (subtotal/discounts/total) from authoritative items/groups and persist to cart_records

## Technical Notes

* DB table: `cart_vendor_groups`

  * columns include: `status vendor_group_status`, `warnings jsonb`, `subtotal_cents`, `promo jsonb`, `total_cents`
* Status enums:

  * `vendor_group_status`: `ok | invalid`
  * warning types: `vendor_invalid | vendor_suspended | license_invalid | invalid_promo`
* Aggregation rules should be deterministic:

  * Suggested: subtotal is sum of `line_subtotal_cents` for items with `status=ok`.
  * If all items are invalid/not_available, group can still exist with `status=invalid` and warnings explaining why.
* **ASSUMPTION:** Vendor eligibility validation already surfaces enough reason to classify `vendor_invalid` vs `license_invalid` vs `vendor_suspended` via `checkouthelpers.ValidateVendorStore` (or extended error typing).

## Out of Scope

* Promo code math and final discount application logic.
* Any analytics/outbox emission.

---

## Jira Ticket Template

## Title [PF-160]: Compute and persist cart_records totals and validity window from authoritative items/vendor groups

## Type

Task

## Description

Compute and persist cart-level totals on `cart_records` based on authoritative item and vendor-group data.

The server must derive:

* `subtotal_cents`
* `discounts_cents` (initially 0 unless vendor promo plumbing already applies)
* `total_cents`
* `valid_until`
* `currency`
* `shipping_address` derived from buyer store

This ensures the cart quote record is fully auditable and self-contained for later checkout conversion.

## Scope

* **Included**

  * Compute cart totals using authoritative persisted quote entities:

    * subtotal from sum of vendor group subtotals (or sum of ok items; pick one and document)
    * discounts from applied vendor promos (if already present) otherwise 0
    * total = subtotal - discounts (non-negative)
  * Persist to `cart_records` fields:

    * `subtotal_cents`, `discounts_cents`, `total_cents`
    * `valid_until` (server-defined window; e.g. now + 15m)
    * `currency` (default USD if empty)
    * `shipping_address` from buyer store record
    * `ad_tokens` pass-through stored if provided/validated elsewhere
  * Ensure updates happen in the same transaction as item/group persistence (transaction boundary may already exist; enforce usage).

* **Explicitly NOT Included**

  * Checkout conversion and assigning checkout_group_id (Phase 8).
  * Inventory reservation.
  * Full promo enforcement (Phase 5).

## Acceptance Criteria

* [ ] After quoting, `cart_records.subtotal_cents`, `discounts_cents`, and `total_cents` match the server-computed values derived from authoritative quote data (items/groups).
* [ ] `valid_until` is always set by the server and is later than `created_at` (e.g., now + configured duration), and the quote response returns the same persisted `valid_until`.

## Dependencies

* Blocked by:

  * PF-XXX: Aggregate vendor groups and persist cart_vendor_groups (status/warnings/subtotal/promo/total)
* Blocks:

  * PF-XXX: Enforce quote-only invariant (no inventory mutation/reservation and no conflict errors)

## Technical Notes

* Existing code sets:

  * `validUntil := time.Now().Add(15 * time.Minute)` (keep, but ensure it’s authoritative and persisted)
  * currency default “USD” (keep)
* Buyer shipping address derivation:

  * Current flow allows payload shipping address; new quote flow should pull from buyer store record.
* **ASSUMPTION:** Buyer store address is represented by `types.Address` and can be stored in `cart_records.shipping_address` using existing `address_t` type.

## Out of Scope

* Any changes to request/response DTO definitions beyond what’s required to persist these fields.
* Any metrics/logging tasks (Phase 9).

---

## Jira Ticket Template

## Title [PF-XXX]: Enforce quote-only invariant: no inventory mutation/reservation and no 409 conflicts on shortage (soft quote warnings)

## Type

Task

## Description

Ensure the cart quote flow is strictly **non-mutating** with respect to inventory and checkout state.

Quoting must never:

* reserve inventory
* decrement inventory
* create orders
* return conflict errors for shortages

Instead, shortages and availability problems must be represented as **soft quote results** via item/vendor statuses and warnings, allowing the client to display issues per line item/vendor card.

## Scope

* **Included**

  * Audit and remove any inventory mutation paths reachable from quote flow.
  * Replace any remaining “hard conflict” behavior for quote-time availability checks with soft results:

    * no `pkgerrors.CodeConflict` for inventory shortage
  * Ensure quote flow only reads from:

    * stores
    * products
    * cart tables
  * Ensure returned/persisted quote includes the item/vendor statuses required to express non-purchasable items.

* **Explicitly NOT Included**

  * Checkout reservation logic (later phase).
  * Payment intents / gateway behavior.
  * Event emission/analytics.

## Acceptance Criteria

* [ ] The quote endpoint/service has no code path that writes to inventory tables/fields or creates checkout/order records.
* [ ] When inventory is insufficient, quote returns successfully and represents the issue via item status/warnings (no conflict HTTP status/code).

## Dependencies

* Blocked by:

  * PF-XXX: Compute and persist cart_records totals and validity window from authoritative items/vendor groups
* Blocks:

  * Phase 7/8 work that assumes quote is safe and non-mutating
  * Future checkout conversion implementation (depends on quote not reserving)

## Technical Notes

* Existing behavior to remove:

  * `if payload.Qty > 0 && product.Inventory.AvailableQty < payload.Qty { return conflict }`
  * convert into “soft not_available” status + warning
* **ASSUMPTION:** Inventory reservation is implemented elsewhere (checkout flow), not required for quote.

## Out of Scope

* Implementing reservation, lock tables, or checkout transactions.
* Adding new warning types beyond those already enumerated in Phase 1.

---

# Phase 5 — Vendor Promo Plumbing (Future-Safe)

**Goal:** Support vendor-scoped discounts without enforcing redemption logic.

* [ ] **Ticket:** Accept vendor promo codes in quote request
* [ ] **Ticket:** Validate promo ownership per vendor
* [ ] **Ticket:** Apply promo to vendor group totals (or reject)
* [ ] **Ticket:** Emit vendor-level warnings for invalid promos

---

# Phase 6 — Attribution Pass-through (Cart-Level)

**Goal:** Preserve attribution context for checkout + analytics.

* [ ] **Ticket:** Accept ad_tokens in quote request
* [ ] **Ticket:** Validate token structure (signature + expiry)
* [ ] **Ticket:** Persist valid ad_tokens on CartRecord
* [ ] **Ticket:** Echo ad_tokens in CartQuote response
* [ ] **Ticket:** Ensure attribution does not affect pricing

---

# Phase 7 — API Layer (Controllers & Routes)

**Goal:** Expose cart quote via a stable, idempotent endpoint.

* [ ] **Ticket:** Wire new DTOs, service, and response into `POST /cart`
* [ ] **Ticket:** Add request validation for QuoteCartRequest
* [ ] **Ticket:** Integrate header-based idempotency middleware
* [ ] **Ticket:** Implement hard errors vs soft warnings behavior
* [ ] **Ticket:** Normalize HTTP semantics (400 vs 200-with-warnings)

---

# Phase 8 — Cart Conversion Readiness (No Checkout Execution)

**Goal:** Prepare CartRecord for checkout fan-out.

* [ ] **Ticket:** Implement cart state transition (`active → converted`)
* [ ] **Ticket:** Generate checkout_group_id on conversion
* [ ] **Ticket:** Persist checkout_group_id on CartRecord
* [ ] **Ticket:** Ensure idempotent reuse of checkout_group_id
* [ ] **Ticket:** Expose converted state via CartRecord fetch (if needed)

---

# Phase 9 — Observability, Safety & Regression

**Goal:** Make cart quote production-safe.

* [ ] **Ticket:** Add structured logging to quote service
* [ ] **Ticket:** Add metrics (latency, item count, vendor count, warnings)
* [ ] **Ticket:** Add rate limiting to cart quote endpoint
* [ ] **Ticket:** Update tests for new schema + DTOs
* [ ] **Ticket:** Add regression tests (MOQ clamp, vendor invalid, mismatch, promo invalid)
* [ ] **Ticket:** Add guard tests ensuring no inventory mutation
