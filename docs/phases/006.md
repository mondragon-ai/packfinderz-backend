✅ DONE
## Title [PF-056]: Product model and database migrations

## Type

Feature

## Description

Define the canonical `products` data model for vendor listings and create the required Postgres migrations. This establishes the authoritative schema for all vendor products, including pricing, MOQ, and media attachment requirements.

## Scope

* Create `products` table per Doc 4 specification `DESIGN_DOC.md`
* Enforce required fields, constraints, and indexes
* Ensure `media_id` (or attachment requirement) is enforced per product rules
* Add foreign key to vendor `stores`

## Acceptance Criteria

* [ ] Goose migration creates `products` table with all required columns and constraints
* [ ] Migration is idempotent and reversible where safe
* [ ] Product rows cannot exist without a vendor store owner
* [ ] Unit tests or migration verification confirms schema correctness

## Dependencies

* Blocked by: None
* Blocks: Vendor create/update product endpoints

## Technical Notes

* Table: `products`
* Enums: reuse existing enums where defined
* FK: `store_id → stores(id)`
* **ASSUMPTION:** Media is attached via `media_attachments`, not a direct FK column

## Out of Scope

* Product API endpoints
* Search indexing
* Media upload logic

---
✅ DONE
## Title [PF-057]: Inventory model and database migrations

## Type

Feature

## Description

Introduce the `inventory_items` table to support optimistic inventory reservation and prevent overselling. Inventory is authoritative per product and updated atomically during checkout.

## Scope

* Create `inventory_items` table
* Enforce non-negative quantity constraints
* One-to-one relationship with `products`

## Acceptance Criteria

* [ ] Goose migration creates `inventory_items` table
* [ ] Each product can have at most one inventory row
* [ ] Constraints prevent negative available or reserved quantities
* [ ] Inventory row is deleted when product is deleted

## Dependencies

* Blocked by: PF-056
* Blocks: Inventory set endpoint, checkout flow

## Technical Notes

* Table: `inventory_items`
* PK: `product_id`
* Used by checkout atomic update logic
* **ASSUMPTION:** Inventory rows are created at product creation time

## Out of Scope

* Reservation logic
* TTL release logic
* Inventory analytics

---
✅ DONE
## Title [PF-058]: Volume discount model and database migrations

## Type

Feature

## Description

Create a normalized volume discount model to support tiered pricing per product based on quantity thresholds.

## Scope

* Create `product_volume_discounts` table
* Enforce uniqueness per product and `min_qty`
* Support deterministic pricing evaluation

## Acceptance Criteria

* [ ] Goose migration creates `product_volume_discounts` table
* [ ] Unique constraint on `(product_id, min_qty)`
* [ ] Discounts can be queried ordered by `min_qty DESC`
* [ ] Schema matches Doc 4 specification

## Dependencies

* Blocked by: PF-056
* Blocks: Pricing validation at checkout

## Technical Notes

* Table: `product_volume_discounts`
* Pricing model uses `unit_price_cents`
* **ASSUMPTION:** Percent-off discounts are not supported in MVP

## Out of Scope

* Admin discount overrides
* Store-wide promotions
* Discount UI logic

---
✅ DONE
## Title [PF-059]: Add GORM models + repositories for Products, Inventory, and Volume Discounts

## Type

Feature

## Description

Create the **canonical GORM models** and **repository layer** for the schemas introduced in **PF-056 / PF-057 / PF-058** so domain services/controllers can depend on a consistent data access API (no ad-hoc GORM usage across handlers).

This ticket introduces:

* GORM model structs (aligned to Doc 4 `DESIGN_DOC.md`)
* Domain repository interfaces + concrete GORM repos (aligned to existing `internal/repo.Base` pattern)

* Add the proper enums (see the last 3 migratiosn for all four tables) to the global oacakge enums as well. 

## Scope

* Add GORM models for:

  * `products`
  * `inventory_items` (1:1 with product)
  * `product_volume_discounts`
  * `product_media` (since product listings require media ordering in Doc 4)
* Add repositories (domain-owned) with methods needed by upcoming services:

  * create/update/delete product
  * upsert inventory
  * manage volume discounts
  * list/get products with **preloads** (vendor summary + inventory + discounts + media)
* Provide a **VendorSummary** projection for product read paths:

  * vendor `store_id`
  * vendor `company_name`
  * vendor logo (nullable): `logo_media_id` + signed/public url resolved at service layer (**ASSUMPTION**: logo is represented by a `media_attachments` row `owner_type='store'` OR a `stores.logo_media_id` if you already have it—repo should support either join path via a query helper)

## Acceptance Criteria

* [ ] Models exist under `/pkg/db/model` and compile
* [ ] Repos exist in the **correct domain** (recommended):

  * `/internal/products/repo` (product + read models)
  * `/internal/inventory/repo` (inventory rows / atomic updates later)
  * `/internal/discounts/repo` (volume discounts) **OR** keep discounts under `/internal/products/repo` if that’s your current domain grouping (**ASSUMPTION**: keep all 3 under `internal/products` for MVP simplicity)
* [ ] Repository methods are context-aware and accept injected `*gorm.DB` (reuse `internal/repo.Base`)
* [ ] Repo supports “product detail” read that includes:

  * product fields
  * inventory (if exists)
  * volume discounts ordered by `min_qty DESC`
  * product media ordered by `position ASC`
  * vendor summary (store name + optional logo reference)
* [ ] At least one DB test per repo exists behind `//go:build db` validating:

  * create → fetch → update → fetch
  * unique constraint behavior (`(product_id, min_qty)` on discounts)
  * inventory 1:1 behavior (PK = `product_id`)
* [ ] No API endpoints/controllers are added in this ticket

## Dependencies

* Blocked by:

  * PF-056 (products migration)
  * PF-057 (inventory migration)
  * PF-058 (volume discounts migration)
* Blocks:

  * Vendor create/update product endpoints
  * Inventory set endpoint
  * Checkout pricing validation (discount lookup)

## Technical Notes

* Tables (per Doc 4):

  * `products(store_id FK → stores(id))`
  * `inventory_items(product_id PK/FK → products(id))`
  * `product_volume_discounts(product_id FK → products(id), unique(product_id,min_qty))`
  * `product_media(product_id FK → products(id), unique(product_id,position))`
* GORM conventions:

  * UUID primary keys, `gen_random_uuid()` at DB layer (models should use `uuid.UUID`)
  * timestamps: `created_at`, `updated_at`
  * preloading: use explicit `Preload` + ordered scopes
* VendorSummary:

  * Repo should expose a read DTO (not the full Store model) for product browse/detail responses
  * **ASSUMPTION:** vendor logo resolution is done in service using existing media signing helpers; repo returns either `logo_media_id` or `logo_gcs_key` (nullable) depending on your chosen store-logo storage pattern
* Inventory join decision:

  * Do **NOT** embed inventory fields into `products` model
  * Keep 1:1 relation via `InventoryItem` and `Preload("Inventory")` for reads
  * (Atomic reserve/update logic is out of scope here)

## Out of Scope

* Product/inventory/discount API endpoints
* Checkout reservation logic / atomic updates
* Search indexing / Elasticsearch
* Media upload/presign or attachment creation flows (other than adding `product_media` model + repo helpers)

---
✅ DONE
## Title [PF-068]: Vendor create product endpoint

## Type

Feature

## Description

Implement the vendor-facing API endpoint to create new products, including validation of pricing, MOQ, inventory initialization, and media attachment requirements.

## Scope

* `POST /api/v1/vendor/products`
* Validate vendor store context and permissions
* Create product + inventory row in a single transaction
* Enforce required fields and invariants
* Vendor may upload/add media. The DTO request should receive a list of media UUIDs and that will crete the list of _Product Medias to be assiociated with the product.  That may be created same TXT as well. 
* Vendor may decide to add volume discounts. The. request DTO will be a list of discount objects of `min_qty` and the discounted `unit_price_cents`. That may be created same TXT as well.

## Acceptance Criteria

* [ ] Endpoint creates product owned by active vendor store
* [ ] Inventory row is initialized correctly
* [ ] Invalid payloads return canonical validation errors
* [ ] Idempotency-Key is enforced
* [ ] Role based (all users may create/update only managers & owners can delete)

## Dependencies

* Blocked by: PF-501, PF-502
* Blocks: Product management UI

## Technical Notes

* Controller: `api/controllers/products`
* Service: `internal/products`
* **ASSUMPTION:** Media can be inline or later in a PUT.

## Out of Scope

* Product updates
* Media upload
* Search indexing

---
✅ DONE
## Title [PF-069]: Vendor update product endpoint 

## Type

Feature

## Description

Implement vendor product updates while syncronozing connected rows from relevant tables. 

## Scope

* `PATCH /api/v1/vendor/products/{productId}`
* Allow updates to mutable fields only
* Enforce vendor ownership and role permissions

## Acceptance Criteria

* [ ] Unauthorized updates are rejected with 403
* [ ] Updates persist correctly and return updated DTO
* [ ] Validation errors use canonical error envelope

## Dependencies

* Blocked by: PF-068
* Blocks: Vendor product management UX

## Technical Notes

* **ASSUMPTION:** Media, Inventory & Discounts must be syncriounsly updated as well and logic to ensure no duplicates. 

## Out of Scope

* Media replacement
* Inventory updates
* Admin overrides

---
✅ DONE
## Title [PF-070]: Vendor delete product endpoint

## Type

Feature

## Description

Allow vendors to permanently delete products they own, cascading inventory and discounts, & media as appropriate.

## Scope

* `DELETE /api/v1/vendor/products/{productId}`
* Enforce ownership and permission checks
* Hard delete product and dependent rows

## Acceptance Criteria

* [ ] Product is removed from database
* [ ] Inventory row is deleted
* [ ] Orphaned inventory and discounts, & media attachments are cleaned up or detached
* [ ] Endpoint returns 204 on success

## Dependencies

* Blocked by: PF-069
* Blocks: Product lifecycle completion

## Technical Notes

* FK cascades relied upon where defined
* **ASSUMPTION:** Orders referencing deleted products keep snapshot data

## Out of Scope

* Soft delete / archival
* Admin recovery

---

## Title [PF-071]: Inventory set endpoint (idempotent)

## Type

Feature

## Description

Provide a vendor-only endpoint to set available inventory quantities in an idempotent manner.

## Scope

* `PUT /api/v1/inventory/{productId}`
* Set `available_qty` explicitly
* Enforce idempotency and optimistic correctness

## Acceptance Criteria

* [ ] Endpoint updates inventory deterministically
* [ ] Idempotency-Key prevents duplicate effects
* [ ] Invalid quantities are rejected
* [ ] Vendor ownership is enforced

## Dependencies

* Blocked by: PF-502
* Blocks: Inventory management UI

## Technical Notes

* Table: `inventory_items`
* **ASSUMPTION:** Reserved quantity is never modified here

## Out of Scope

* Reservation logic
* Inventory deltas
* Bulk updates

---
✅ DONE
## Title [PF-072]: MOQ validation (client + server)

## Type

Task

## Description

Ensure Minimum Order Quantity (MOQ) rules are enforced consistently on both client and server during cart and checkout flows.

## Scope

* Server-side validation during checkout
* Shared validation rules with frontend
* Canonical error responses on violation

## Acceptance Criteria

* [ ] Checkout fails with 422 when MOQ not met
* [ ] Error payload identifies offending product(s)
* [ ] Validation logic is unit-tested

## Dependencies

* Blocked by: PF-504
* Blocks: Checkout correctness

## Technical Notes

* MOQ stored on `products`
* **ASSUMPTION:** Client-side validation already exists or will mirror server logic

## Out of Scope

* Discount interactions
* Vendor overrides

---

## Title [PF-073]: Vendor/product visibility gating (license + subscription + state)

## Type

Feature

## Description

Enforce vendor visibility rules so only licensed and subscribed vendors appear in buyer-facing product search and browse endpoints.

## Scope

* Apply gating at query level
* Reuse canonical visibility rules
* Ensure no leakage via direct product access

## Acceptance Criteria

* [ ] Unverified vendors never appear in search (see `store.KYCStatus`)
* [ ] Lapsed subscriptions hide vendor listings immediately (see `store.SubscriptionActive` == `true`)
* [ ] Only products and stores are displayed to the buyer when they both are from the state (`store.Address.State` is the same.)
* [ ] Buyer access to hidden vendors returns 404/422

## Dependencies

* Blocked by: License + subscription models
* Blocks: Marketplace correctness

## Technical Notes

* Tables: `stores`, `subscriptions`, `products`
* Applied in `GET /products` LIST & `GET /products/{productID}` and vendor directory queries
* **ASSUMPTION:** Gating is enforced server-side only

## Out of Scope

* Admin preview access
* Caching strategies

---

## Title [PF-510]: Product audit logging

## Type

Task

## Description

Emit audit log entries for critical product lifecycle actions to ensure traceability and compliance.

## Scope

* Log product create, update, delete actions
* Include actor, store, and target metadata
* Append-only audit records

## Acceptance Criteria

* [ ] Audit logs written for create/update/delete
* [ ] Logs include actor_user_id and store context
* [ ] No sensitive fields are logged

## Dependencies

* Blocked by: PF-504
* Blocks: Compliance readiness

## Technical Notes

* Table: `audit_logs`
* Action names must be deterministic
* **ASSUMPTION:** Audit logging helper already exists

## Out of Scope

* Analytics ingestion
* Admin UI for audit logs

---

If you want, next we can:

* Convert these into **Phase 5 implementation order**
* Generate **Codex/Claude code-generation prompts per ticket**
* Or do **Phase 6 — Orders & Checkout** in the same rigor
