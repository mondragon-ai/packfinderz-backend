
# Title [PF-136]: Create `cron-worker` binary with scheduler, locking, and metrics

## Type

Infra

## Description

Create a dedicated `cron-worker` binary responsible for **time-based orchestration only**. This worker runs scheduled jobs every 24 hours and enforces time-driven invariants without Pub/Sub or event streaming.

## Scope

* Create `cmd/cron-worker` entrypoint
* Job registry abstraction
* Global execution lock (single leader)
* Structured logging and basic metrics
* Fixed 24h cadence execution

**NOT included**

* Job business logic
* Pub/Sub or queue consumption
* Per-job concurrency decisions

## Acceptance Criteria

* [ ] `cron-worker` starts as an independent binary
* [ ] Only one instance executes jobs at a time (lock enforced)
* [ ] All registered jobs run once per 24h window
* [ ] Job start/end + duration are logged
* [ ] Failure of one job does not crash the worker
* [ ] Add to the Make File when runnig dev + the docker & heroky yml file

## Dependencies

* Blocked by: None
* Blocks: all future one

## Technical Notes

* Path: `cmd/cron-worker/main.go`
* Locking options:

  * DB advisory lock
  * Redis lock (preferred if already used)
* Metrics:

  * job_duration_seconds
  * job_success / job_failure
* **ASSUMPTION:** cron-worker is deployed separately from API/other workers

## Out of Scope

* Horizontal scaling
* Distributed cron
* Job retries beyond next scheduled run

---


# Title [PF-137]: Implement license lifecycle cron jobs (warning, expiration, hard delete)

## Type

Feature

## Description

Enforce license lifecycle invariants via daily cron jobs. This includes notifying vendors of expiring licenses, expiring licenses past validity, revoking store eligibility when needed, and hard-deleting long-expired licenses and their media.

## Scope

* Scan licenses by date windows:

  * 14-day expiration warning
  * expired (0–30 days)
  * expired >30 days
* Emit outbox events for notifications (use `pkg/outbox/**/*.go` folder for outbox repo and services)
* Update license status on expiration `license.status=expired`
* Revoke `store.kyc_status=expired` when no valid licenses remain
* Hard-delete licenses and related media after 30 days of being expired (if not manually deleted by user)

**NOT included**

* Notification delivery
* Media deletion worker orchestration
* UI updates

## Acceptance Criteria

* [ ] Licenses expiring in 14 days generate outbox notifications vendor (ONCE at the 14 day start) (use `pkg/outbox/**/*.go` folder for outbox repo and services)
* [ ] Expired licenses are marked `expired` generate outbox notification to vendor (use `pkg/outbox/**/*.go` folder for outbox repo and services)
* [ ] Store license validity is revoked when no valid licenses remain
* [ ] Licenses expired >30 days are deleted
* [ ] Associated `media` and `media_attachment` rows are removed 
* [ ] All side effects occur in deterministic order

## Dependencies

* Blocked by:

  * PF-XXX
  * Phase 14 media attachment rules
* Blocks: None

## Technical Notes

* Tables:

  * `licenses`
  * `stores`
  * `media_attachments`
  * `media`
* Outbox events:

  * `license_expiring_soon`
  * `license_expired`
* **ASSUMPTION:** license expiration dates are authoritative and immutable

## Out of Scope

* Grace periods
* Partial license revocation
* Admin override flows

---


# Title [PF-138]: Implement order TTL cron job (nudge → expire → inventory release)

## Type

Feature

## Description

Enforce order time-to-live rules via daily cron execution. Orders that remain pending too long must trigger vendor nudges, eventual expiration, and inventory release.

## Scope

* Scan pending orders in time windows:

  * ≥5 days pending → vendor nudge
  * ≥10 days pending → expire order
* Emit outbox notifications rows to buyer and vendor (2 record) (use `pkg/outbox/**/*.go` folder for outbox repo and services)
* Expire orders deterministically  `vendor_orders.status=expired`
* Release reserved inventory

**NOT included**

* Real-time reminders
* Payment retries
* Partial fulfillment handling

## Acceptance Criteria

* [ ] Vendors are notified when orders reach 5 days pending
* [ ] Orders ≥10 days pending are expired
* [ ] Buyers and vendors are notified on expiration
* [ ] Inventory reservations are released
* [ ] Orders are not double-processed across runs

## Dependencies

* Blocked by:

  * PF-XXX
  * Inventory reservation logic
* Blocks: None

## Technical Notes

* Tables:

  * `orders`
  * `order_items`
  * `inventory`
* Outbox events:

  * `order_pending_nudge`
  * `order_expired`
* **ASSUMPTION:** order timestamps are server-generated and trusted

## Out of Scope

* Escalation logic
* Manual admin intervention

---


# Title [PF-139]: Implement notification retention cleanup job (>30 days)

## Type

Task

## Description

Delete stale in-app notifications older than 30 days to keep the notifications table bounded and performant.

## Scope

* Daily scan of notifications
* Hard delete records older than 30 days

**NOT included**

* Archival
* Soft deletes
* Per-store retention policies

## Acceptance Criteria

* [ ] Notifications older than 30 days are deleted
* [ ] Job is idempotent
* [ ] Execution time scales with table size

## Dependencies

* Blocked by: PF-XXX
* Blocks: None

## Technical Notes

* Table: `notifications`
* Query:

  ```sql
  DELETE FROM notifications
  WHERE created_at < now() - interval '30 days';
  ```
* **ASSUMPTION:** notifications have no compliance retention requirement

## Out of Scope

* User-configurable retention
* Notification analytics

---


# Title [PF-140]: Implement outbox retention cleanup job (>30 days published)

## Type

Task

## Description

Clean up published outbox records older than 30 days to prevent unbounded growth of the outbox table.

## Scope

* Scan outbox records with `published_at` & `attempt_count` >= 5 count (assume it was already sent to DLQ)
* Delete records older than 30 days

**NOT included**

* Reprocessing logic
* Dead-letter handling

## Acceptance Criteria

* [ ] Published outbox records older than 30 days are deleted
* [ ] Unpublished records are not deleted unless `attempt_count` >= 5
* [ ] Cleanup does not block active consumers

## Dependencies

* Blocked by: PF-XXX
* Blocks: None

## Technical Notes

* Table: `outbox_events`
* Query:

  ```sql
  DELETE FROM outbox_events
  WHERE published_at IS NOT NULL
    AND published_at < now() - interval '30 days';
  ```
* **ASSUMPTION:** 30 days is sufficient audit window for MVP

## Out of Scope

* Compliance archiving
* Cross-region replication

---


# Title [PF-141]: Decide and document cron-worker concurrency model

## Type

Chore

## Description

Decide whether cron jobs should execute sequentially or concurrently (goroutines) and document the rationale clearly. This decision impacts scalability, DB load, and failure isolation.

## Scope

* Evaluate sequential vs concurrent execution
* Consider number of jobs and per-job scan complexity
* Document chosen model and guardrails

**NOT included**

* Implementation of parallelism
* Dynamic job scaling

## Acceptance Criteria

* [ ] Concurrency model is explicitly documented
* [ ] Rationale references current and future scale
* [ ] Risks and mitigations are listed

## Dependencies

* Blocked by: PF-XXX
* Blocks: PF-XXX, PF-XXX, PF-XXX, PF-XXX (implementation clarity)

## Technical Notes

* Recommendation likely:

  * One goroutine per job
  * Shared DB pool with limits
* **ASSUMPTION:** job count remains small (≤10) for foreseeable future

## Out of Scope

* Adaptive concurrency
* Per-store sharding

---
