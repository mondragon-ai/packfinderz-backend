# Title [PF-141]: Finalize `cmd/outbox-publisher` dispatcher binary

## Type

Infra

## Description

Finalize the `cmd/outbox-publisher` binary that continuously dispatches authoritative Postgres outbox events to Pub/Sub. This binary acts as a **pure transport and safety layer**, with no business logic, enforcing the canonical dispatcher control flow defined in the master context.

## Scope

* Implement main dispatcher loop
* Fetch unpublished outbox rows using `FOR UPDATE SKIP LOCKED`
* Process rows sequentially within a batch
* Sleep with jitter between polling cycles
* Structured logging per attempt

**Explicitly NOT included**

* Cron semantics or scheduling guarantees
* Domain-specific decisions
* Pub/Sub consumer logic

## Acceptance Criteria

* [ ] Binary builds and runs independently as `cmd/outbox-publisher`
* [ ] Dispatcher fetches only `published_at IS NULL` rows
* [ ] Rows are locked using `FOR UPDATE SKIP LOCKED`
* [ ] Each row is processed exactly once per loop iteration
* [ ] Failure of one row does not halt the dispatcher

## Dependencies

* Blocked by: `outbox_events` table exists
* Blocks: PF-XXX, PF-XXX, PF-XXX, PF-XXX

## Technical Notes

* Entry points:

  * `cmd/outbox-publisher/main.go`
  * `cmd/outbox-publisher/service.go`
* Additional helpers will live in `internal/outbox/*.go`. maybe break up `cmd/outbox-publisher/service.go` and add in the `internal/outbox/*.go` folder as well. 
* Batch size SHOULD be configurable
* Sleep jitter prevents thundering herd
* **ASSUMPTION:** at-least-once semantics are acceptable and expected

## Out of Scope

* Horizontal scaling coordination
* Leader election
* Backpressure from consumers

---

Here is the **final tightened version** with **zero ambiguity** about how `event_type`, `aggregate_type`, `aggregate_id`, and `payload_json` participate in dispatching.
It stays concise but removes all room for interpretation by an LLM or engineer.

---

# Title [PF-142]: Implement explicit event → topic routing registry with typed payload + envelope validation

## Type

Feature

## Description

Introduce a **single authoritative registry** responsible for translating `outbox.event_type` → Pub/Sub topic and validating the **typed payload contract** and **envelope invariants** for that event **before publish**.

The dispatcher MUST publish **only what is already persisted in the outbox row** and MUST NOT fetch or enrich data at dispatch time.

This registry is the **only allowed decision point** for routing, payload typing, and schema enforcement in the **Outbox Dispatcher Worker**.

---

## Scope

### Included

* Central registry (explicit switch / map) keyed by `event_type`
* Exactly **one canonical Pub/Sub topic per `event_type`** (we can add later one but for now, analytics, notifications, billing are our starting topics -- see env example files and config/consts file)
* Strongly typed payload structs per `event_type`
* Decode + validate `payload_json` **before** Pub/Sub envelope construction
* Explicit handling for empty payloads (`{}` allowed, `NULL` not allowed)
* Validation of **envelope invariants** derived from the outbox row:

  * `aggregate_type` must be present and match the expected aggregate for the `event_type`
  * `aggregate_id` must be present and non-nil
* Unknown `event_type` treated as **terminal (non-retryable) failure**

### Explicitly NOT included

* Dynamic or config-driven routing
* Reflection-based routing
* Payload enrichment or DB lookups at dispatch time
* Backward-compatible payload coercion
* Multi-topic fanout

---

## Acceptance Criteria

* [ ] Every supported `event_type` resolves to **exactly one** Pub/Sub topic via the registry
* [ ] Registry defines the **expected aggregate_type** for each `event_type`
* [ ] Unknown `event_type` is classified as **non-retryable** and sent to DLQ (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] `payload_json` is decoded into the **correct Go struct** for that `event_type`
* [ ] Payload validation failure is **non-retryable** and results in DLQ (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] Missing or invalid `aggregate_type` / `aggregate_id` results in **non-retryable** failure (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] Dispatcher never publishes events with untyped, unchecked, or null payloads
* [ ] Dispatcher does **not** fetch or derive additional data beyond the outbox row

---

## Dependencies

* Blocked by: PF-XXX (Outbox Dispatcher Worker bootstrap)
* Blocks: PF-XXX (Outbox analytics publisher)

---

## Technical Notes

* Registry locations:

  * `pkg/outbox/registry` → event_type → topic + expected aggregate + payload schema
  * `pkg/outbox/payloads` → typed payload definitions
* Registry MUST be:

  * explicit (switch or static map; no reflection)
  * exhaustive (missing cases should be compiler-visible where possible)
* Registry consumes **only** the following outbox fields:

  * `event_type` → routing + payload schema selection
  * `aggregate_type` → envelope validation
  * `aggregate_id` → envelope validation
  * `payload_json` → typed payload decoding + validation
* Payload validation occurs **before** Pub/Sub message construction
* Canonical event names, aggregates, and topic mappings MUST align with **MASTER CONTEXT**
* **ASSUMPTION:** payload schemas are versioned in code, not stored in DB

---

## Out of Scope

* Schema migration or evolution tooling
* Event version negotiation
* Multiple payload versions per `event_type`


---

# Title [PF-XXX]: Define retry policy and attempt handling for outbox publishing

## Type

Task

## Description

Implement bounded retry behavior for outbox publishing failures. The dispatcher must distinguish retryable vs non-retryable failures and update attempt counters and error metadata accordingly.

## Scope

* Classify failures as retryable vs non-retryable
* Increment `attempts` only after failed publish
* Persist `last_error` with short reason
* Enforce `MAX_ATTEMPTS` cutoff

**Explicitly NOT included**

* Pub/Sub internal retry logic
* Exponential retry inside Pub/Sub client

## Acceptance Criteria

* [ ] Retryable failures increment `attempts`
* [ ] Non-retryable failures do not retry
* [ ] Events exceeding `MAX_ATTEMPTS` are terminal
* [ ] Dispatcher never marks published without Pub/Sub ack

## Dependencies

* Blocked by: PF-XXX
* Blocks: PF-XXX

## Technical Notes

* Config:

  * `MAX_ATTEMPTS = 10` (configurable)
* Retryable examples:

  * transient network errors
  * Pub/Sub timeouts
* Non-retryable examples:

  * unknown event_type
  * payload decode failure
* **ASSUMPTION:** attempt count is authoritative for terminal state

## Out of Scope

* Dynamic retry tuning
* Per-event retry policies

---

# Title [PF-XXX]: Implement DLQ model, migration, and repository

## Type

Infra

## Description

Introduce a first-class Dead Letter Queue (DLQ) persistence model to capture terminal outbox failures. DLQ rows preserve the original event envelope and error context for inspection and manual remediation.

## Scope

* Create `outbox_dlq` table migration
* Define DLQ model and repository helpers
* Persist DLQ rows atomically with terminal outbox state

**Explicitly NOT included**

* Automatic reprocessing
* Admin UI for DLQ inspection

## Acceptance Criteria

* [ ] `outbox_dlq` table exists with required columns
* [ ] DLQ rows store original envelope payload
* [ ] DLQ write is atomic with terminal outbox update
* [ ] DLQ rows are never retried automatically

## Dependencies

* Blocked by: PF-XXX
* Blocks: PF-XXX

## Technical Notes

* Table: `outbox_dlq`
* Fields MUST match master context spec
* Repo location: `pkg/outbox/dlq_repository.go`
* **ASSUMPTION:** DLQ retention is handled separately (cron cleanup)

## Out of Scope

* DLQ replay tooling
* Metrics dashboards

---

# Title [PF-XXX]: Publish to DLQ on terminal outbox failure

## Type

Feature

## Description

Integrate DLQ publishing into the dispatcher control flow. When an outbox event reaches a terminal failure state (non-retryable error or max attempts exceeded), the dispatcher must write a DLQ row and mark the outbox event as terminal.

## Scope

* Detect terminal failure conditions
* Construct original event envelope for DLQ
* Write DLQ row
* Prevent further processing of the outbox row

**Explicitly NOT included**

* DLQ reprocessing
* Notifications or alerts on DLQ write

## Acceptance Criteria

* [ ] Non-retryable failures result in DLQ write
* [ ] Events exceeding `MAX_ATTEMPTS` result in DLQ write
* [ ] Outbox row is not retried after DLQ
* [ ] DLQ payload matches original envelope exactly

## Dependencies

* Blocked by: PF-XXX, PF-XXX, PF-XXX
* Blocks: None

## Technical Notes

* DLQ write MUST occur before marking outbox terminal
* Envelope fields MUST mirror publish envelope
* **ASSUMPTION:** “terminal” means `published_at` remains NULL and row is excluded by dispatcher

## Out of Scope

* Alerting on DLQ growth
* Partial DLQ writes
