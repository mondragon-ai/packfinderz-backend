# Title [PF-141]: Finalize `cmd/outbox-publisher` dispatcher binary

## Type

Infra

## Description

Finalize the `cmd/outbox-publisher` binary that continuously dispatches authoritative Postgres outbox events to Pub/Sub. This binary acts as a **pure transport and safety layer**, with no business logic, enforcing the canonical dispatcher control flow defined in the master context.

## Scope

* Implement main dispatcher loop
* Fetch unpublished outbox rows using `FOR UPDATE SKIP LOCKED`
* Process rows sequentially within a batch
* Sleep with jitter between polling cycles
* Structured logging per attempt

**Explicitly NOT included**

* Cron semantics or scheduling guarantees
* Domain-specific decisions
* Pub/Sub consumer logic

## Acceptance Criteria

* [ ] Binary builds and runs independently as `cmd/outbox-publisher`
* [ ] Dispatcher fetches only `published_at IS NULL` rows
* [ ] Rows are locked using `FOR UPDATE SKIP LOCKED`
* [ ] Each row is processed exactly once per loop iteration
* [ ] Failure of one row does not halt the dispatcher

## Dependencies

* Blocked by: `outbox_events` table exists
* Blocks: PF-XXX, PF-XXX, PF-XXX, PF-XXX

## Technical Notes

* Entry points:

  * `cmd/outbox-publisher/main.go`
  * `cmd/outbox-publisher/service.go`
* Additional helpers will live in `internal/outbox/*.go`. maybe break up `cmd/outbox-publisher/service.go` and add in the `internal/outbox/*.go` folder as well. 
* Batch size SHOULD be configurable
* Sleep jitter prevents thundering herd
* **ASSUMPTION:** at-least-once semantics are acceptable and expected

## Out of Scope

* Horizontal scaling coordination
* Leader election
* Backpressure from consumers

---

Here is the **final tightened version** with **zero ambiguity** about how `event_type`, `aggregate_type`, `aggregate_id`, and `payload_json` participate in dispatching.
It stays concise but removes all room for interpretation by an LLM or engineer.

---

# Title [PF-142]: Implement explicit event → topic routing registry with typed payload + envelope validation

## Type

Feature

## Description

Introduce a **single authoritative registry** responsible for translating `outbox.event_type` → Pub/Sub topic and validating the **typed payload contract** and **envelope invariants** for that event **before publish**.

The dispatcher MUST publish **only what is already persisted in the outbox row** and MUST NOT fetch or enrich data at dispatch time.

This registry is the **only allowed decision point** for routing, payload typing, and schema enforcement in the **Outbox Dispatcher Worker**.

---

## Scope

### Included

* Central registry (explicit switch / map) keyed by `event_type`
* Exactly **one canonical Pub/Sub topic per `event_type`** (we can add later one but for now, analytics, notifications, billing are our starting topics -- see env example files and config/consts file)
* Strongly typed payload structs per `event_type`
* Decode + validate `payload_json` **before** Pub/Sub envelope construction
* Explicit handling for empty payloads (`{}` allowed, `NULL` not allowed)
* Validation of **envelope invariants** derived from the outbox row:

  * `aggregate_type` must be present and match the expected aggregate for the `event_type`
  * `aggregate_id` must be present and non-nil
* Unknown `event_type` treated as **terminal (non-retryable) failure**

### Explicitly NOT included

* Dynamic or config-driven routing
* Reflection-based routing
* Payload enrichment or DB lookups at dispatch time
* Backward-compatible payload coercion
* Multi-topic fanout

---

## Acceptance Criteria

* [ ] Every supported `event_type` resolves to **exactly one** Pub/Sub topic via the registry
* [ ] Registry defines the **expected aggregate_type** for each `event_type`
* [ ] Unknown `event_type` is classified as **non-retryable** and sent to DLQ (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] `payload_json` is decoded into the **correct Go struct** for that `event_type`
* [ ] Payload validation failure is **non-retryable** and results in DLQ (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] Missing or invalid `aggregate_type` / `aggregate_id` results in **non-retryable** failure (DLQ model and repo not yet deployed add plumming and stubb later ticket integrates)
* [ ] Dispatcher never publishes events with untyped, unchecked, or null payloads
* [ ] Dispatcher does **not** fetch or derive additional data beyond the outbox row

---

## Dependencies

* Blocked by: PF-XXX (Outbox Dispatcher Worker bootstrap)
* Blocks: PF-XXX (Outbox analytics publisher)

---

## Technical Notes

* Registry locations:

  * `pkg/outbox/registry` → event_type → topic + expected aggregate + payload schema
  * `pkg/outbox/payloads` → typed payload definitions
* Registry MUST be:

  * explicit (switch or static map; no reflection)
  * exhaustive (missing cases should be compiler-visible where possible)
* Registry consumes **only** the following outbox fields:

  * `event_type` → routing + payload schema selection
  * `aggregate_type` → envelope validation
  * `aggregate_id` → envelope validation
  * `payload_json` → typed payload decoding + validation
* Payload validation occurs **before** Pub/Sub message construction
* Canonical event names, aggregates, and topic mappings MUST align with **MASTER CONTEXT**
* **ASSUMPTION:** payload schemas are versioned in code, not stored in DB

---

## Out of Scope

* Schema migration or evolution tooling
* Event version negotiation
* Multiple payload versions per `event_type`


---
Below are **clean, ambiguity-free upgrades** for each remaining ticket.
I’ve kept them tight, but added the **missing decision rules, invariants, and control-flow constraints** so an LLM (or engineer) has exactly one correct implementation path, consistent with everything defined earlier in this thread.

---

# Title [PF-143]: Define bounded retry policy and attempt handling for outbox publishing

## Type

Task

## Description

Implement **deterministic, bounded retry behavior** for the Outbox Dispatcher Worker.
The dispatcher MUST classify failures as **retryable or terminal**, update attempt counters and error metadata **authoritatively in Postgres**, and ensure no event is retried indefinitely or published without acknowledgement.

Retry behavior is driven solely by **dispatcher logic**, not by Pub/Sub internals.

---

## Scope

### Included

* Explicit classification of dispatcher failures:

  * **Retryable** (transient, infrastructure-level)
  * **Non-retryable / terminal** (schema, routing, or contract violations)
* Increment `outbox.attempts` **only after a failed publish attempt**
* Persist a concise, human-readable `last_error` on every failure
* Enforce a hard `MAX_ATTEMPTS` cutoff
* Ensure publish success is recorded **only after Pub/Sub ACK**

### Explicitly NOT included

* Pub/Sub client internal retry/backoff behavior
* Exponential backoff or jitter inside the dispatcher
* Per-event or per-topic retry tuning

---

## Acceptance Criteria

* [ ] Retryable failures increment `attempts` and allow future retry
* [ ] Non-retryable failures are immediately classified as terminal
* [ ] Events exceeding `MAX_ATTEMPTS` are classified as terminal
* [ ] Dispatcher never marks an event as published without a Pub/Sub ACK
* [ ] `attempts` and `last_error` are persisted in Postgres on every failure

---

## Dependencies

* Blocked by: PF-142 (Event → topic registry + payload validation)
* Blocks: PF-XXX (DLQ write on terminal failure)

---

## Technical Notes

* `MAX_ATTEMPTS = 10` (configurable; default constant)
* Retry classification MUST be explicit and centralized:

  * **Retryable examples**:

    * transient network errors
    * Pub/Sub timeouts
    * temporary service unavailability
  * **Non-retryable examples**:

    * unknown `event_type`
    * payload decode / validation failure
    * aggregate invariant violation
* Attempt count is authoritative for terminal state determination
* Retry decision MUST be made **after** registry + payload validation
* Dispatcher MUST NOT mutate payload or envelope between attempts

---

## Out of Scope

* Dynamic retry tuning
* Backoff strategies
* Observability dashboards for retries

---

# Title [PF-144]: Implement DLQ persistence model, migration, and repository

## Type

Infra

## Description

Introduce a **first-class Dead Letter Queue (DLQ) persistence model** to capture **terminal outbox failures**.
DLQ rows MUST preserve the **exact original event envelope** and failure context to support audit, debugging, and future manual remediation.

DLQ is a **storage concern**, not a processing queue.

---

## Scope

### Included

* Goose migration for `outbox_dlq` table
* DLQ model struct aligned with migration
* Repository helpers for writing/reading DLQ rows
* Atomic persistence of:

  * terminal outbox state
  * corresponding DLQ row

### Explicitly NOT included

* Automatic replay or reprocessing
* Admin UI or tooling
* Notifications or alerting

---

## Acceptance Criteria

* [ ] `outbox_dlq` table exists and matches MASTER CONTEXT spec
* [ ] DLQ rows store the **original publish envelope verbatim**
* [ ] DLQ write is atomic with marking the outbox row terminal
* [ ] DLQ rows are never retried or re-enqueued automatically

---

## Dependencies

* Blocked by: PF-143 (Retry policy)
* Blocks: PF-145 (DLQ publish on terminal failure)

---

## Technical Notes

* Table: `outbox_dlq`
* Required fields MUST include:

  * `event_id`
  * `event_type`
  * `aggregate_type`
  * `aggregate_id`
  * `payload_json`
  * `error_reason` (e.g. attempts, unknwond event, etc) -> enum as well 
  * `failed_at`
* Repository location:

  * `pkg/outbox/dlq_repository.go`
* DLQ rows are **append-only**
* **ASSUMPTION:** DLQ retention and cleanup handled by separate cron job

---

## Out of Scope

* DLQ replay tooling
* Metrics or dashboards
* Partial or best-effort DLQ writes

---

# Title [PF-145]: Publish to DLQ on terminal outbox failure

## Type

Feature

## Description

Integrate DLQ persistence into the Outbox Dispatcher Worker control flow.
When an outbox event reaches a **terminal failure state**—either due to a **non-retryable error** or exceeding `MAX_ATTEMPTS`—the dispatcher MUST persist a DLQ row and permanently exclude the event from further processing.

---

## Scope

### Included

* Detection of terminal failure conditions:

  * non-retryable failure
  * retryable failure exceeding `MAX_ATTEMPTS`
* Construction of the **exact publish envelope** for DLQ persistence
* Atomic write of:

  * DLQ row
  * terminal outbox state
* Hard exclusion of terminal outbox rows from dispatcher selection

### Explicitly NOT included

* DLQ reprocessing
* Alerts, notifications, or metrics
* Partial or best-effort DLQ persistence

---

## Acceptance Criteria

* [ ] Non-retryable failures result in immediate DLQ write
* [ ] Events exceeding `MAX_ATTEMPTS` result in DLQ write
* [ ] Outbox rows written to DLQ are never retried
* [ ] DLQ payload matches the original publish envelope **exactly**
* [ ] Dispatcher does not publish or retry terminal events

---

## Dependencies

* Blocked by:

  * PF-142 (Event registry + validation)
  * PF-143 (Retry policy)
  * PF-144 (DLQ model + repo)
* Blocks: None

---

## Technical Notes

* DLQ write MUST occur **before** marking outbox row terminal
* DLQ envelope MUST include:

  * `event_type`
  * `aggregate_type`
  * `aggregate_id`
  * `payload_json`
  * failure metadata
* “Terminal” means:

  * `published_at` remains `NULL`
  * dispatcher query explicitly excludes the row
* Dispatcher MUST NOT attempt publish after DLQ persistence

---

## Out of Scope

* Alerting on DLQ growth
* Replay or remediation workflows
* Partial DLQ writes or retries
