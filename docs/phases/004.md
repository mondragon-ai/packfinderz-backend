[DONE ✅]
## Title [PF-044]: License model + migration (media_id required)

## Type

Feature

## Description

Introduce the canonical `licenses` data model with a **required `media_id`** at creation time. Licenses are the source of truth for compliance and MUST always reference an uploaded media object (PDF/image) representing the license document.

This enforces the corrected compliance rule: **license metadata cannot exist without media**.

## Scope

* Create `licenses` table via Goose migration
* `media_id` is **NOT NULL**
* Enforce FK relationship to `media`
* Add required indexes for compliance workflows

## Acceptance Criteria

* [ ] `licenses.media_id` is `NOT NULL`
* [ ] Migration is reversible or forward-safe
* [ ] FK to `media(id)` enforced
* [ ] Indexes exist for `(store_id, status)` and `expiration_date`
* [ ] Migration runs cleanly in dev and prod modes
* [ ] Get the media metadata and validate the mime type is acceptable (PDF or Image)

* [ ] Goose migration creates `licenses` table with:

  * `id` (uuid, pk)
  * `store_id` (uuid, not null)
  * `user_id` (uuid, not null)
  * `status` (`license_status` enum)
  * `media_id` (uuid, not null) 
  * `created_at` (timestamptz)
  * `issuing_state` (text, not null) 
  * `issue_date`  (timestamptz)
  * `expiration_date`  (timestamptz)
  * `type` (`license_type` enum)
  * `number` (text, not null, unique) 

* [ ] Canonical `license_status` enum includes: `pending`, `verified`, `rejected`, `expired`
* [ ] Canonical `license_type` enum includes: `producer`, `grower`, `dispensary`, `merchant` (can be added later on)
* [ ] GORM models exist for `Licenses` in the DB models folder

## Dependencies

* Blocked by: Media table existing
* Blocks: PF-045, PF-047, PF-051

## Technical Notes

* Table: `licenses`
* Enum: `license_status`
* FK: `media_id → media(id)`
* **ASSUMPTION:** One license = one media document (no multi-doc license)

## Out of Scope

* Admin approval logic
* Background schedulers

---
[DONE ✅]
## Title [PF-045]: License create endpoint (atomic metadata + media_id)

## Type

Feature

## Description

Implement the license creation endpoint that **atomically creates license metadata**. Creating a license without a `media_id` reference MUST be impossible.

## Scope

* `POST /api/v1/licenses`
* Validate `media_id` ownership and readiness
* Create license in `pending` state
* Enforce store scoping via `activeStoreId`
* Idempotent behavior

## Acceptance Criteria

* [ ] Request without `media_id` fails validation (`400`)
* [ ] Media must belong to active store
* [ ] License is created with `status=pending`
* [ ] Idempotency enforced via `Idempotency-Key` (see middleware and redis client)
* [ ] Response returns created license object

## Dependencies

* Blocked by: PF-044
* Blocks: PF-048, PF-049

## Technical Notes

* Endpoint: `POST /api/v1/licenses`
* Validation: media must be `uploaded|ready` & accepted media type (image or pdf)
* **ASSUMPTION:** Media is uploaded before license creation (UI flow enforced)

## Out of Scope

* Admin verification
* OCR or data extraction
* Auto validation with scraping or api (state specific).

---

[DONE ✅]
## Title [PF-046]: License list endpoint (store-scoped)

## Type

Feature

## Description

Provide a read-only endpoint to list licenses belonging to the active store. This enables store users to view compliance status and upcoming expirations.

## Scope

* `GET /api/v1/licenses`
* Store-scoped via `activeStoreId`
* Return metadata +  signed URLs for the image/pdf of the uploaded doc (using the GCS Key `media.gcs_key`)

## Acceptance Criteria

* [ ] Only licenses for `activeStoreId` are returned
* [ ] Supports pagination
* [ ] Includes status, expiration date, and media_id
* [ ] Unauthorized access is rejected

## Dependencies

* Blocked by: PF-044
* Blocks: UI compliance views

## Technical Notes

* Table: `licenses`
* RBAC: any store member (where the `create` & `delete` endpoint is only `admin`, `managers` & `owners`)
* **ASSUMPTION:** Sorting by `created_at desc` default

## Out of Scope

* Admin/global listing
* Media previews

---

## Title [PF-047]: License delete endpoint (expired-only semantics)

## Type

Feature

## Description

Implement controlled license deletion. A license may ONLY be deleted if it is **expired**. If the deleted license was the store’s last valid license, the store’s KYC status MUST be downgraded.

## Scope

* `DELETE /api/v1/licenses/{licenseId}`
* Allow deletion only if `status=expired | rejected`
* Update store KYC mirror if needed
* Enforce store ownership
* Only `manager` and `owner` roles can perform this actions ( same as the create/uplaod license)

## Acceptance Criteria

* [ ] Deleting non-expired license returns `409`
* [ ] Expired license is deleted successfully
* [ ] If no remaining valid licenses → store becomes unverified
* [ ] Media is detached but not auto-deleted

## Dependencies

* Blocked by: PF-044
* Blocks: PF-050

## Technical Notes

* Table: `licenses`, `stores`
* **ASSUMPTION:** Media GC handled separately
* Store KYC update may be synchronous or event-driven

## Out of Scope

* Admin override delete
* Bulk deletion

---

## Title [PF-048]: Implement Admin License Approve/Reject Endpoint

## Type

Feature

## Description

Implement the admin-only endpoint to approve or reject a store license. This endpoint is the authoritative manual verification mechanism for OMMA licenses and drives downstream compliance state transitions.

Admins must be able to explicitly approve or reject a license, recording the decision in the `licenses` table and triggering the appropriate side effects (handled by outbox events in a separate tickets).

## Scope

* Implement `POST /api/v1/admin/licenses/{licenseId}/verify`
* Allow admin to set license status to `verified` or `rejected`
* Validate admin authorization
* Persist decision atomically

## Acceptance Criteria

* [ ] Admin can approve a pending license and its status becomes `verified`
* [ ] Admin can reject a pending license and its status becomes `rejected`
* [ ] Non-admin callers receive `403`
* [ ] Invalid or already-finalized licenses return `409`
* [ ] Endpoint is idempotent via `Idempotency-Key`

## Dependencies

* Blocked by:

  * License table (`licenses`) exists
  * Admin auth middleware
* Blocks:

  * Store KYC mirroring
  * Compliance notifications
  * Outbox event emission

## Technical Notes

* Endpoint: `POST /api/v1/admin/licenses/{licenseId}/verify`
* Tables: `licenses`
* Enum: `license_status`
* Must use canonical error handling via `pkg/errors`
* **ASSUMPTION:** Request body includes `{ "decision": "verified" | "rejected", "reason": string? }`

## Out of Scope

* Automated OMMA verification
* License document parsing
* Notifications or async side effects (handled separately)

---

## Title [PF-049]: Mirror License Status to Store KYC Status

## Type

Task

## Description

When a license is approved or rejected, the corresponding store’s `kyc_status` must be updated to reflect the aggregate license state. This ensures store-level compliance gating is enforced consistently across the platform.

The store KYC state is a mirror, not the source of truth.

## Scope

* Update `stores.kyc_status` based on license transitions
* Apply rules:

  * At least one verified license → `verified`
  * All licenses rejected or expired → `rejected` or `expired`
* Execute atomically with license decision

## Acceptance Criteria

* [ ] Approving a license updates store KYC to `verified`
* [ ] Rejecting the only active license updates store KYC to `rejected`
* [ ] Store KYC updates occur in the same DB transaction as license update
* [ ] No KYC update occurs if aggregate status does not change
* [ ] Outbox event to notify customer is necessary 

## Dependencies

* Blocked by:

  * PF-301 (admin license decision endpoint)
* Blocks:

  * Vendor visibility gating
  * Compliance notifications

## Technical Notes

* Tables: `licenses`, `stores`
* Logic lives in domain service layer (not controller)
* Must re-evaluate **all licenses for the store**
* **ASSUMPTION:** KYC rules are MVP-simple (no weighting by license type)

## Out of Scope

* Historical KYC state tracking
* Multi-state license aggregation logic

---

## Title [PF-050]: Emit License Status Outbox Events + Compliance Notifications

## Type

Feature

## Description

Emit outbox events whenever a license is uploaded to be reviewed, approved or rejected by admin, enabling downstream consumers (notifications, etc) to react asynchronously. Compliance notifications must be sent to both the store and admins.

This ticket wires compliance changes into the async eventing system.

## Scope

* Insert `outbox_events` rows on license approve/reject
* Define event type: `license_status_changed`
* Include relevant payload (licenseId, storeId, newStatus)
* Consume event to generate notifications:

  * Store notified of approval/rejection
  * Admin notified when license enters review queue -> uploaded & pending

## Acceptance Criteria

* [ ] Outbox event is written in same transaction as license update
* [ ] Event includes correct aggregate + payload
* [ ] Consumer processes event idempotently
* [ ] Store receives compliance notification on approve/reject
* [ ] Admin receives notification when license is submitted for review

## Dependencies

* Blocked by:

  * PF-301 (license decision)
  * Outbox infrastructure
* Blocks:

  * Compliance UX completeness

## Technical Notes

* Tables: `outbox_events`, `notifications`
* Pub/Sub topic: compliance events (new or existing) -> add to env.exmaple & config file if doesnt exist
* Consumer MUST use idempotency manager
* **ASSUMPTION:** One shared compliance topic is sufficient for MVP

## Out of Scope

* Email/SMS delivery (in-app notifications only)
* Analytics ingestion

---

## Title [PF-051]: Implement License Expiry Scheduler (14-Day Warning + Expiration)

## Type

Task

## Description

Implement a daily scheduler that enforces license expiry rules. The job must warn stores of upcoming expirations and automatically expire licenses on their expiration date, updating store KYC status accordingly.

This ensures compliance remains accurate without manual intervention.

## Scope

* Daily scheduled worker job
* Find licenses expiring in 14 days → notify store (outbox event -> notify with warning)
* Find licenses expired today → set status to `expired`   (outbox event -> notify expired)
* Mirror store KYC status after expiry  (only if no more valid licenses exist)
* Emit outbox events for all status changes

## Acceptance Criteria

* [ ] Scheduler runs once per day
* [ ] Stores receive warning notifications 14 days before expiry
* [ ] Licenses automatically flip to `expired` on expiration date
* [ ] Store KYC is recalculated after expiry  (only if no more valid licenses exist)
* [ ] Job is idempotent and safe to re-run

## Dependencies

* Blocked by:

  * License + store KYC logic
  * Notification consumer
* Blocks:

  * Long-term compliance correctness

## Technical Notes

* Worker: `cmd/worker` (scheduler loop) -> Repurpose to be a daily scheduler for this and other relevant tasks.
* Tables: `licenses`, `stores`, `outbox_events`
* Queries must be indexed (`expiration_date`)
* **ASSUMPTION:** Scheduler cadence is daily at fixed time

## Out of Scope

* Grace period beyond defined rules
* Manual admin overrides for expired licenses
