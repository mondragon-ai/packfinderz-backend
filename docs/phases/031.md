# Title [PF-275]: Goose migration + GORM models for wishlists table

## Type

Task

## Description

Create the database migration and GORM model for the `wishlists` table. This is the foundational persistence layer for the Wishlist feature and must exactly match the schema. The wishlist row represents the product ID to be added or removed from the stores wishlist, the store associated wiht the wishlist item, and the product from a browser product list endpoint. The wishlist item should include this product summary information or if only the product_id then join the product information on request. No store join to be added, just the store ID. No need to link a store row to this model-- only the prouct being aded to the wishlist. 

ADD THIS OR FETCH IT ON REQUEST TIME PER ITEM IN TEH WISH LSIT PER STORE:

```go
type ProductSummary struct {
	ID                  uuid.UUID `json:"id"`
	SKU                 string    `json:"sku"`
	Title               string    `json:"title"`
	Subtitle            *string   `json:"subtitle,omitempty"`
	Category            string    `json:"category"`
	Classification      *string   `json:"classification,omitempty"`
	Unit                string    `json:"unit"`
	PriceCents          int       `json:"price_cents"`
	CompareAtPriceCents *int      `json:"compare_at_price_cents,omitempty"`
	THCPercent          *float64  `json:"thc_percent,omitempty"`
	CBDPercent          *float64  `json:"cbd_percent,omitempty"`
	HasPromo            bool      `json:"has_promo"`
	VendorStoreID       uuid.UUID `json:"vendor_store_id"`
	CreatedAt           time.Time `json:"created_at"`
	UpdatedAt           time.Time `json:"updated_at"`
	MaxQty              int       `json:"max_qty"`
	ThumbnailURL        *string   `json:"thumbnail_url,omitempty"`
}
```

This ticket is limited to:

* Goose migration creating ONLY the `wishlists` table
* GORM model in `pkg/db/models/wishlist.go` matching the migration
* Proper struct tags and associations


## Scope

### Included

* Goose migration creating `wishlists` table with:

  * `id`
  * `store_id`
  * `created_at`
  * `product`
* Unique index on `store_id`
* FK to `stores(id)` with `ON DELETE CASCADE`
* GORM model in `pkg/db/models/wishlist.go`
* GORM tags matching migration (primary key, indexes, FK)
* Association to Store

### Explicitly NOT Included

* Wishlist items table
* Product relations
* Repositories
* Services
* Controllers
* Routes

## Acceptance Criteria

* [ ] Goose migration creates ONLY `wishlists(id, store_id, created_at)`
* [ ] `store_id` has UNIQUE constraint
* [ ] FK to `stores(id)` exists with `ON DELETE CASCADE`
* [ ] `pkg/db/models/wishlist.go` exists and matches migration shape exactly
* [ ] GORM auto-migrate is NOT relied on
* [ ] Migration runs cleanly locally

## Dependencies

* Blocked by: Stores table already exists
* Blocks: Wishlist repo, service, controller

## Technical Notes

* Files:

  * `migrations/<timestamp>_create_wishlists.sql`
  * `pkg/db/models/wishlist.go`
* Model must include Store association

**ASSUMPTION:** Store model already exists in `pkg/db/models/store.go`.

## Out of Scope

* Wishlist items
* Product joins
* API exposure

---

# Title [PF-276]: Wishlist repository + DTO definitions (store_id + product_id)

**Type:** Feature

**Description:**
Implement repository functions and DTO projections for the store-scoped wishlist backed by the `wishlist_items` table. A wishlist item is one liked product for one store.

**Scope**

**Included**
Create `internal/wishlist/repo.go` implementing:

* `AddItem(storeID, productID) error`
* `RemoveItem(storeID, productID) error`
* `ListItems(storeID, cursor, limit) (WishlistItemsPageDTO, error)`
* `ListItemIDs(storeID) ([]uuid.UUID, error)`
* `CountItems(storeID) (int, error)` *(optional but useful for pagination; remove if you don’t want it)*

Create DTOs in `internal/wishlist/types.go`:

* `WishlistItemDTO` (includes `ProductSummary` projection)
* `WishlistItemsPageDTO` (items + cursor/nextCursor + limit)
* `WishlistIDsDTO` (just `[]uuid.UUID`)

Behavior requirements:

* `ListItems` returns **product summaries** for products in the wishlist for that store.
* The product projection must mirror BrowseProducts summary fields (reuse the same projection function/mapper if it exists).
* `AddItem` must be idempotent at the DB level using unique constraint `(store_id, product_id)`:

  * Use `INSERT ... ON CONFLICT DO NOTHING` (Postgres) or GORM equivalent.
* `RemoveItem` deletes by `(store_id, product_id)`.

**Explicitly NOT Included**

* Store-type validation (buyer/vendor)
* Controllers / routes
* Authorization decisions

**Acceptance Criteria**

* [ ] Repo exposes the required methods using `storeID` + `productID` (no wishlist parent table, no wishlistID)
* [ ] `AddItem` is idempotent (duplicate adds do not error)
* [ ] `RemoveItem` succeeds even if row does not exist (no error)
* [ ] `ListItems` supports cursor + limit pagination
* [ ] `ListItemIDs` returns only product UUIDs for the store
* [ ] DTOs compile and are used by repo return types

**Dependencies**

* Blocked by: PF-275 (wishlist_items migration + model)
* Blocks: PF-277

**Technical Notes**

* Directory: `internal/wishlist/`
* Prefer reusing the BrowseProducts projection/query builder to avoid divergence.
* Cursor pagination: define cursor as `(created_at, id)` or just `id` if ordering is by `created_at DESC, id DESC`.

---

# Title [PF-277]: Wishlist service layer with business rules

**Type:** Feature

**Description:**
Implement `internal/wishlist/service.go` to provide business logic for wishlist operations using store context.

**Scope**

**Included**
Create `internal/wishlist/service.go` implementing:

* `GetWishlist(storeID, cursor, limit) (WishlistItemsPageDTO, error)`
* `GetWishlistIDs(storeID) (WishlistIDsDTO, error)`
* `AddItem(storeID, productID) error`
* `RemoveItem(storeID, productID) error`

Rules:

* Inject wishlist repo + product repo (or product service) + store repo/service (as needed).
* Enforce buyer-only access (store type check).
* Validate product exists before add.
* `AddItem` must be idempotent (service should treat duplicates as success; repo already handles via ON CONFLICT DO NOTHING).
* `RemoveItem` succeeds even if missing.

**Explicitly NOT Included**

* HTTP handlers
* Routes
* Middleware

**Acceptance Criteria**

* [ ] Service compiles and injects required deps
* [ ] Buyer store type enforced
* [ ] Product existence validated prior to add
* [ ] AddItem is idempotent (duplicate add returns nil)
* [ ] RemoveItem returns nil even if item missing
* [ ] Delegates persistence to repo

**Dependencies**

* Blocked by: PF-276
* Blocks: PF-278

**Technical Notes**

* Use existing store-type enum and store lookup method already used elsewhere.
* Do not rely on request context inside service signature; pass `storeID` explicitly (controller extracts from context).

---

# Title [PF-278]: Wishlist controller + routes wiring

**Type:** Feature

**Description:**
Expose store-scoped wishlist operations via authenticated HTTP endpoints under `/api/v1`.

**Endpoints**

* `GET /api/v1/wishlist` (returns wishlist product summaries, paginated)
* `GET /api/v1/wishlist/ids` (returns only product IDs)
* `POST /api/v1/wishlist/items` (adds one product to wishlist)
* `DELETE /api/v1/wishlist/items/{productId}` (removes one product)

**Scope**

**Included**
Create:

* `api/controllers/wishlist_controller.go` (match your existing controller conventions)
* Route mounting in `api/routes/router.go`
* DI wiring: Repo → Service → Controller

Handler behavior:

* Auth required.
* Extract `storeID` from store context middleware (existing pattern).
* Input validation:

  * POST body: `{ "product_id": "<uuid>" }` (recommended)
  * DELETE path param: `{productId}` UUID
* Responses use canonical envelope helper.
* Pagination support on `GET /wishlist` using query params:

  * `cursor` (optional)
  * `limit` (optional; default per your API conventions)

**Explicitly NOT Included**

* Frontend integration
* Rate limiting
* Analytics/notifications

**Acceptance Criteria**

* [ ] All four endpoints reachable under authenticated `/api/v1`
* [ ] POST validates payload and returns success even if already liked
* [ ] GET /wishlist returns paginated product summaries
* [ ] GET /wishlist/ids returns only product IDs
* [ ] DELETE works even if product not present
* [ ] Routes mounted correctly and service injected

**Dependencies**

* Blocked by: PF-277
* Blocks: Frontend wishlist integration

**Technical Notes**

* Idempotency-Key header is **optional** because DB constraint + ON CONFLICT yields idempotency. If you want it for consistency, accept it but don’t require it.
