
# Title [PF-129]: Create/finalize `media_attachments` table and indexes

## Type

Infra

## Description

Introduce/update a canonical `media_attachments` table to normalize how media is linked to domain entities. This table represents **usage**, not ownership, and is required to support safe deletion and multi-entity reuse of media.

## Scope

* Create `media_attachments` table
* Add indexes for entity-based and media-based lookups
* Enforce store scoping via FK or explicit column

**NOT included**

* Domain wiring
* Media deletion logic
* Backfilling existing media relationships

## Acceptance Criteria

* [ ] `media_attachments` table exists with correct columns
* [ ] Index exists for `(entity_type, entity_id)`
* [ ] Index exists for `(media_id)`
* [ ] Table supports multiple rows per `media_id`

## Dependencies

* Blocked by: Existing `media` table
* Blocks: PF-1402, PF-1403, PF-1404, PF-1405, PF-1406, PF-1407

## Technical Notes

* Fields:

  * `id (uuid, pk)`
  * `media_id (uuid, fk → media.id)`
  * `entity_type (enum/text)`
  * `entity_id (uuid)`
  * `store_id (uuid)`
  * `gcs_key (text)`
  * `created_at (timestamptz)`
* FK on `media_id` MUST be `ON DELETE RESTRICT`
* **ASSUMPTION:** `entity_type` is a controlled enum in code, not DB enum (MVP)

## Out of Scope

* Polymorphic ORM helpers
* Cascading deletes

---

# Title [PF-130]: Define media attachment lifecycle and deletion rules

## Type

Chore

## Description

Document and codify the lifecycle rules governing media attachments, including constraints around deletion and protected usage. This serves as the authoritative reference for all domain integrations.

## Scope

* Add code comments near attachment models
* Add markdown documentation describing lifecycle rules
* Explicitly define protected attachment types

**NOT included**

* Runtime enforcement
* UI validation

## Acceptance Criteria

* [ ] Lifecycle rules are documented in-code and in docs
* [ ] Rules clearly define protected vs unprotected attachments
* [ ] Deletion preconditions are unambiguous

## Dependencies

* Blocked by: PF-1401
* Blocks: PF-1403, PF-1404, PF-1405, PF-1406, PF-1407

## Technical Notes

* Explicit rules:

  * One attachment row per usage
  * Media delete allowed only if:

    * zero attachments exist, OR
    * attachments are non-protected
  * License attachments are **always protected**
* **ASSUMPTION:** protection is enforced in service layer, not DB

## Out of Scope

* Automated rule validation
* Migration of legacy behavior

---

Below are **four fully-formed Jira tickets**, written as authoritative, implementation-ready work items.
They strictly follow your template and the corrected canonical document.
No scope is invented beyond what you specified.

---

# Title [PF-131]: Implement canonical Media Attachment reconciliation helper

## Type

Feature

## Description

Build a reusable, canonical helper that reconciles media references on domain entities with their corresponding `media_attachments` rows. This helper is the single approved mechanism for creating and removing attachment rows during domain writes and MUST be used by all media-aware domains.

The MediaAttachment GORM model and Goose migration already exist; this ticket focuses on the helper logic, repositories, and service layer orchestration.

## Scope

* Implement a reusable reconciliation helper/service
* Implement GORM repositories for `media_attachments`
* Support diff-based create/remove logic
* Enforce store scoping and immutability rules
* Require execution inside an existing DB transaction

## Acceptance Criteria

* [ ] Helper accepts `entity_type`, `entity_id`, `store_id`, `old_media_ids[]`, `new_media_ids[]`
* [ ] Helper correctly diffs old vs new media IDs
* [ ] New attachments are created for added media IDs
* [ ] Attachment rows are removed for deleted media IDs
* [ ] Unchanged media IDs result in no DB writes
* [ ] All operations require an active transaction
* [ ] Cross-store attachment creation is rejected
* [ ] Implementation follows the canonical lifecycle document exactly

## Dependencies

* Blocked by: MediaAttachment GORM model and Goose migration (already complete)
* Blocks: Domain integrations (PF-132)

## Technical Notes

* Tables: `media_attachments`
* Services: new shared attachment reconciliation service
* Repos: `MediaAttachmentRepository`
* Must not mutate existing attachment rows
* **ASSUMPTION:** Media records and `gcs_key` already exist and are queryable by `media_id`

## Out of Scope

* Domain-specific business logic
* Media deletion worker logic
* Any database schema changes

---

# Title [PF-132]: Integrate Media Attachment reconciliation into Product and License domains

## Type

Task

## Description

Integrate the canonical Media Attachment reconciliation helper into existing Product and License domain flows. This ensures attachment rows are correctly created and removed during create/update operations and establishes the pattern required for all future media-aware domains.

Only Product and License domains are included in this phase.

## Scope

* Integrate reconciliation helper into:

  * Product create
  * Product update
  * License create
* Ensure reconciliation occurs within the same transaction as domain writes
* Explicitly codify this requirement for future domains

## Acceptance Criteria

* [ ] Product create creates attachment rows for all referenced media
* [ ] Product update diffs and reconciles attachment rows correctly
* [ ] License create creates protected attachment rows
* [ ] Attachment reconciliation runs inside domain DB transactions
* [ ] No orphaned or duplicate attachment rows observed
* [ ] Protected attachment semantics are preserved for licenses

## Dependencies

* Blocked by: PF-131 (Attachment reconciliation helper)
* Blocks: Media deletion enforcement (PF-134)

## Technical Notes

* Domains: `products`, `licenses`
* Entity types:

  * `product`
  * `license`
* Must use canonical helper; no inline attachment logic allowed
* **ASSUMPTION:** Product update endpoints already load previous persisted media IDs

## Out of Scope

* Ad, store, user, or other domain integrations
* Media deletion endpoint logic
* Worker or async processing

---

# Title [PF-133]: Implement dedicated Media Deletion Worker (media-deleted-sub consumer)

## Type

Infra

## Description

Create a dedicated binary worker (`cmd/media-deleted`) that consumes messages from `media-deleted-sub` and performs the recursive detachment and cleanup process for non-protected media attachments.

This worker is responsible for enforcing post-delete cleanup guarantees across domains.

## Scope

* Create standalone binary/worker
* Subscribe to `media-deleted-sub`
* Load all attachments for the deleted media
* Trigger domain-specific detachment for each attachment
* Delete attachment rows after successful detachment

## Acceptance Criteria

* [ ] Worker subscribes to `media-deleted-sub`
* [ ] Worker loads all `media_attachments` for a given media ID
* [ ] Worker iterates through attachments deterministically
* [ ] Domain-specific detachment (removed from the domain entity) is triggered before `media_attachments` row deletion
* [ ] Attachment rows are deleted only after successful detachment
* [ ] Worker is idempotent and safe to retry

## Dependencies

* Blocked by: PF-131 (Attachment repository/helper)
* Blocks: None

## Technical Notes

* Binary: `media-deletion-worker` (name illustrative)
* Queue/Sub: `media-deleted-sub`
* Tables: `media_attachments`
* **ASSUMPTION:** Domain detachment APIs or internal services already exist or will be stubbed initially

## Out of Scope

* Media delete API endpoint logic
* Protected attachment checks
* GCS object deletion logic

---

# Title [PF-134]: Enforce protected attachment checks in Media delete endpoint

## Type

Bug

## Description

Add strict enforcement to the Media delete endpoint to prevent deletion when any active protected attachment exists. This ensures licenses and ads cannot be orphaned or silently detached.

The endpoint must act as a gatekeeper before emitting deletion events.

## Scope

* Load all attachments for the target media
* Check for protected `entity_type` values
* Reject deletion if any protected attachment exists
* Allow deletion only when all attachments are unprotected
* Emit deletion event for downstream worker processing

## Acceptance Criteria

* [ ] Media delete endpoint loads all attachments for media
* [ ] Deletion is rejected if any `license` or `ad` attachment exists
* [ ] Client receives a clear error response when blocked
* [ ] Deletion event is emitted only after passing protection checks
* [ ] No attachment cleanup occurs synchronously in the API

## Dependencies

* Blocked by: PF-201 (Attachment repository)
* Blocks: PF-203 (Worker assumes pre-validated deletes)

## Technical Notes

* API: Media delete endpoint
* Logic must reference `ProtectedAttachmentEntities`
* **ASSUMPTION:** Media delete already emits an outbox or pub/sub event

## Out of Scope

* Actual detachment logic
* Attachment reconciliation
* Worker implementation

---

Here’s a **single, fully-formed Jira ticket** that captures exactly what you described, written for a senior engineer and aligned with your existing architecture and consumer code.

---

# Title [PF-135]: Implement real Media Detachment Handler for GCS deletion events

## Type

Feature

## Description

Implement a **real `detachmentHandler`** used by the `DeletionConsumer` to correctly remove media references from domain entities (products, ads, stores, users, etc.) when a GCS `OBJECT_DELETE` event is received.

Currently, the consumer uses a no-op detacher, which only deletes `media_attachments` rows and does **not** remove the `media_id` references from the owning entities. This can leave dangling references in domain tables (e.g., product galleries, COAs, ad creatives, store logos, avatars).

This ticket introduces a concrete detachment implementation that:

1. Dynamically routes by `EntityType`
2. Loads the owning entity using existing repos/services
3. Removes the media reference from the entity according to its schema
4. Persists the updated entity
5. Deletes the attachment row **in the same DB transaction**


## Scope

### Included

* Implement a concrete `detachmentHandler` using a `switch` on `MediaAttachment.EntityType`
* For each supported entity type:

  * Load the entity by `EntityID`
  * Detect where the media is referenced (single FK or collection)
  * Remove/null the reference if present
  * Persist the entity update
* Use existing repositories/services under `internal/<domain>/*` where available
* Ensure detachment + attachment-row deletion occur in the **same DB transaction**
* Make detachment logic **idempotent** (safe on retries)
* Return errors only for real failures (not “already detached” cases)

### Explicitly NOT Included

* Creating new entity types or new attachment semantics
* Schema migrations
* Backfilling or repairing existing dangling references
* Cross-media cascade deletes beyond the referenced attachment

---

## Acceptance Criteria

* [ ] A concrete `detachmentHandler` implementation replaces the current no-op detacher
* [ ] Handler routes by `attachment.EntityType` using a `switch` statement
* [ ] For each entity type, the owning entity is loaded and updated to remove the media reference
* [ ] Entity updates and `media_attachments` row deletion occur in the same DB transaction
* [ ] Detachment is idempotent (no error if media reference is already missing)
* [ ] Unsupported `EntityType` values fail loudly (error or logged error + nack, per policy)
* [ ] Unit tests or integration tests cover at least one single-FK case and one collection case

---

## Dependencies

### Blocked by

* Existing GCS deletion consumer (`DeletionConsumer`) already merged
* `MediaAttachment` schema finalized

### Blocks

* Reliable media lifecycle cleanup
* Safe reuse of media across entities without dangling references
* Production readiness of GCS deletion consumer

---

## Technical Notes

### Key Files / Locations

* Consumer:

  * `consumer/deletion_consumer.go`
* Interfaces:

  * `detachmentHandler`
* Models (reference discovery):

  * `pkg/db/models/*`
* Domain repos/services (entity loading & updates):

  * `internal/<domain>/*`

### Expected Implementation Shape (Guidance)

* Introduce a concrete detacher, e.g. `AttachmentDetacher`
* Route by `MediaAttachment.EntityType`:

  ```go
  switch attachment.EntityType {
  case "product":
      // remove from gallery / COA fields
  case "ad_creative":
      // null creative media reference
  case "store":
      // remove logo / banner media
  case "user":
      // remove avatar media
  default:
      return fmt.Errorf("unsupported entity type: %s", attachment.EntityType)
  }
  ```
* Use existing domain services/repos to:

  * Load entities (some may require joins to locate media references)
  * Update entities according to their model semantics
* Execute detachment + `media_attachments.Delete(...)` within a single transaction
* Prefer passing `*gorm.DB` through repos/services rather than opening nested transactions

### ASSUMPTIONS

* `MediaAttachment.EntityType` values map cleanly to domain models
* Each domain already has a repository or service capable of loading/updating the entity
* Media references may be either:

  * single FK fields (e.g., `avatar_media_id`)
  * collections (e.g., product galleries)
* Consumer retry semantics rely on idempotent detachment

---

## Out of Scope

* Automatic repair of legacy data
* Deleting the `media` row itself
* Cross-entity cascading deletes
* Changes to Pub/Sub message formats or GCS notifications
