## Title [PF-124]: Add Admin authentication model + role (storeless)

## Type

Feature

## Description

Define how **admin users** authenticate and authorize **without Store context** so they can access `/api/admin/*` routes for license verification, payouts, and other privileged operations.

## Scope

* Add/confirm an **admin role** in `enums.MemberRole` (or dedicated `SystemRole` if you split later)
* Ensure JWT claims can represent an admin session **with no activeStoreId / storeType**
* Ensure middleware + route guards support **storeless admin requests**

## Acceptance Criteria

* [ ] Admin JWTs can be minted/parsed with `ActiveStoreID=nil` and `StoreType=nil` and still pass auth.
* [ ] `RequireRole("admin")` works for admin requests based on JWT role claim.
* [ ] Admin routes do **not** require store context (no 403/500 due to missing store_id).

## Dependencies

* Blocked by: none
* Blocks: Admin login route; Admin user provisioning

## Technical Notes

* Reuse existing JWT machinery if possible:

  * `Auth` middleware already sets `ctxStoreID` only if `claims.ActiveStoreID != nil`.
  * The risky piece is `middleware.StoreContext(logg)` on `/api/admin` routes — this should be removed or made conditional.
* **ASSUMPTION:** `enums.MemberRole` currently does *not* include `"admin"`; if it does, this ticket becomes mostly route/middleware changes.

## Out of Scope

* MFA, email verification, SSO, Cognito/Firebase adapter

---

## Title [PF-XXX]: Implement Admin login endpoint (storeless) + token issuance

## Type

Feature

## Description

Create a dedicated admin login route so a privileged operator can obtain JWT + refresh token and access admin-only APIs.

## Scope

* New route: `POST /api/admin/v1/auth/login`
* Request: `{ "email": string, "password": string }`
* Response: `{ "accessToken": string, "refreshToken": string, "user": <admin user dto> }`
* Use existing password hash verification + session manager (Redis) rotation model

## Acceptance Criteria

* [ ] Valid admin credentials return `200` with `accessToken` and `refreshToken`.
* [ ] Invalid credentials return `401` with the standard invalid credentials message (match existing behavior).
* [ ] Returned JWT has role = `admin` and **does not require** store claims.
* [ ] `last_login_at` is updated for admin user on successful login (same as current login).

## Dependencies

* Blocked by: PF-XXX (Admin role storeless support)
* Blocks: Admin route hardening + integration harness

## Technical Notes

* You can reuse the existing `Login` flow structure with a simplified variant:

  * Lookup user by email
  * Verify password
  * Confirm `user.IsActive`
  * Confirm user is admin via `user.SystemRole == "admin"` (or however you encode it)
  * Mint access token with `ActiveStoreID=nil`, `StoreType=nil`, `Role=admin`
  * Create refresh token with `sessionManager.Generate(ctx, accessID)`
* Consider putting this in `internal/adminauth` (or `internal/auth/admin`) to avoid polluting store login service.
* **ASSUMPTION:** Admin users live in the same `users` table and are distinguished by `SystemRole` (since your current login already supports `SystemRole` override).

## Out of Scope

* Admin registration endpoint (handled separately)
* Refresh endpoint changes (unless you decide admins need separate refresh semantics)

---

## Title [PF-XXX]: Refactor `/api/admin` router to remove StoreContext requirement

## Type

Task

## Description

Your current admin router applies `middleware.StoreContext(logg)` even though admins are not associated with a store. This will likely break requests when `ctxStoreID` is absent.

## Scope

* Update the router setup for `/api/admin`:

  * Keep: `Auth`, `RequireRole("admin")`, `Idempotency`, `RateLimit`
  * Remove (or conditionalize): `StoreContext`
* If any admin endpoints truly need store_id (e.g., acting “as” a store), that should be explicit in payload/path and validated there—not implied via store context middleware.

## Acceptance Criteria

* [ ] `GET /api/admin/ping` works with an admin JWT that has no `active_store_id`.
* [ ] Existing buyer/vendor routes that depend on `StoreContext` remain unchanged.
* [ ] No panics / internal errors when admin JWT has `ActiveStoreID=nil`.

## Dependencies

* Blocked by: PF-XXX (Admin login)
* Blocks: Admin features (license verify, payouts) reliably working

## Technical Notes

* Smallest change: remove `r.Use(middleware.StoreContext(logg))` from the `/api/admin` subtree.
* Alternative: change `StoreContext` middleware to be a no-op if role is admin, but that’s riskier (it changes behavior globally).

  * If you do conditional logic, gate it strictly on `RoleFromContext(ctx) == "admin"`.

## Out of Scope

* Reworking StoreContext implementation everywhere

---

## Title [PF-XXX]: Admin user provisioning (seed + optional CLI/SQL instructions)

## Type

Task

## Description

Admins need a way to exist in the database. For MVP, support **manual creation** (psql) and/or a **seed migration** for the first admin user.

## Scope

* Option A (preferred MVP): Goose migration to insert an initial admin user (email + password hash pulled from env at deploy-time is tricky; so either insert a disabled user and manually set password, or document manual insert).
* Option B: `make admin-create` CLI command (Go) that:

  * takes email + password from env/args
  * hashes password using existing `security` helper
  * inserts user with `system_role="admin"` and `is_active=true`

## Acceptance Criteria

* [ ] There is a documented, repeatable way to create an admin user in dev/stage.
* [ ] Admin user has `SystemRole=admin`, a valid `PasswordHash`, and `IsActive=true`.
* [ ] Admin user can login via the new endpoint and hit `/api/admin/ping`.

## Dependencies

* Blocked by: none
* Blocks: Admin login testing in non-local environments

## Technical Notes

* Manual psql instructions should include:

  * inserting into `users` with normalized lowercase email
  * setting `password_hash` using the same hashing function (so CLI is safer than raw SQL)
* **ASSUMPTION:** You already have a password hashing utility (`security.HashPassword(...)` or equivalent; you’re using `security.VerifyPassword(...)` now).

## Out of Scope

* Full admin registration API exposed publicly
* Invite emails / SendGrid integration

---

## Title [PF-XXX]: Integration tests for admin auth + protected admin routes (happy + unhappy paths)

## Type

Task

## Description

Add coverage that proves admin auth is storeless and that protected admin endpoints enforce role-based access.

## Scope

* Tests (API-level):

  * Admin login success
  * Admin login failure (bad password)
  * Access `/api/admin/ping`:

    * succeeds with admin token
    * fails with buyer/vendor token (403)
    * fails with no token (401)

## Acceptance Criteria

* [ ] CI-friendly scripted run can authenticate as admin and call `GET /api/admin/ping`.
* [ ] Non-admin tokens cannot call admin endpoints (`403 role required`).
* [ ] Missing/invalid token returns `401`.

## Dependencies

* Blocked by: Admin login + provisioning + router refactor tickets
* Blocks: Confident rollout of admin-only features (license verify, payouts)

## Technical Notes

* Fits naturally into your Phase 13 integration harness (`/scripts/integration/`) using real HTTP calls.
* Use env vars like:

  * `ADMIN_EMAIL`, `ADMIN_PASSWORD`, `API_BASE_URL`

## Out of Scope

* Deep license verify workflow tests (that’s a separate “admin licenses” ticket set)
