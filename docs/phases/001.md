## [PF-101]: Implement `users` model + Argon2id password hashing

## Type

Task

## Description

Implement the canonical `users` identity model and secure password handling for PackFinderz. Passwords MUST be hashed using Argon2id per Security + Ops. The `users` table MUST be created via Goose SQL migration and mapped via a GORM model in the DB models folder.

## Scope

* Implement Goose migration to create `users` table (per Data Design `users`)
* Implement GORM model for `users` in the DB models folder
* Implement password hashing + verification utilities using Argon2id
* Add minimal unit tests for hashing/verify behavior (no DB required)

## Acceptance Criteria

* [ ] Goose migration creates `users` with: `id`, `email` (unique), `password_hash`, `first_name`, `last_name`, `phone` (nullable), `is_active`, `last_login_at` (nullable), `system_role` (nullable), `created_at`, `updated_at`
* [ ] Argon2id hashing and verification functions exist and pass tests (correct password verifies; wrong password fails)
* [ ] No plaintext passwords or password hashes are logged

## Dependencies

* Blocked by: Phase 0 infra (DB bootstrap + Goose runner)
* Blocks: login, register, store membership, JWT minting

## Technical Notes

* Tables: `users`
* Password hashing: Argon2id required (Security + Ops)
* **ASSUMPTION:** Argon2id parameters come from env/config with safe defaults in dev; prod must be configurable
* Model location: DB models folder (per your instruction)

## Out of Scope

* Email verification / MFA
* User profile update endpoints
* Admin password reset flow

---

## [PF-021]: Implement `stores` model with `StoreType` (buyer/vendor) and address shape

## Type

Task

## Description

Implement the canonical `stores` tenant model (LOCKED) including `store.type = buyer|vendor`, KYC status, subscription gating fields, and address/geo fields required for future PostGIS filtering. Create the `stores` table via Goose migration and map it with a GORM model. Define `StoreType` as a global enum/type in `pkg/enums` (or equivalent global location per Phase 0 standards).

## Scope

* Goose migration to create required Postgres enums used by `stores` (at minimum `store_type`, `kyc_status`) if not already created
* Goose migration to create `stores` table (per Data Design `stores`)
* GORM model for `stores` in DB models folder
* Global enum/type definition for `StoreType` in `pkg/enums` (shared)
* Minimal validation helpers for `StoreType` conversion/parsing (optional but recommended)

## Acceptance Criteria

* [ ] Goose migration creates `stores` with fields matching data design: `id`, `type`, `company_name`, `dba_name`, `description`, `phone`, `email`, `kyc_status`, `subscription_active`, `delivery_radius_meters`, `address` (composite), `geom` (geography point), `social` (optional), timestamps
* [ ] `StoreType` is defined in global enums/types (not API-only) and used by the model and future JWT claims
* [ ] Store model supports buyer/vendor typing consistent with tenancy rules (vendor has buyer privileges later; buyer never vendor)

## Dependencies

* Blocked by: Phase 0 DB + Goose runner; base extensions (pgcrypto/postgis) if required for `geom` / UUID defaults
* Blocks: store membership, registration, store switching, tenancy middleware

## Technical Notes

* Tables: `stores`
* Postgres types: `store_type`, `kyc_status`, composite `address_t` and `social_t`, `geom geography(Point,4326)`
* **ASSUMPTION:** If composite types are not yet created in migrations, this ticket will create them (or store address as JSONB temporarily ONLY if composite types are blocked; must be flagged)
* Ensure address immutability is enforced at API layer per policy (DB-level lock not required in this ticket)

## Out of Scope

* Vendor directory search queries (PostGIS usage)
* Store update endpoints
* Subscription activation logic

---

## [PF-103]: Implement `store_memberships` model and role enum

## Type

Task

## Description

Implement multi-store membership join model between `users` and `stores` to support store switching and RBAC. Create `store_memberships` via Goose migration and map via GORM model. Define `member_role` as a global enum/type in `pkg/enums` (shared across auth, RBAC, controllers-- if not already created).

## Scope

* Goose migration to create Postgres enum `member_role` (per Data Design-- If not already created)
* Goose migration to create `store_memberships` table with unique `(store_id, user_id)`
* GORM model for `store_memberships` in DB models folder
* Global role enum/type in `pkg/enums`
* Helper functions for common membership queries (repo-level skeleton is okay; full repos can come later)

## Acceptance Criteria

* [ ] Goose migration creates `store_memberships` with: `id`, `store_id` FK, `user_id` FK, `role`, `created_at`, and unique index `(store_id, user_id)`
* [ ] Global role enum/type exists and is referenced in membership and JWT claims mapping
* [ ] A user can belong to multiple stores (enforced by data model); membership uniqueness prevents duplicates per store

## Dependencies

* Blocked by: [PF-101], [PF-102]
* Blocks: registration flow (create owner membership), store switching, RBAC enforcement

## Technical Notes

* Tables: `store_memberships`
* Postgres types: `member_role`
* **ASSUMPTION:** We will use the roles listed in Data Design (`owner, admin, sales_rep, viewer, driver, compliance, finance`) as the canonical set for DB enum even if API contract also mentions `manager/staff/ops`—any mismatch should be resolved in a later “role alignment” ticket.

## Out of Scope

* User invite endpoint
* Permission overrides array (`permissions[]`) (future)
* Admin/agent “system roles” beyond `users.system_role`

---

## Title (number 0-N) => [PF-104]

Implement JWT minting + parsing with `activeStoreId` claims

## Type

Task

## Description

Implement JWT issuance and verification to support multi-store tenancy enforcement. Tokens MUST include `userId`, `activeStoreId`, and role, and be minted with a TTL. Parsing must validate signature + expiry and return typed claims for middleware use. You noted basic implementation exists—this ticket refactors and expands it to the canonical claim set.

## Scope

* JWT claim struct + minting function with configured TTL
* JWT parsing/verification that returns typed claims
* Support `activeStoreId` presence for store-scoped endpoints (agents/admins may omit store context; handled in middleware ticket)
* Unit tests for mint + parse + expiry behavior

## Acceptance Criteria

* [ ] Access JWT includes at minimum: `user_id`, `active_store_id` (nullable only for system users), `role`, `store_type` (optional convenience), `iat`, `exp`
* [ ] Token parsing rejects invalid signature and expired tokens
* [ ] Claims are returned in a typed struct used by HTTP middleware (not map[string]any)
* [ ] No JWTs are logged (Security redline)

## Dependencies

* Blocked by: config (JWT signing key), [PF-101], [PF-103] (for role mapping decisions)
* Blocks: auth endpoints, store-scoped auth middleware, store switching

## Technical Notes

* JWT claims per Master Context + Security + Ops
* TTL: short-lived access token (Security doc suggests <=15m; confirm via config)
* **ASSUMPTION:** Signing algorithm is HMAC (HS256) for MVP; rotation strategy later
* **ASSUMPTION:** `store_type` may be derived at request-time if not embedded; include only if readily available during mint

## Out of Scope

* Refresh token logic (separate ticket)
* Allowlist/denylist access token revocation
* Email verification / MFA

---

## [PF-105]: Implement refresh token storage + rotation (Redis-backed)

## Type

Task

## Description

Implement refresh token issuance, storage, and rotation to support session continuity and store switching without re-login. Refresh tokens MUST be rotated when exchanging for a new access token (and per your rule: new refresh token generated when JWT expires and refresh is used). Store refresh tokens in Redis such that the JWT (or access token identifier) is the key and the refresh token string is the value, with TTL slightly beyond access expiry.

## Scope

* Refresh token generation (opaque random string recommended)
* Redis storage scheme: key = access token identifier; value = refresh token; TTL > access TTL
* Rotation on refresh: validate provided refresh token, mint new access token + new refresh, store new mapping, invalidate old mapping
* Helper functions in `pkg/redis` (or `pkg/auth/session` if you split later, but still under `pkg/redis` per your preference)
* Unit tests for generation/rotation logic (Redis may be mocked)

## Acceptance Criteria

* [ ] Refresh token is opaque, non-guessable, and never logged
* [ ] Refresh token exchange rotates token (old refresh becomes invalid)
* [ ] Redis key TTL outlives access token TTL (configurable)
* [ ] Invalid/expired refresh token returns 401-equivalent domain error (actual HTTP mapping handled by envelope ticket)

## Dependencies

* Blocked by: Redis bootstrap, JWT minting ([PF-104])
* Blocks: refresh endpoint, logout endpoint

## Technical Notes

* Redis: store session keys with namespacing (e.g., `sess:<access_jti>` or `sess:<token_hash>`)
* **ASSUMPTION:** Access tokens include a stable identifier (e.g., `jti`) or we derive a hash of token bytes to use as Redis key; choose one and document
* Security redlines: never log refresh tokens
* Rotation semantics per your instruction: “rotated on every time the active JWT expires”

## Out of Scope

* Multi-device session management UI
* Persistent refresh tokens in Postgres
* Sliding session policies beyond TTL config

---

## [PF-106]: Implement `POST /api/v1/auth/login` endpoint (email + password)

## Type

Feature

## Description

Implement the login endpoint to authenticate a user via email/password, issue access + refresh tokens, and return store memberships for store selection. Behavior must follow Domain Model rules: if user has exactly 1 store membership, auto-set `activeStoreId` and return tokens ready for use; if multiple stores, return stores list and issue a token that is either missing `activeStoreId` or has a default but must reject store-scoped endpoints until switching (per Master Context assumptions).

FLOW:

1) Login (verified user from Users) > One one store linked (fetches stores associates from store_membership table) > set default `activeStoreId` & return token with claims, User DTO (which joins from the store membership and associated store)
2) Login (verified user from Users) > More than one store linked (fetches stores associates from store_membership table) > Select store from list > set  `activeStoreId` from selected store & return token with claims, User DTO (which joins from the store membership and associated store)

## Scope

* Controller + route for `POST /api/v1/auth/login`
* Validate request body (email/password)
* Lookup user by email; verify password hash
* Fetch store memberships for user
* Token issuance behavior:

  * 1 store: include `activeStoreId`
  * > 1 store: return `stores[]` and token behavior per assumption (documented)
* Store refresh token mapping in Redis

## Acceptance Criteria

* [ ] Valid credentials return 200 with access token, refresh token, and stores list
* [ ] Invalid credentials return 401 with standard error envelope code (mapping handled via response helpers)
* [ ] If user has one store: token includes `activeStoreId`
* [ ] If user has multiple stores: response includes `stores[]` for switching; store-scoped requests fail until active store selected (enforced by middleware ticket)

Where `stores[]` is an array of structs with store name, logo, and the store id to visually see the stores to choose from via UI (out of scope) 

## Dependencies

* Blocked by: [PF-101], [PF-103], [PF-104], [PF-105], API routing/middleware foundation (Phase 0)
* Blocks: frontend auth integration, protected endpoints

## Technical Notes

* Endpoint: `POST /api/v1/auth/login`
* **ASSUMPTION:** “stores[]” response includes storeId + name (company/DBA) + store type + logo (optional)
* Update `users.last_login_at`
* Ensure logs include request_id but not sensitive fields

## Out of Scope

* Account verification emails
* MFA
* Brute force prevention (separate rate limit ticket)

---

## [PF-026]: Implement `POST /api/v1/auth/register` endpoint (user + first store + owner membership)

## Type

Feature

## Description

Implement registration to create a new user, create their first Store (buyer or vendor), and create an owner membership, all in a single DB transaction. Registration is idempotent per API contract and should enforce uniqueness on email. For now, users can login without verification (verification is future).

## Scope

* Controller + route for `POST /api/v1/auth/register`
* Validate request body including required fields:

  * first_name, last_name, phone (optional per user model), email, password
  * company legal name, DBA name (optional), store type (buyer|vendor)
  * address object (per global address type)
  * accept T&C boolean
* Create user (hashed password), store, and owner membership in one transaction
* Issue access + refresh tokens after creation
* Idempotency support required (handled by idempotency middleware ticket, but endpoint must be compatible)

## Acceptance Criteria

* [ ] Successful register returns 201 and includes tokens + created store summary
* [ ] User is created with Argon2id password hash (no plaintext stored)
* [ ] Store + membership created and user is owner of that store

## Dependencies

* Blocked by: [PF-101], [PF-102], [PF-103], [PF-104], [PF-105], idempotency middleware (or temporary inline enforcement if middleware not ready)
* Blocks: onboarding flows, license upload, store switching UX

## Technical Notes

* Endpoint: `POST /api/v1/auth/register` (Idempotent: YES)
* Transactionality required (user/store/membership)
* **ASSUMPTION:** Address geocoding may not be implemented in this phase; store `address.lat/lng` must be provided by client for now, or set to 0 and updated later by admin override (must be explicitly chosen in implementation)
* T&C acceptance not stored. Must be true to create store or reject with error code. 

## Out of Scope

* License upload/verification
* Email verification / SendGrid
* Invite-user registration flows

---

## Title (number 0-N) => [PF-108]

Implement logout + refresh endpoints (`POST /auth/logout`, `POST /auth/refresh`)

## Type

Feature

## Description

Implement session endpoints to (a) revoke refresh token on logout and (b) exchange refresh token for a new access token + rotated refresh token. This is required for secure session management and store switching UX.

## Scope

* `POST /api/v1/auth/logout`: revoke current refresh token mapping
* `POST /api/v1/auth/refresh`: validate refresh token, mint new access JWT, rotate refresh token, update Redis
* Request validation + standardized responses
* Ensure endpoints are compatible with idempotency rules (refresh is not listed as idempotent; logout is not explicitly idempotent, but should be safe on repeated calls)

## Acceptance Criteria

* [ ] Logout removes refresh mapping; subsequent refresh attempts fail with 401
* [ ] Refresh exchanges a valid refresh for new access + new refresh (rotation)
* [ ] Invalid refresh returns 401 with consistent error code
* [ ] No tokens are logged

## Dependencies

* Blocked by: [PF-104], [PF-105]
* Blocks: long-lived sessions, store switching without relogin

## Technical Notes

* Endpoints: `POST /api/v1/auth/logout`, `POST /api/v1/auth/refresh`
* **ASSUMPTION:** logout identifies the session via presented refresh token (body) or Authorization bearer token + refresh in cookie/header; choose one and document
* Follow logging redlines

## Out of Scope

* Access-token denylist
* Session introspection endpoints (list sessions)

---

## Title (number 0-N) => [PF-109]

Implement `POST /api/v1/auth/switch-store` endpoint (mint JWT with new `activeStoreId`)

## Type

Feature

## Description

Implement store switching to support multi-store users. Endpoint must verify the user is a member of the requested store and mint a new access token with `activeStoreId` set. Frontend will use returned store list context (store id + name) and call switch when user selects a store.

## Scope

* Controller + route for `POST /api/v1/auth/switch-store`
* Validate request body: `storeId`
* Verify membership exists for `(userId, storeId)`; fetch role and store type
* Mint new access JWT with `activeStoreId=storeId`
* Optionally rotate refresh token (recommended) or keep same refresh session (documented)

## Acceptance Criteria

* [ ] Switching to a store the user belongs to returns 200 with a new access token containing `activeStoreId`
* [ ] Switching to a store without membership returns 403
* [ ] Store-scoped middleware recognizes the new `activeStoreId` on subsequent calls

## Dependencies

* Blocked by: [PF-103], [PF-104], auth middleware (to identify userId), API scaffolding
* Blocks: multi-store UX, vendor-as-buyer switching

## Technical Notes

* Endpoint: `POST /api/v1/auth/switch-store`
* **ASSUMPTION:** Refresh token rotation on switch-store is optional; for MVP, keep refresh token as-is unless you want strict per-store sessions (decide during implementation and document)
* Must not “logout old store” explicitly; switching is token refresh only

## Out of Scope

* UI store list endpoint (already exists as `GET /stores/my`, implemented later)
* Membership invitation flows

---

## Title (number 0-N) => [PF-110]

Enforce store-scoped auth middleware (tenancy enforcement via `activeStoreId`)

## Type

Task

## Description

Implement store-scoped authentication middleware that enforces tenancy boundaries using `activeStoreId` in JWT. Most endpoints MUST require store context; only specific route groups are exempt (health, auth public endpoints). Must support system users (agent/admin) that may operate without `activeStoreId` per Master Context.

## Scope

* Middleware to:

  * parse/validate JWT
  * attach claims to request context
  * enforce presence of `activeStoreId` for store-scoped route groups
* Route-group based application:

  * `/api/v1/public/*` no auth
  * `/api/v1/private/*` requires auth + `activeStoreId`
  * `/api/v1/admin/*` requires admin role (store context optional)
  * `/api/v1/agent/*` requires agent role (store context optional)
* Standardized rejection errors (401/403) using response envelope helpers

## Acceptance Criteria

* [ ] Protected endpoints reject missing/invalid JWT with 401
* [ ] Store-scoped endpoints reject missing `activeStoreId` with 403 (or 401 if preferred) and explicit error code
* [ ] Admin/agent endpoints allow missing `activeStoreId` but still require valid JWT + correct system role
* [ ] Middleware does not trust client-provided store identifiers in body/query for tenancy checks

## Dependencies

* Blocked by: [PF-104], HTTP routing/middleware stack (Phase 0)
* Blocks: all protected business endpoints

## Technical Notes

* Tenancy enforcement rules from Master Context (Store is canonical tenant)
* **ASSUMPTION:** Middleware uses context keys and a small helper API (e.g., `auth.FromContext(ctx)`)
* Ensure logging includes request_id and user_id/store_id where available

## Out of Scope

* Fine-grained per-action permissions (separate RBAC ticket)
* Order “perspective” authorization (buyerStoreId vs vendorStoreId) (later domain ticket)

---

## Title (number 0-N) => [PF-111]

Enforce RBAC permission resolution server-side

## Type

Task

## Description

Implement RBAC that resolves effective permissions on the server from the user’s store membership role (and system role for admin/agent). This ensures correct authorization regardless of client claims. The token may carry role, but the server must be able to validate/resolve permissions to avoid privilege escalation.

## Scope

* Define role → permissions mapping (server-side)
* Implement permission checking helpers usable by controllers/middleware
* Middleware or guard helpers for:

  * store member roles (owner/admin/etc.)
  * system roles (agent/admin)
* Minimal integration in at least one protected route group to prove wiring (e.g., admin group)

## Acceptance Criteria

* [ ] RBAC mapping exists centrally and is referenced by middleware/guards (no scattered role checks)
* [ ] Requests lacking required permission return 403 with standard error envelope
* [ ] Admin and Agent roles are enforced for `/api/v1/admin/*` and `/api/v1/agent/*` routes respectively

## Dependencies

* Blocked by: [PF-103], [PF-110]
* Blocks: secure implementation of store/user management, orders, payouts, agent actions

## Technical Notes

* Source roles: `member_role` (DB) + `users.system_role`
* **ASSUMPTION:** Permission overrides array on membership is deferred (future); MVP uses role-only mapping
* If role is included in JWT, still validate membership exists at request-time for sensitive actions (may be added later)

## Out of Scope

* Per-store custom permission overrides
* Admin UI permission management

---

## Title (number 0-N) => [PF-112]

Add Redis-backed idempotency middleware (Idempotency-Key contract)

## Type

Task

## Description

Implement the Redis-backed Idempotency-Key middleware per the API contract. Endpoints marked “Idempotent: YES” MUST require the header, and replays MUST return the stored response exactly. The idempotency scope MUST include `(userId, activeStoreId, method, path, idempotencyKey)` and store status code + response body + minimal headers.

## Scope

* Middleware that:

  * requires `Idempotency-Key` for configured routes
  * computes scope key from request context + route
  * stores response (status + body + content-type) on first success
  * returns stored response on replay
  * detects key reuse with different request body hash and returns `409 IDEMPOTENCY_KEY_REUSED` (per contract assumption)
* TTL handling:

  * default 24h
  * 7d for critical endpoints (checkout/payment/order decision flows)
* Redis key namespacing + helper functions in `pkg/redis`

## Acceptance Criteria

* [ ] Requests missing `Idempotency-Key` on configured endpoints return 400 with canonical error code
* [ ] Replaying same key+scope returns identical HTTP status and body bytes
* [ ] Reusing key with different request body returns 409 with `IDEMPOTENCY_KEY_REUSED`
* [ ] TTL differs for 24h vs 7d endpoint groups

## Dependencies

* Blocked by: Redis bootstrap, [PF-110] (needs userId/storeId context)
* Blocks: safe register/invite/license/media/checkout/order actions

## Technical Notes

* Must support agent/admin endpoints where `activeStoreId` may be null (contract specifies null)
* Store response headers at minimum `Content-Type`
* **ASSUMPTION:** For streaming responses, idempotency is not supported (all idempotent endpoints here are JSON)

## Out of Scope

* Distributed locks for non-idempotent endpoints
* Exactly-once semantics beyond replay storage

---

## Title (number 0-N) => [PF-113]

Add Redis-backed auth rate limiting (login brute force protection)

## Type

Task

## Description

Add rate limiting to authentication endpoints to mitigate brute-force and credential stuffing attacks. Must enforce limits per IP and per account identifier (email), using Redis counters with TTL.

## Scope

* Rate limit middleware applied to:

  * `POST /api/v1/auth/login`
  * optionally `POST /api/v1/auth/register` (recommended)
* Counters:

  * per-IP attempts (windowed)
  * per-email attempts (windowed)
* Configurable thresholds and windows via env/config
* Standard error response `429` with canonical code

## Acceptance Criteria

* [ ] Excess login attempts from an IP are blocked with 429 until window resets
* [ ] Excess login attempts for an email are blocked with 429 until window resets
* [ ] Rate limiting uses Redis TTL counters and is safe under concurrency
* [ ] Logs record rate limit events without logging credentials

## Dependencies

* Blocked by: Redis bootstrap, HTTP middleware stack (Phase 0)
* Blocks: production-safe auth rollout

## Technical Notes

* Redis keys: `rl:ip:<ip>`, `rl:email:<hash(email)>` (avoid logging raw email in keys)
* **ASSUMPTION:** Use fixed-window or sliding-window approximation; fixed-window is acceptable for MVP
* Ensure email is normalized (lowercase/trim) before hashing

## Out of Scope

* CAPTCHA challenges
* Global WAF / bot detection
* Anti-scraping protections
