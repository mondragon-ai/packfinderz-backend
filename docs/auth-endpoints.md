# Auth Endpoint cURL snippets

Use `{{API_BASE_URL}}` to point at your environment (e.g., `https://api.packfinderz.com`). Every request/response is JSON and the API mirrors the `errors` package response format (status, code, message, data). On success the server also sets `X-PF-Token` to the freshest access token for login, register, refresh, and switch-store flows.

## Shared headers
- `Content-Type: application/json`
- `Accept: application/json`
- Optional `Idempotency-Key` (useful for `POST /auth/login` and `/auth/register` so you can safely retry the same payload from Postman without creating duplicate logins).
- `Authorization: Bearer {{access_token}}` where required.

## POST /api/v1/auth/login
Logs an existing user in and returns tokens, the user record, and their stores. Returns HTTP 401 when credentials are wrong.

### Request body
```json
{
  "email": "owner@example.com",
  "password": "Secur3P@ssw0rd!"
}
```

### cURL (copy into Postman > Raw):
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/login" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Idempotency-Key: {{optional_idempotency_key}}" \
  -d '{
    "email": "owner@example.com",
    "password": "Secur3P@ssw0rd!"
  }'
```

On success you will see the JSON payload and the `X-PF-Token` header containing the access token that expires according to `pkg/config.JWTConfig`.

## POST /api/v1/auth/register
Creates the initial user/store/membership bundle for a new company. `accept_tos` **must** be `true`. Choose `store_type` from `buyer` or `vendor`.

### Request body (required + optional fields)
```json
{
  "first_name": "Jamie",
  "last_name": "Rivera",
  "email": "jamie@example.com",
  "password": "Secur3P@ssw0rd!",
  "company_name": "Rivera Grocers",
  "store_type": "vendor",
  "address": {
    "line1": "123 Main St",
    "city": "Seattle",
    "state": "WA",
    "postal_code": "98101",
    "country": "US",
    "lat": 47.608,
    "lng": -122.335
  },
  "accept_tos": true
}
```

Optional fields you can add to the same payload:
- `phone` (string)
- `dba_name` (string)
- `address.line2` (string)
- `address.geo_hash` (string generated by your front end if you already calculate it)

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/register" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Idempotency-Key: {{optional_idempotency_key}}" \
  -d '{
    "first_name": "Jamie",
    "last_name": "Rivera",
    "email": "jamie@example.com",
    "password": "Secur3P@ssw0rd!",
    "phone": "+1-206-555-0100",
    "company_name": "Rivera Grocers",
    "dba_name": "Rivera Fresh",
    "store_type": "vendor",
    "address": {
      "line1": "123 Main St",
      "line2": "Suite 400",
      "city": "Seattle",
      "state": "WA",
      "postal_code": "98101",
      "country": "US",
      "lat": 47.608,
      "lng": -122.335,
      "geo_hash": "dp7e2k"
    },
    "accept_tos": true
  }'
```

Upon success the response mirrors login (tokens + user + stores) and sets `X-PF-Token` to the new access token.

## POST /api/v1/auth/refresh
Rotates the refresh token for a new access token. Send the expired access token in `Authorization` and the refresh token in the JSON body. The old refresh token is invalidated.

### Request body
```json
{
  "refresh_token": "{{refresh_token}}"
}
```

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/refresh" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{prev_access_token}}" \
  -d '{
    "refresh_token": "{{refresh_token_token}}"
  }'
```

Success response includes the new `access_token`, `refresh_token`, and updates the `X-PF-Token` header with the freshly minted access token.

## POST /api/v1/auth/logout
Revokes the refresh token tied to the bearer access token. No body payload is required.

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/logout" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

A successful logout returns `{"status":"logged_out"}`.

## POST /api/v1/auth/switch-store
Used when a user belongs to multiple stores and wants to target a different one. Provide the new store UUID, current refresh token, and the access token in `Authorization`. The request is validated against active memberships.

### Request body
```json
{
  "store_id": "{{new_store_id}}",
  "refresh_token": "{{refresh_token}}"
}
```

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/switch-store" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{
    "store_id": "{{new_store_id}}",
    "refresh_token": "{{refresh_token}}"
  }'
```

Success returns new `access_token`, `refresh_token`, and the target store summary, plus `X-PF-Token` contains the new access token. If the membership is inactive or missing, expect HTTP 403.

## Media endpoints
All `/api/v1/media` paths require an authenticated user with an active store context (the same token you used for products/orders), so include `Authorization: Bearer {{access_token}}`. The store is derived from the session, meaning you do not send a `store_id` inside these payloads. Optional filters and headers are listed per endpoint.

### POST /api/v1/media/presign
Creates a media record, enforces `kind`/`mime_type` pairing, and returns a signed PUT URL that expires after 20 minutes (`uploadTTL`). Allowed `media_kind` values: `product`, `ads`, `pdf`, `license_doc`, `coa`, `manifest`, `user`, and `other`. The service caps uploads at 20 MB (`size_bytes ≤ 20,971,520`) and rejects mime types that are not allowed for the chosen kind (see `mimeTypesByKind` in `internal/media/service.go`).

#### Request body
```json
{
  "media_kind": "product",
  "mime_type": "image/png",
  "file_name": "fresh-cut-spinach.png",
  "size_bytes": 124518
}
```

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/media/presign" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{
    "media_kind": "product",
    "mime_type": "image/png",
    "file_name": "fresh-cut-spinach.png",
    "size_bytes": 124518
  }'
```

Return includes `media_id`, `gcs_key`, `signed_put_url`, `content_type`, and `expires_at`. Use the `signed_put_url` (valid until the `expires_at` timestamp, here `2026-01-29T17:23:06.708391-03:00`) to upload the asset directly to GCS. In Postman:

1. Switch to the **PUT** method and paste `signed_put_url` into the URL field.
2. Add `Content-Type: image/png` (matching `content_type` from the response).
3. In **Body → binary**, select the file to upload.
4. Execute the request—GCS returns 200/201 on success and the media row transitions from `pending` to `uploaded`.

If the upload fails, the server leaves the row in `pending`, so you can retry the PUT without re-presigning (reuse the same `media_id`/URL) until you get a success.

### PUT {GCS PRE SIGNED URL}

#### cURL
```bash
curl -i -X PUT \
  -H "Content-Type: image/png" \
  --upload-file "/Users/angelmondragon/Documents/Dev/GPT_Summary/fresh-cut-spinach.png" \
  "NEW_SIGNED_URL"
```


### GET /api/v1/media
Fetches paginated metadata for the store’s media uploads. The JSON response includes `items` (each with `signed_url` populated only when the status is `uploaded` or `ready`) plus a `cursor` for the next page. Default `limit` is 25, capped at 100; omit the query to use the default.

#### Supported query parameters
- `limit` (integer greater than zero, max 100) – override the number of items per page.
- `cursor` (string) – paste the `cursor` value from the previous response to continue.
- `kind` – filter by `media_kind` (same list as above).
- `status` – filter by `media_status` (`pending`, `uploaded`, `processing`, `ready`, `failed`, `delete_requested`, `deleted`, `delete_failed`).
- `mime_type` – filter by the recorded Content-Type string (exact match).
- `search` – compares the file name and GCS key for partial matches.

#### cURL (example with filters)
```bash
curl -G "{{API_BASE_URL}}/api/v1/media" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  --data-urlencode "limit=50" \
  --data-urlencode "kind=product" \
  --data-urlencode "status=uploaded" \
  --data-urlencode "mime_type=image/png" \
  --data-urlencode "search=spinach"
```

Keep the `cursor` value returned alongside `items` to fetch the next page. Each item contains `id`, `kind`, `status`, timestamps, and `signed_url` when available.

### DELETE /api/v1/media/{mediaId}
Deletes the media row for the active store if the asset is in a deletable status (`uploaded` or `ready`). The route returns HTTP 204 on success. Provide a valid UUID.

#### cURL
```bash
curl -X DELETE "{{API_BASE_URL}}/api/v1/media/{{media_id}}" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

If the media row was already marked deleted or belongs to a different store, the endpoint silently succeeds or returns HTTP 403/404 accordingly.

## Cart & Checkout endpoints

Cart-related routes live inside the authenticated store context, so every request requires `Authorization: Bearer {{access_token}}` and, for mutating routes (`PUT /api/v1/cart` and `POST /api/v1/checkout`), an `Idempotency-Key` header with a store-scoped unique value. These headers are enforced by the idempotency middleware (missing keys return HTTP 400/422).

### GET /api/v1/cart
Returns the buyer store's active cart snapshot (if one exists). `items` lists the ordered lines, `cart_level_discount` carries applied promotions, and the totals (`subtotal_cents`, `fees`, `total_discount`, `total_cents`) mirror the values you previously submitted via `PUT /api/v1/cart`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/cart" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

### PUT /api/v1/cart
Creates or replaces the buyer store's active cart. The payload must include `subtotal_cents`, `total_cents`, `total_discount`, and the `items` array; everything else is optional (but recommended when available). The response returns the persisted cart record, so you can immediately render totals, timestamps, and status.

#### Request body (required + optional fields)
```json
{
  "session_id": "bf05-4512-9c9f",
  "shipping_address": {
    "line1": "1501 Pike Pl",
    "line2": "Pier 52",
    "city": "Seattle",
    "state": "WA",
    "postal_code": "98101",
    "country": "US",
    "lat": 47.610,
    "lng": -122.339,
    "geohash": "c22yzv"
  },
  "total_discount": 200,
  "fees": 50,
  "subtotal_cents": 12000,
  "total_cents": 11850,
  "cart_level_discount": [
    {
      "type": "loyalty",
      "title": "Loyalty bundle",
      "id": "23f9d3d6-12b3-4f5e-92fa-1f0f545f733e",
      "value": "2.00",
      "value_type": "flat",
      "vendor_id": "7efe5c43-aa7f-4adf-a448-98bb7c6c3fef"
    }
  ],
  "items": [
    {
      "product_id": "d3f7e10b-3f91-4f3f-92f6-df0452a1f5f5",
      "vendor_store_id": "8a4e0a8f-5a10-4de1-94da-21a1c4d4e0b1",
      "qty": 2,
      "product_sku": "SPINACH-4OZ",
      "unit": "case",
      "unit_price_cents": 6500,
      "compare_at_unit_price_cents": 7000,
      "applied_volume_tier_min_qty": 3,
      "applied_volume_tier_unit_price_cents": 6200,
      "discounted_price": 6200,
      "sub_total_price": 12400,
      "featured_image": "https://cdn.packfinderz.com/products/spinach.png",
      "thc_percent": 0,
      "cbd_percent": 0
    }
  ]
}
```

##### Payload field notes
- `session_id`: optional string stored with the cart so you can tie it back to a session.
- `shipping_address`: optional object; when present, `line1`, `city`, `state`, `postal_code`, `country`, `lat`, and `lng` must be provided. `line2` and `geohash` remain optional.
- `total_discount`, `subtotal_cents`, `total_cents`: integers that must be provided for accuracy. `fees` defaults to `0` when omitted.
- `cart_level_discount`: optional list of objects; each requires `title`, `id`, `value`, `value_type`, and `vendor_id`. `type` is nullable/optional.
- `items`: required array of cart items. Each item must include `product_id`, `vendor_store_id`, `qty`, `product_sku`, `unit`, `unit_price_cents`, and `sub_total_price`. Optional fields per item are `compare_at_unit_price_cents`, `applied_volume_tier_min_qty`, `applied_volume_tier_unit_price_cents`, `discounted_price`, `featured_image`, `thc_percent`, and `cbd_percent`.

#### cURL (copy into Postman > Raw)
```bash
curl -X PUT "{{API_BASE_URL}}/api/v1/cart" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_cart_key}}" \
  -d '{ ... }'
```

Replace `{ ... }` with the JSON payload shown above.

### POST /api/v1/checkout
Submits the buyer store's active cart (the bearer must belong to a buyer store). The request returns `201 Created` with a `checkout_group_id`, `vendor_orders`, and `rejected_vendors` (if any). This endpoint is protected by the idempotency middleware, so include the `Idempotency-Key` header in every request.

#### Request body
```json
{
  "cart_id": "f7b1aeac-0c93-4d59-8a0c-3cd264a5f042",
  "attributed_ad_click_id": "5d4d57a0-3a4f-4b1f-8ccf-910d1c9fa43e"
}
```
`cart_id` is required; `attributed_ad_click_id` is optional and should be a UUID when you need to attribute the checkout to an advertising click.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/checkout" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_checkout_key}}" \
  -d '{
    "cart_id": "{{cart_id}}",
    "attributed_ad_click_id": "{{optional_ad_click_id}}"
  }'
```

#### Response highlights
- `checkout_group_id`: UUID representing the checkout run.
- `vendor_orders`: array of vendors with totals (`subtotal_cents`, `transport_fee_cents`, `discount_cents`, `tax_cents`, `total_cents`, `balance_due_cents`) and their `items`.
- Each line item includes `line_item_id`, `product_id` (nullable), `product_name`, `qty`, `unit`, `unit_price_cents`, `discount_cents`, `total_cents`, `status`, and optional `notes`.
- `rejected_vendors`: appears when one or more vendors reject items their order; each entry provides `vendor_store_id` and the rejected line items.
