# Auth Endpoint cURL snippets

Use `{{API_BASE_URL}}` to point at your environment (e.g., `https://api.packfinderz.com`). Every request/response is JSON and the API mirrors the `errors` package response format (status, code, message, data). On success the server also sets `X-PF-Token` to the freshest access token for login, register, refresh, and switch-store flows.

## Shared headers
- `Content-Type: application/json`
- `Accept: application/json`
- Optional `Idempotency-Key` (useful for `POST /auth/login` and `/auth/register` so you can safely retry the same payload from Postman without creating duplicate logins).
- `Authorization: Bearer {{access_token}}` where required.

## POST /api/v1/auth/login
Logs an existing user in and returns tokens, the user record, and their stores. Returns HTTP 401 when credentials are wrong.

### Request body
```json
{
  "email": "owner@example.com",
  "password": "Secur3P@ssw0rd!"
}
```

### cURL (copy into Postman > Raw):
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/login" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Idempotency-Key: {{optional_idempotency_key}}" \
  -d '{
    "email": "owner@example.com",
    "password": "Secur3P@ssw0rd!"
  }'
```

On success you will see the JSON payload and the `X-PF-Token` header containing the access token that expires according to `pkg/config.JWTConfig`.

## POST /api/v1/auth/register
Creates the initial user/store/membership bundle for a new company. `accept_tos` **must** be `true`. Choose `store_type` from `buyer` or `vendor`.

### Request body (required + optional fields)
```json
{
  "first_name": "Jamie",
  "last_name": "Rivera",
  "email": "jamie@example.com",
  "password": "Secur3P@ssw0rd!",
  "company_name": "Rivera Grocers",
  "store_type": "vendor",
  "address": {
    "line1": "123 Main St",
    "city": "Seattle",
    "state": "WA",
    "postal_code": "98101",
    "country": "US",
    "lat": 47.608,
    "lng": -122.335
  },
  "accept_tos": true
}
```

Optional fields you can add to the same payload:
- `phone` (string)
- `dba_name` (string)
- `address.line2` (string)
- `address.geo_hash` (string generated by your front end if you already calculate it)

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/register" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Idempotency-Key: {{optional_idempotency_key}}" \
  -d '{
    "first_name": "Jamie",
    "last_name": "Rivera",
    "email": "jamie@example.com",
    "password": "Secur3P@ssw0rd!",
    "phone": "+1-206-555-0100",
    "company_name": "Rivera Grocers",
    "dba_name": "Rivera Fresh",
    "store_type": "vendor",
    "address": {
      "line1": "123 Main St",
      "line2": "Suite 400",
      "city": "Seattle",
      "state": "WA",
      "postal_code": "98101",
      "country": "US",
      "lat": 47.608,
      "lng": -122.335,
      "geo_hash": "dp7e2k"
    },
    "accept_tos": true
  }'
```

Upon success the response mirrors login (tokens + user + stores) and sets `X-PF-Token` to the new access token.

## POST /api/v1/auth/refresh
Rotates the refresh token for a new access token. Send the expired access token in `Authorization` and the refresh token in the JSON body. The old refresh token is invalidated.

### Request body
```json
{
  "refresh_token": "{{refresh_token}}"
}
```

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/refresh" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{prev_access_token}}" \
  -d '{
    "refresh_token": "{{refresh_token_token}}"
  }'
```

Success response includes the new `access_token`, `refresh_token`, and updates the `X-PF-Token` header with the freshly minted access token.

## POST /api/v1/auth/logout
Revokes the refresh token tied to the bearer access token. No body payload is required.

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/logout" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

A successful logout returns `{"status":"logged_out"}`.

## POST /api/v1/auth/switch-store
Used when a user belongs to multiple stores and wants to target a different one. Provide the new store UUID, current refresh token, and the access token in `Authorization`. The request is validated against active memberships.

### Request body
```json
{
  "store_id": "{{new_store_id}}",
  "refresh_token": "{{refresh_token}}"
}
```

### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/auth/switch-store" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{
    "store_id": "{{new_store_id}}",
    "refresh_token": "{{refresh_token}}"
  }'
```

Success returns new `access_token`, `refresh_token`, and the target store summary, plus `X-PF-Token` contains the new access token. If the membership is inactive or missing, expect HTTP 403.

## Media endpoints
All `/api/v1/media` paths require an authenticated user with an active store context (the same token you used for products/orders), so include `Authorization: Bearer {{access_token}}`. The store is derived from the session, meaning you do not send a `store_id` inside these payloads. Optional filters and headers are listed per endpoint.

### POST /api/v1/media/presign
Creates a media record, enforces `kind`/`mime_type` pairing, and returns a signed PUT URL that expires after 20 minutes (`uploadTTL`). Allowed `media_kind` values: `product`, `ads`, `pdf`, `license_doc`, `coa`, `manifest`, `user`, and `other`. The service caps uploads at 20 MB (`size_bytes ≤ 20,971,520`) and rejects mime types that are not allowed for the chosen kind (see `mimeTypesByKind` in `internal/media/service.go`).

#### Request body
```json
{
  "media_kind": "product",
  "mime_type": "image/png",
  "file_name": "fresh-cut-spinach.png",
  "size_bytes": 124518
}
```

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/media/presign" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{
    "media_kind": "product",
    "mime_type": "image/png",
    "file_name": "fresh-cut-spinach.png",
    "size_bytes": 124518
  }'
```

Return includes `media_id`, `gcs_key`, `signed_put_url`, `content_type`, and `expires_at`. Use the `signed_put_url` (valid until the `expires_at` timestamp, here `2026-01-29T17:23:06.708391-03:00`) to upload the asset directly to GCS. In Postman:

1. Switch to the **PUT** method and paste `signed_put_url` into the URL field.
2. Add `Content-Type: image/png` (matching `content_type` from the response).
3. In **Body → binary**, select the file to upload.
4. Execute the request—GCS returns 200/201 on success and the media row transitions from `pending` to `uploaded`.

If the upload fails, the server leaves the row in `pending`, so you can retry the PUT without re-presigning (reuse the same `media_id`/URL) until you get a success.

### PUT {GCS PRE SIGNED URL}

#### cURL
```bash
curl -i -X PUT \
  -H "Content-Type: application/pdf" \
  --upload-file "/Users/angelmondragon/Downloads/reserva.pdf" \
  "NEW_SIGNED_URL"
```


### GET /api/v1/media
Fetches paginated metadata for the store’s media uploads. The JSON response includes `items` (each with `signed_url` populated only when the status is `uploaded` or `ready`) plus a `cursor` for the next page. Default `limit` is 25, capped at 100; omit the query to use the default.

#### Supported query parameters
- `limit` (integer greater than zero, max 100) – override the number of items per page.
- `cursor` (string) – paste the `cursor` value from the previous response to continue.
- `kind` – filter by `media_kind` (same list as above).
- `status` – filter by `media_status` (`pending`, `uploaded`, `processing`, `ready`, `failed`, `delete_requested`, `deleted`, `delete_failed`).
- `mime_type` – filter by the recorded Content-Type string (exact match).
- `search` – compares the file name and GCS key for partial matches.

#### cURL (example with filters)
```bash
curl -G "{{API_BASE_URL}}/api/v1/media" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  --data-urlencode "limit=50" \
  --data-urlencode "kind=product" \
  --data-urlencode "status=uploaded" \
  --data-urlencode "mime_type=image/png" \
  --data-urlencode "search=spinach"
```

Keep the `cursor` value returned alongside `items` to fetch the next page. Each item contains `id`, `kind`, `status`, timestamps, and `signed_url` when available.

### DELETE /api/v1/media/{mediaId}
Deletes the media row for the active store if the asset is in a deletable status (`uploaded` or `ready`). The route returns HTTP 204 on success. Provide a valid UUID.

#### cURL
```bash
curl -X DELETE "{{API_BASE_URL}}/api/v1/media/{{media_id}}" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

If the media row was already marked deleted or belongs to a different store, the endpoint silently succeeds or returns HTTP 403/404 accordingly.

## Cart & Checkout endpoints

Cart-related routes live inside the authenticated store context, so every request requires `Authorization: Bearer {{access_token}}` and, for mutating routes (`POST /api/v1/cart` and `POST /api/v1/checkout`), an `Idempotency-Key` header with a store-scoped unique value. These headers are enforced by the idempotency middleware (missing keys return HTTP 400/422).

### GET /api/v1/cart
Returns the buyer store's active cart snapshot (if one exists). `items` lists the ordered lines, `cart_level_discount` carries applied promotions, and the totals (`subtotal_cents`, `fees`, `total_discount`, `total_cents`) mirror the authoritative values produced by the most recent `POST /api/v1/cart`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/cart" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

### POST /api/v1/cart
Creates or replaces the buyer store's active quote. The request must include `buyer_store_id` (must match the authenticated store) and at least one item; `vendor_promos` and `ad_tokens` are optional. The response returns the persisted `CartQuote`, so clients can immediately render the authoritative snapshot.

#### Request body
```json
{
  "buyer_store_id": "bf05-4512-9c9f",
  "vendor_promos": [
    {
      "vendor_store_id": "4d5c8316-eb62-4d9b-9f11-65b8c5c8a638",
      "code": "SAVE20"
    }
  ],
  "items": [
    {
      "product_id": "d3f7e10b-3f91-4f3f-92f6-df0452a1f5f5",
      "vendor_store_id": "8a4e0a8f-5a10-4de1-94da-21a1c4d4e0b1",
      "quantity": 2
    }
  ],
  "ad_tokens": ["token-abc"]
}
```

#### Payload field notes
- `buyer_store_id`: required and must match the authenticated buyer store from the JWT.
- `vendor_promos`: optional array that pairs vendor IDs with promo codes; invalid promos do not fail the quote but surface vendor-level warnings.
- `items`: required array with `product_id`, `vendor_store_id`, and `quantity >= 1`.
- `ad_tokens`: echoed back in the quote response but otherwise ignored by the service.

#### cURL (copy into Postman > Raw)
```bash
curl -X PUT "{{API_BASE_URL}}/api/v1/cart" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_cart_key}}" \
  -d '{ ... }'
```

Replace `{ ... }` with the JSON payload shown above.

### POST /api/v1/checkout
Submits the buyer store's active cart (the bearer must belong to a buyer store). The request returns `201 Created` with a `checkout_group_id`, `vendor_orders`, and `rejected_vendors` (if any). This endpoint is protected by the idempotency middleware, so include the `Idempotency-Key` header in every request.

#### Request body
```json
{
  "cart_id": "f7b1aeac-0c93-4d59-8a0c-3cd264a5f042",
  "shipping_address": {
    "line1": "400 Market St",
    "line2": "Suite 800",
    "city": "Philadelphia",
    "state": "PA",
    "postal_code": "19106",
    "country": "US",
    "lat": 39.948,
    "lng": -75.142
  },
  "payment_method": "cash",
  "shipping_line": {
    "code": "express",
    "title": "Express Shipping",
    "price_cents": 500
  }
}
```
`cart_id` and `shipping_address` are required; `payment_method` must be either `cash` or `ach`. `shipping_line` is optional and lets you confirm the chosen shipping option (omit it if the buyer selected the store's default). Checkout attribution now relies on the tokens persisted in `cart_records.ad_tokens`, so no `attributed_ad_click_id` is accepted by this endpoint.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/checkout" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_checkout_key}}" \
  -d '{
    "cart_id": "{{cart_id}}",
    "shipping_address": {
      "line1": "{{shipping_line1}}",
      "city": "{{shipping_city}}",
      "state": "{{shipping_state}}",
      "postal_code": "{{shipping_postal_code}}",
      "country": "US",
      "lat": {{shipping_lat}},
      "lng": {{shipping_lng}}
    },
    "payment_method": "cash",
    "shipping_line": {
      "code": "{{shipping_code}}",
      "title": "{{shipping_title}}",
      "price_cents": {{shipping_price_cents}}
    }
  }'
```

#### Response highlights
- `checkout_group_id`: UUID representing the checkout run.
- `vendor_orders`: array of vendors with totals (`subtotal_cents`, `transport_fee_cents`, `discount_cents`, `tax_cents`, `total_cents`, `balance_due_cents`) and their `items`.
- Each line item includes `line_item_id`, `product_id` (nullable), `product_name`, `qty`, `unit`, `unit_price_cents`, `discount_cents`, `total_cents`, `status`, and optional `notes`.
- `rejected_vendors`: appears when one or more vendors reject items their order; each entry provides `vendor_store_id` and the rejected line items.

## Order endpoints

Every `/api/v1/orders*` route runs under the authenticated store context (`middleware.RequireStore` / `StoreTypeFromContext`) so the bearer token must carry the store you intend to operate on. All requests require `Authorization: Bearer {{access_token}}`. The POST routes listed below are also guarded by `middleware.Idempotency` (`api/middleware/idempotency.go`), which enforces a non-empty `Idempotency-Key` header before allowing retries. The TTL varies: the **critical 7-day** TTL applies to `/api/v1/orders/{orderId}/cancel`, `/api/v1/orders/{orderId}/retry`, and `/api/v1/vendor/orders/{orderId}/decision`, while the **default 24-hour** TTL covers `/api/v1/orders/{orderId}/nudge`, every `/api/v1/agent/orders/*` route, and `/api/admin/orders/*`.

### GET /api/v1/orders
Returns either the buyer (`internal/orders.BuyerOrderList`) or vendor (`internal/orders.VendorOrderList`) perspective depending on `StoreType` stored in the JWT. The handler reconciles `internal/orders.BuyerOrderFilters` / `internal/orders.VendorOrderFilters` (`internal/orders/dto.go`) with the columns in `pkg/db/models/vendor_order.go` (`status`, `fulfillment_status`, `shipping_status`, `total_cents`, `discount_cents`, `order_number`, etc.).

Supported query parameters:

  * `limit` (optional, defaults to `25`, max `100`; enforced by `pkg/pagination.NormalizeLimit`)
  * `cursor` (optional pagination cursor tied to `vendor_orders.created_at` + `id`)
  * `order_status` (optional enum from `pkg/db/models/vendor_order.go` / `enums.VendorOrderStatus`)
  * `fulfillment_status` (optional enum from `enums.VendorOrderFulfillmentStatus`)
  * `shipping_status` (optional enum from `enums.VendorOrderShippingStatus`)
  * `payment_status` (optional enum from `pkg/db/models/payment_intent.go` / `enums.PaymentStatus`)
  * `actionable_statuses` (vendor-only, comma-separated `enums.VendorOrderStatus`)
  * `date_from` / `date_to` (optional ISO-8601 / `time.RFC3339` range filters)
  * `q` (optional case-insensitive search across buyer and vendor `company_name`)

Response rows include `order_number`, totals, `payment_status`, `fulfillment_status`, `shipping_status`, and the related store summaries so the UI reflects exactly what is persisted on `vendor_orders`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/orders" \
  -H "Authorization: Bearer {{access_token}}" \
  --data-urlencode "limit=25" \
  --data-urlencode "order_status=created_pending" \
  --data-urlencode "fulfillment_status=pending" \
  --data-urlencode "shipping_status=pending" \
  --data-urlencode "actionable_statuses=created_pending,accepted" \
  --data-urlencode "date_from=2025-01-01T00:00:00Z" \
  --data-urlencode "date_to=2025-01-31T23:59:59Z" \
  --data-urlencode "q=rivera"
```

### GET /api/v1/orders/{orderId}
Returns the shared `internal/orders.OrderDetail` assembled from `pkg/db/models/vendor_order.go`, `pkg/db/models/order_line_item.go`, `pkg/db/models/payment_intent.go`, and the active `pkg/db/models/order_assignment.go` row. The controller verifies the caller’s `buyer_store_id` or `vendor_store_id` owns the order before returning the detail.

#### cURL
```bash
curl -X GET "{{API_BASE_URL}}/api/v1/orders/{{order_id}}" \
  -H "Authorization: Bearer {{access_token}}"
```

### POST /api/v1/orders/{orderId}/cancel
Buyer-only action (`StoreType=buyer`). No request body—just the UUID path param, the caller’s store context, and an `Idempotency-Key` with the 7-day TTL. `internal/orders.Service.CancelOrder` releases inventory (line items from `pkg/db/models/order_line_item.go`) and marks the parent `vendor_orders.status` as `canceled`.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/orders/{{order_id}}/cancel" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: cancel-{{uuid}}"
```

### POST /api/v1/orders/{orderId}/nudge
Buyer-only POST that fires `internal/orders.Service.NudgeVendor`. No body is accepted; the route simply verifies the UUID and the store context. Include an `Idempotency-Key` (24-hour TTL) to keep retries safe.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/orders/{{order_id}}/nudge" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: nudge-{{uuid}}"
```

### POST /api/v1/orders/{orderId}/retry
Buyer-only action that reconstructs the expired order snapshot, re-reserves inventory, and returns `internal/orders.BuyerRetryResult` containing the new `order_id`. The request requires an `Idempotency-Key` with the critical 7-day TTL.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/orders/{{order_id}}/retry" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: retry-{{uuid}}"
```

### POST /api/v1/vendor/orders/{orderId}/decision
Vendor-only endpoint. The controller decodes `vendorOrderDecisionRequest` (`decision` required) and converts it into `enums.VendorOrderDecision`. Only `vendor_orders.status = created_pending` rows (see `pkg/db/models/vendor_order.go`) may transition to `accepted` or `rejected`; the service enforces that before patching the `status` column and emitting `order_decided`.

#### Request body
```json
{
  "decision": "accept"
}
```

`decision` must be either `accept` or `reject` or the validator returns `pkg/errors.CodeValidation`.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/vendor/orders/{{order_id}}/decision" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: decision-{{uuid}}" \
  -d '{
    "decision": "accept"
  }'
```

### POST /api/v1/vendor/orders/{orderId}/line-items/decision
Vendor-only POST that decodes `vendorLineItemDecisionRequest` (`line_item_id`, `decision`, optional `notes`). The handler validates `line_item_id` as a UUID, and the service updates `pkg/db/models/order_line_item.go` (`status`, `notes`) before recomputing the parent `vendor_order` totals. `decision` must be `fulfill` or `reject`, and `notes` is optional explanatory text stored with the line item.

#### Request body
```json
{
  "line_item_id": "a0b1c2d3-4e5f-6789-abcd-1234567890ab",
  "decision": "fulfill",
  "notes": "Picked this up curbside"
}
```

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/vendor/orders/{{order_id}}/line-items/decision" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: line-item-{{uuid}}" \
  -d '{
    "line_item_id": "{{line_item_id}}",
    "decision": "fulfill",
    "notes": "Fulfilled via curbside"
  }'
```

## Agent dispatch endpoints

All `/api/v1/agent/orders*` routes require `RequireRole("agent")` from the JWT (`api/middleware/require_role.go`). GET endpoints support the standard cursor/limit pagination, and the POST actions (`pickup`/`deliver`) require `Idempotency-Key` (24-hour TTL) thanks to `middleware.Idempotency`. Agent requests always carry `Authorization: Bearer {{agent_access_token}}`.

### GET /api/v1/agent/orders
Returns the agent’s assigned orders (`internal/orders.AgentOrderQueueList`) by joining `vendor_orders` with `order_assignments` rows where `active = true` and `agent_user_id` matches the caller. Each `AgentOrderQueueSummary` mirrors what is stored in `pkg/db/models/vendor_order.go` and the buyer/vendor summaries from `pkg/db/models/store.go`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/agent/orders" \
  -H "Authorization: Bearer {{agent_access_token}}" \
  --data-urlencode "limit=25" \
  --data-urlencode "cursor={{optional_cursor}}"
```

### GET /api/v1/agent/orders/queue
Returns the unassigned dispatch queue. The repository filters for `vendor_orders.status = hold` and `order_assignments.active IS NULL`, so every order is ready for assignment and the response uses `internal/orders.AgentOrderQueueSummary`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/agent/orders/queue" \
  -H "Authorization: Bearer {{agent_access_token}}" \
  --data-urlencode "limit=25" \
  --data-urlencode "cursor={{optional_cursor}}"
```

### GET /api/v1/agent/orders/{orderId}
Returns `internal/orders.OrderDetail`, but the controller rejects requests when `ActiveAssignment.AgentUserID` differs from the caller or when there is no active assignment (`pkg/db/models/order_assignment.go`). The payload includes the assignment’s `pickup_time`, `delivery_time`, and signature keys, so the app knows whether the order is still on the way.

#### cURL
```bash
curl -X GET "{{API_BASE_URL}}/api/v1/agent/orders/{{order_id}}" \
  -H "Authorization: Bearer {{agent_access_token}}"
```

### POST /api/v1/agent/orders/{orderId}/pickup
Marks the assigned order as `status=in_transit`, `shipping_status=in_transit`, and records `order_assignments.pickup_time`. Returns `{"status":"in_transit"}`; repeated calls are safe because the service treats already-in-transit orders as idempotent.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/agent/orders/{{order_id}}/pickup" \
  -H "Authorization: Bearer {{agent_access_token}}" \
  -H "Idempotency-Key: pickup-{{uuid}}"
```

### POST /api/v1/agent/orders/{orderId}/deliver
Transitions the order to `vendor_orders.status = delivered`, `shipping_status = delivered`, and fills `order_assignments.delivery_time`. Success returns `{"status":"delivered"}`.

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/agent/orders/{{order_id}}/deliver" \
  -H "Authorization: Bearer {{agent_access_token}}" \
  -H "Idempotency-Key: deliver-{{uuid}}"
```

## Product & inventory endpoints

Vendor product management lives under the authenticated store context, so every request requires `Authorization: Bearer {{access_token}}` and the store in the JWT must be a **vendor** store. Only vendor members with roles `owner`, `admin`, `manager`, `staff`, `agent`, or `ops` can use these routes. `POST /api/v1/vendor/products` additionally requires an `Idempotency-Key` header (24‑hour TTL) because it creates inventory, media, and volume discount rows in a single transaction.

### POST /api/v1/vendor/products
Creates a new product record plus its inventory, optional media links, and optional tiered pricing. The controller decodes the `createProductRequest` DTO and validates every required field (`sku`, `title`, `category`, `feelings`, `flavors`, `usage`, `unit`, `moq`, `price_cents`, `inventory`). The request also enforces:

- `category` must be one of `flower`, `cart`, `pre_roll`, `edible`, `concentrate`, `beverage`, `vape`, `topical`, `tincture`, `seed`, `seedling`, or `accessory`.
- `unit` must be one of `unit`, `gram`, `ounce`, `pound`, `eighth`, or `sixteenth`.
- `feelings`, `flavors`, and `usage` are required string arrays where each entry is validated against the `product` enums (e.g., `feelings`: `relaxed`, `happy`, `euphoric`, `focused`, `hungry`, `talkative`, `creative`, `sleepy`, `uplifted`, `calm`; `flavors`: `earthy`, `citrus`, `fruity`, `floral`, `cheese`, `diesel`, `spicy`, `sweet`, `pine`, `herbal`; `usage`: `stress_relief`, `pain_relief`, `sleep`, `depression`, `muscle_relaxant`, `nausea`, `anxiety`, `appetite_stimulation`).
- `moq` must be ≥ 1 and `price_cents`/`compare_at_price_cents` must be ≥ 0.
- `thc_percent` and `cbd_percent` are optional and must stay between 0 and 100.
- `classification` (if provided) must be one of `sativa`, `hybrid`, `indica`, `cbd`, `hemp`, or `balanced`.
- `inventory` is required and must contain `available_qty` (≥ 0) and `reserved_qty` (≥ 0) with `reserved_qty ≤ available_qty`; the service stores both counts in `inventory_items`.
- `media_ids`, when present, must be UUIDs for `media_kind=product` rows that belong to the same vendor store (duplicates are rejected).
- `volume_discounts` entries must include `min_qty` (≥ 1) and `unit_price_cents` (≥ 0), and `min_qty` values must be unique within the payload.

`partial fields` are allowed for the optional attributes (`subtitle`, `body_html`, `strain`, `media_ids`, `volume_discounts`, `compare_at_price_cents`, `is_active`, `is_featured`, `thc_percent`, `cbd_percent`). `is_active` defaults to `true` when omitted; `is_featured` defaults to `false`.

#### Sample request body (required + optional fields)
```json
{
  "sku": "FLWR-OK-GLZ-008",
  "title": "Galactic Glaze — Premium Indoor Flower",
  "subtitle": "Sticky, terp-forward buds with a bright citrus + pine finish.",
  "body_html": "<h3>Overview</h3><p><strong>Galactic Glaze</strong> is a boutique indoor flower with dense structure, strong bag appeal, and a clean burn. Expect an initial citrus pop that settles into piney, earthy undertones.</p><h3>Aroma & Flavor</h3><ul><li><strong>Citrus</strong> upfront</li><li><strong>Pine</strong> on the finish</li><li><strong>Earthy</strong> base notes</li></ul><h3>Effects</h3><p>Often described as <strong>uplifted</strong>, <strong>focused</strong>, and <strong>happy</strong>, making it a solid daytime option for customers who want clarity without feeling heavy.</p><h3>Suggested Use Cases</h3><ul><li>Stress relief</li><li>Anxiety support</li><li>Mood lift</li></ul><h3>Compliance Notes</h3><p>COA available upon request. Store and handle per local regulations.</p>",
  "category": "flower",
  "feelings": ["uplifted", "focused", "happy"],
  "flavors": ["citrus", "pine", "earthy"],
  "usage": ["stress_relief", "anxiety", "depression"],
  "strain": "Galactic Glaze",
  "classification": "hybrid",
  "unit": "eighth",
  "moq": 10,
  "price_cents": 1800,
  "compare_at_price_cents": 2200,
  "is_active": true,
  "is_featured": false,
  "thc_percent": 24.75,
  "cbd_percent": 0.35,
  "inventory": {
    "on_hand_qty": 240,
    "reserved_qty": 0,
    "low_stock_threshold": 30
  },
  "media_ids": [
    "3b7e2b6a-6b9f-4b2a-9f7a-7c4c9a2b5e11",
    "c1f0e7e4-0d7a-4d63-8d6f-0b2c2d1f9a77"
  ],
  "volume_discounts": [
    { "min_qty": 25, "unit_price_cents": 1700 },
    { "min_qty": 50, "unit_price_cents": 1550 },
    { "min_qty": 100, "unit_price_cents": 1400 }
  ]
}
```

#### cURL (copy into Postman > Raw)
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/vendor/products" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_product_key}}" \
  -d '{ ... }'
```

Replace `{ ... }` with the JSON payload above. The response returns the persisted `product.ProductDTO`, which includes `inventory`, `volume_discounts`, and `media` (may be absent/`null` when there are no attachments). The `inventory` block in the response surfaces the live `available_qty`, `reserved_qty`, and `updated_at`, while `media` objects expose `id`, `url` (nullable), `gcs_key`, `position`, and `created_at`.

### PATCH /api/v1/vendor/products/{productId}
Updates metadata, inventory, volume discounts, or media for an existing product. The `updateProductRequest` allows every field to be optional, but trimmed strings (`sku`, `title`) must not become empty and enumerated values are re-validated. The controller enforces the same enum/value rules as creation, and the service includes these behaviors:

- Passing `inventory` will upsert the `inventory_items` row via `UpsertInventory`; both `available_qty` and `reserved_qty` must be provided (the controller enforces this) and `reserved_qty` cannot exceed `available_qty`, so you can keep inventory synchronized from Postman (existing `reserved_qty` is preserved while `available_qty` is overwritten to avoid unintentional reservation changes).
- Providing `volume_discounts` replaces every tier for the product, so send the full desired set each time; duplicates in `min_qty` are rejected.
- Providing `media_ids` replaces the ordered media stack, so you can clear media by sending an empty array or reorder requests by inserting IDs in the desired order. Media must exist, belong to the active vendor store, and be `media_kind=product`.
- Omitting optional blocks leaves that portion of the product untouched.

#### Sample update body (optional fields + inventory sync)
```json
{
  "title": "Fresh Cut Spinach (updated)",
  "price_cents": 630,
  "inventory": {
    "available_qty": 250,
    "reserved_qty": 5
  },
  "media_ids": [
    "{{new_media_id}}",
    "{{second_media_id}}"
  ],
  "volume_discounts": [
    {
      "min_qty": 5,
      "unit_price_cents": 620
    },
    {
      "min_qty": 15,
      "unit_price_cents": 590
    }
  ]
}
```

#### cURL (copy into Postman > Raw)
```bash
curl -X PATCH "{{API_BASE_URL}}/api/v1/vendor/products/{{product_id}}" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{ ... }'
```

The response is the updated `product.ProductDTO`. Inventory changes appear under `inventory`, and `media` may be `null` if no attachments remain. Volume discounts mirror the new tier list with each entry returning `id`, `min_qty`, `unit_price_cents`, and `created_at`.

### DELETE /api/v1/vendor/products/{productId}
Removes the product, its inventory, volume discounts, and media cascading via FK constraints. The bearer must be a vendor member who owns (or is an allowed role on) the store; the controller checks `store_id` ownership before delegating to the service.

#### cURL
```bash
curl -X DELETE "{{API_BASE_URL}}/api/v1/vendor/products/{{product_id}}" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

Returns `204 No Content` on success. Requesting a product that belongs to another store returns `403 Forbidden`, and non-existent products return `404 Not Found`.

### GET /api/v1/inventory
Returns every inventory row that belongs to the authenticated vendor store. Each entry matches an `inventory_items` row and surfaces `product_id`, `available_qty`, `reserved_qty`, and `updated_at` so you can keep the UI aligned with the database truth. The API enforces vendor context and member roles (owner/admin/manager/staff/agent/ops), so missing or mismatched stores return `403`.

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/v1/inventory" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

#### Response highlights
- `items`: array of inventory objects keyed by `product_id`.
- `available_qty`: non-negative integer (the value you control via the set endpoint).
- `reserved_qty`: number of units already reserved by active carts/orders (read-only in this endpoint).
- `updated_at`: timestamp showing when the row was last synced.

### PUT /api/v1/inventory/{productId}
Sets the vendor's available quantity for a specific product. The route is idempotent (the middleware requires `Idempotency-Key` and deduplicates identical payloads), and you are only allowed to touch `available_qty` here—`reserved_qty` remains managed by reservations/checkouts. Provide a valid `productId` path parameter (UUID) and a body containing the new `available_qty` (must be `>= 0`).

#### Request body
```json
{
  "available_qty": 180
}
```

#### cURL (copy into Postman > Raw)
```bash
curl -X PUT "{{API_BASE_URL}}/api/v1/inventory/{{product_id}}" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -H "Idempotency-Key: {{unique_inventory_key}}" \
  -d '{
    "available_qty": 180
  }'
```

The response mirrors the updated inventory row (`available_qty`, `reserved_qty`, `updated_at`). Invalid quantities (`< 0`) or a `productId` that belongs to another store return `403/404`, and the middleware enforces idempotency so repeat submissions with the same key and payload return the original result without double updates.

## License endpoints

License metadata lives under the vendor store context and requires `Authorization: Bearer {{access_token}}`. Only members with roles `owner`, `admin`, `manager`, `staff`, or `ops` can mutate licenses. Every license record must be backed by a `media_id` that points at an uploaded `media_kind=license_doc` asset belonging to the same store; the service verifies the media is ready (`uploaded`/`ready`) with an allowed mime type (PDF or image) before persisting the license.

### POST /api/v1/licenses
Registers a new license for the active store. The controller decodes the `licenseCreateRequest`, which enforces:

- `media_id` (required UUID) – points at the license PDF/image that already exists in the store’s media table, `media_kind=license_doc`, and owns the right store.
- `issuing_state`, `type`, and `number` are required strings (`type` is one of `producer`, `grower`, `dispensary`, or `merchant`); `issuing_state` and `number` are trimmed before persistence.
- `issue_date` and `expiration_date` are optional ISO dates (Go’s `time.Time`).

#### Request body
```json
{
  "media_id": "{{license_media_id}}",
  "issuing_state": "WA",
  "issue_date": "2025-11-01T00:00:00Z",
  "expiration_date": "2026-11-01T00:00:00Z",
  "type": "dispensary",
  "number": "LIC-123456"
}
```

> `issue_date`/`expiration_date` may be omitted; the server stores them null when missing.

#### cURL (copy into Postman > Raw)
```bash
curl -X POST "{{API_BASE_URL}}/api/v1/licenses" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  -d '{
    "media_id": "{{license_media_id}}",
    "issuing_state": "WA",
    "issue_date": "2025-11-01T00:00:00Z",
    "expiration_date": "2026-11-01T00:00:00Z",
    "type": "dispensary",
    "number": "LIC-123456"
  }'
```

Success returns the `licenseResponse` (`id`, `store_id`, `user_id`, `status`, `media_id`, `issuing_state`, `issue_date`, `expiration_date`, `type`, `number`, `created_at`, `updated_at`). Status starts as `pending`.

### GET /api/v1/licenses
Lists the store’s licenses with pagination. Supply optional query parameters `limit` (positive integer) and `cursor` (opaque string from the previous response). The `ListResult` contains `items` and a `cursor` for the next page.

#### Query parameters
- `limit` – optional, positive integer; when omitted the service uses its default limit.
- `cursor` – optional pagination cursor returned by a previous call.

#### cURL (with pagination example)
```bash
curl -G "{{API_BASE_URL}}/api/v1/licenses" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}" \
  --data-urlencode "limit=25" \
  --data-urlencode "cursor={{optional_cursor}}"
```

Each item exposes `id`, `store_id`, `user_id`, `status` (`pending`, `verified`, `rejected`, or `expired`), `media_id`, `issuing_state`, `issue_date`, `expiration_date`, `type`, `number`, `created_at`, `updated_at`, and `signed_url` (pre-signed GCS URL for the license file, when available).

### DELETE /api/v1/licenses/{licenseId}
Removes a rejected or expired license so the store can re-submit compliance assets. Only `owner`/`manager` roles may delete, and the endpoint returns `403 Forbidden` if the license belongs to another store or `409 Conflict` when the status is still `pending` or `verified`.

#### cURL
```bash
curl -X DELETE "{{API_BASE_URL}}/api/v1/licenses/{{license_id}}" \
  -H "Accept: application/json" \
  -H "Authorization: Bearer {{access_token}}"
```

Success returns `{"deleted": true}` and, if the store no longer has any valid licenses, the service flips the store’s KYC back to `pending_verification`.



## Admin endpoints

### POST /api/admin/v1/auth/login
Admin login lives under `/api/admin` so the resulting access token is storeless (`role=admin`, no `active_store_id`). Valid credentials set `X-PF-Token` to the fresh access token, return the `refresh_token`, and include the admin `user` DTO; invalid credentials return the standard `401` message. The request payload is `auth.LoginRequest` (`email`/`password` are required strings and `email` is normalized before the lookup). The response mirrors `pkg/db/models.User` fields (`id`, `email`, `first_name`, `last_name`, `phone`, `system_role`), and the service rejects anything that does not have `system_role="admin"` even if the password is valid.

#### Request body
```json
{
  "email": "admin@example.com",
  "password": "Secur3P@ssw0rd!"
}
```

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/admin/v1/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@example.com",
    "password": "Secur3P@ssw0rd!"
  }'
```

Success returns `{"user": {...}, "refresh_token": "{{refresh_token}}"}` and the `X-PF-Token` header contains the access token used by `/api/admin/*`. The handler updates `last_login_at` on the `users` row before minting the JWT so downstream tooling sees the latest activity timestamp.

### POST /api/admin/v1/auth/register
Developer-only helper that exists when `PACKFINDERZ_APP_ENV != prod` (the controller immediately returns `403 admin register disabled in production` otherwise). It creates an admin user with `system_role="admin"`, `is_active=true`, and an Argon2id password hash via `security.HashPassword`, returns the `user` DTO plus the tokens, and sets `X-PF-Token` so tooling can immediately call `/api/admin/*`. Duplicate emails return `409 Conflict` (the service checks `users.Repository.FindByEmail` before insert), while validation errors still surface `422`. The response payload is identical to the admin login output because the controller proxies to `auth.AdminLogin`.

#### Request body
```json
{
  "email": "admin@example.com",
  "password": "Secur3P@ssw0rd!"
}
```

`email` and `password` are both required (`auth.AdminRegisterRequest`). The created `users` row mirrors `pkg/db/models.User`, so it will have `password_hash`, `system_role`, `is_active`, and timestamps (`created_at`, `updated_at`).

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/admin/v1/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@example.com",
    "password": "Secur3P@ssw0rd!"
  }'
```

Success returns the admin `user` DTO plus `refresh_token` and the `X-PF-Token` header (the access token itself is not serialized). The endpoint is omitted when `PACKFINDERZ_APP_ENV=prod`, keeping the admin table writable only in dev/stage.

### GET /api/admin/ping
Admin ping simply echoes `{"scope":"admin","status":"ok"}` and confirms the JWT has `role=admin`. The route is guarded by `middleware.Auth` and `middleware.RequireRole("admin")` while skipping `StoreContext` so storeless tokens pass.

#### cURL
```bash
curl -X GET "{{API_BASE_URL}}/api/admin/ping" \
  -H "Authorization: Bearer {{admin_access_token}}"
```

Expect `200` with the status payload; no body or query parameters are accepted.

### POST /api/admin/v1/licenses/{licenseId}/verify
Admin users (via `/api/admin`) control license status. Supply `decision` (`verified` or `rejected`) and an optional `reason`. The route returns the updated `licenseResponse` and publishes the `LicenseStatusChanged` outbox event. The request DTO is `adminLicenseVerifyRequest`, so `decision` is required, `reason` is optional, and the controller rejects any string other than the `pkg/enums.LicenseStatus` values `verified`/`rejected`.

The updated `licenseResponse` mirrors `pkg/db/models.License` fields (`id`, `store_id`, `status`, `media_id`, `issuing_state`, `issue_date`, `expiration_date`, `type`, `number`, timestamps). If the license already has a non-`pending` status the service returns `409 Conflict`.

#### Request body
```json
{
  "decision": "verified",
  "reason": "Documentation verified"
}
```

`reason` is optional and stored with the license update to give stores context for the admin decision. `decision` must be `verified` or `rejected`; anything else results in `422 decision must be verified or rejected`.

#### cURL (admin token example)
```bash
curl -X POST "{{API_BASE_URL}}/api/admin/v1/licenses/{{license_id}}/verify" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {{admin_access_token}}" \
  -d '{
    "decision": "verified",
    "reason": "Documentation verified"
  }'
```

When verification succeeds the store’s KYC status is recalculated (`verified`, `rejected`, or `expired` depending on other licenses) and the response includes the refreshed license record along with any generated `notifications`.

### GET /api/admin/v1/orders/payouts
Returns delivered, settled, and unpaid vendor orders eligible for payout. Query `limit` (default `25`, max `100`) and optional `cursor` control pagination (`pagination.Params`), and each entry includes `orderId`, `orderNumber`, `vendorStoreId`, `amountCents`, and `deliveredAt` coming from `internal/orders.Repository.ListPayoutOrders`. The repository filters `pkg/db/models.VendorOrder` rows where `status=delivered` and joins `pkg/db/models.PaymentIntent` rows with `status=settled`, so clients can target payout-ready orders exactly.

Query options:

  * `limit` (optional, default `25`, max `100`)
  * `cursor` (optional pagination cursor)

#### cURL
```bash
curl -G "{{API_BASE_URL}}/api/admin/v1/orders/payouts" \
  -H "Authorization: Bearer {{admin_access_token}}" \
  --data-urlencode "limit=25" \
  --data-urlencode "cursor={{optional_cursor}}"
```

Response is `internal/orders.PayoutOrderList` containing the cursor for the next page plus the entries described above.

### GET /api/admin/v1/orders/payouts/{orderId}
Loads the detail for a single payout-ready order via `internal/orders.Repository.FindOrderDetail`. The handler verifies the `vendor_orders.status` is `delivered` and the attached `payment_intents.status` is `settled` before returning the shared `internal/orders.OrderDetail`, which mirrors `pkg/db/models.VendorOrder`/`pkg/db/models.PaymentIntent` plus joined line items, assignments, and store metadata. Default 404/403 responses occur if the order is missing or fails the payout guard.

#### cURL
```bash
curl -X GET "{{API_BASE_URL}}/api/admin/v1/orders/payouts/{{order_id}}" \
  -H "Authorization: Bearer {{admin_access_token}}"
```

Success returns the full order detail payload so the admin UI can review items, payment info, and delivery timestamps before authorizing the cash payout.

### POST /api/admin/v1/orders/{orderId}/confirm-payout
Finalizes the payout for an eligible order. The controller reads `orderId` from the path (validated as UUID) and uses `internal/orders.Service.ConfirmPayout` to set `payment_intents.status=paid`, stamp `vendor_paid_at`, close the vendor order, append a ledger row, and emit the `order_paid` outbox event. The route is protected by `middleware.Idempotency`, so include `Idempotency-Key` (24h TTL) in every request to avoid replays.

Headers:

  * `Authorization: Bearer {{admin_access_token}}`
  * `Idempotency-Key: {{unique_key}}`

#### cURL
```bash
curl -X POST "{{API_BASE_URL}}/api/admin/v1/orders/{{order_id}}/confirm-payout" \
  -H "Authorization: Bearer {{admin_access_token}}" \
  -H "Idempotency-Key: payout-{{uuid}}"
```

Success returns `200` with an empty data envelope; if the order is no longer delivered/settled, the API responds with `409`/`422` describing the state conflict. The `ConfirmPayout` service enforces `pkg/db/models.VendorOrder.status=delivered` and `pkg/db/models.PaymentIntent.status=settled` before mutating rows.
