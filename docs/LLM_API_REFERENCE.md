## Shared conventions
- Authentication: `Authorization: Bearer <token>` is validated by `middleware.Auth`, loads `user_id`, `store_id`, and `role` into context before entering `/api` handlers (api/middleware/auth.go:23-80).
- Store context: `middleware.StoreContext` rejects requests without a store ID once the JWT is validated (api/middleware/store.go:6-16).
- Roles: `middleware.Auth` seeds the JWT `role` claim from `AccessTokenClaims.Role` (derived from the primary membership or `users.system_role`), and `middleware.RequireRole("admin"/"agent")` gates `/api/admin` and `/api/v1/agent` ping endpoints (api/middleware/auth.go:19-80; api/middleware/roles.go:1-27).
- Idempotency: `Idempotency-Key` is required for `POST /api/v1/auth/register`, `/api/v1/stores/me/users/invite`, `/api/v1/licenses`, and `/api/v1/media/presign`, with TTL rules defined in `api/middleware/idempotency.go:37-208`.
- Errors: handlers emit `pkg/errors.Code*` metadata so HTTP status and retryability follow `pkg/errors/errors.go:9-100`.

## Health
- `GET /health/live` – unauthenticated liveliness check, returns `{"status":"live"}` and `X-PackFinderz-Env` (api/controllers/health.go:16-21).
- `GET /health/ready` – dependency probe; pings Postgres/Redis/GCS/BigQuery (dataset + `marketplace_events`/`ad_events` tables) so `pkg/errors.CodeDependency` details surface missing analytics infra before work starts (api/controllers/health.go:23-70; pkg/bigquery/client.go:27-184).

## Public
- `GET /api/public/ping` – no auth, responds `{"scope":"public","status":"ok"}` (api/controllers/ping.go:10-24).
- `POST /api/public/validate` – validates `name`/`email` payload, echoes sanitized `name`, `email`, and optional `limit` (validators enforce length/format) (api/controllers/validate.go:11-35).

## Auth
- `POST /api/admin/v1/auth/login` – admin-only route under the `/api/admin` group, it accepts the same `{"email","password"}` payload (handled via `auth.LoginRequest`), enforces `users.system_role=admin`, and mirrors the fresh access token in `X-PF-Token` while returning `{"user":<users.UserDTO>,"refresh_token":<refresh_token>}`; invalid emails/passwords or non-admin users get the canonical `401 invalid credentials` error. The route does not serialize the access token (only the header), updates `last_login_at`, mints a JWT with `role=admin`/no store claims, and seeds the refresh session via `session.Generate` so `/api/admin/*` can be accessed without an `active_store_id` (api/routes/router.go:117-119; api/controllers/auth.go:39-61; internal/auth/service.go:160-194).
- `POST /api/admin/v1/auth/register` – dev-only helper that is mounted only when `cfg.App.IsProd()` is false, creates a `users.system_role=admin` row with `is_active=true`, hashes the password via `security.HashPassword`, prevents duplicate emails via the conflict check in `internal/auth/admin_register`, then reuses `auth.AdminLogin` so the response matches the admin login payload while also adding `X-PF-Token` (header) so dev tooling can immediately hit `/api/admin/*`; invalid payloads still raise `422` from `validators.DecodeJSONBody`, duplicate emails surface as `409`, and production calls return `403 admin register disabled in production` (api/routes/router.go:109-119; api/controllers/auth.go:63-93; internal/auth/admin_register.go:16-92; pkg/config/config.go:19-36; pkg/security/password.go:29-44).
  Request body (all fields required):
  ```json
  {
    "first_names": "Admin",
    "last_name": "User",
    "email": "admin@example.com",
    "password": "Secur3P@ssw0rd!"
  }
  ```
- `POST /api/v1/auth/register` – public, body `RegisterRequest` (first/last name, email, password, company, store_type, address, accept_tos), reuses `auth.Service` to auto-login, returns 201 with tokens and `X-PF-Token` (api/controllers/register.go:13-41; internal/auth/register.go:21-133).
- `POST /api/v1/auth/logout` – requires Authorization Bearer token, revokes the access session via `session.Manager.Revoke`, returns `{"status":"logged_out"}` (api/controllers/session.go:47-79).
- `POST /api/v1/auth/refresh` – requires Authorization, body `{"refresh_token"}`, rotates session, issues new `AccessToken`/`RefreshToken` plus `X-PF-Token` header (api/controllers/session.go:81-143).
- `POST /api/v1/auth/switch-store` – Authorization plus body `{"store_id","refresh_token"}`, ensures membership, rotates session, returns new tokens and `StoreSummary` (api/controllers/switch_store.go:18-68).

## Private (store-scoped)
- `GET /api/ping` – auth + store context, echoes scope/store_id for health (api/controllers/ping.go:16-24).
- `GET /api/v1/notifications` – auth + store context via `middleware.Auth`/`middleware.StoreContext` so only stores with `activeStoreId` can reach it; `controllers.ListNotifications` parses `limit` (positive integer), `cursor` (optional encoded `created_at|id`), and `unreadOnly=true|false`, then calls `notifications.Service.List`. The service normalizes `limit` with `pagination.NormalizeLimit` (default 25, max 100), enforces cursor-based pagination ordered by `(created_at, id)` descending, applies the `read_at IS NULL` filter when requested, and returns `ListResult{items: []Notification, cursor: nextCursor}` for the next page (empty when none). Non-authenticated requests fail before the controller (401 from `middleware.Auth`), and missing store context returns `pkg.errors.CodeForbidden`/HTTP 403 (`api/routes/router.go:129-133`; `api/controllers/notifications.go:17-67`; `internal/notifications/service.go:13-79`; `internal/notifications/repo.go:54-75`; `pkg/pagination/pagination.go:12-40`).
- `POST /api/v1/notifications/{notificationId}/read` – requires `Idempotency-Key` because `middleware.Idempotency` guards every `/api` POST; the controller validates the path UUID + active store (`StoreIDFromContext`) and calls `notifications.Service.MarkRead`. That service only updates `read_at` when it is `NULL` for the matching `notificationId`/`storeId`, so the request is idempotent, returns `{"read": true}` on success, and rejects cross-store or missing contexts with `pkg.errors.CodeNotFound`/HTTP 404 or `pkg.errors.CodeForbidden`/HTTP 403 (`api/routes/router.go:129-133`; `api/controllers/notifications.go:69-107`; `internal/notifications/service.go:81-109`; `internal/notifications/repo.go:78-101`; `api/middleware/idempotency.go:37-208`).
- `POST /api/v1/notifications/read-all` – also behind `middleware.Idempotency`, so repeated calls without unread notifications still succeed; the controller calls `notifications.Service.MarkAllRead`, which updates every unread row’s `read_at` for the active store and returns `{"updated": count}` so clients can show how many items were affected without touching other tenants (`api/routes/router.go:129-133`; `api/controllers/notifications.go:108-118`; `internal/notifications/service.go:99-109`; `internal/notifications/repo.go:104-113`; `api/middleware/idempotency.go:37-208`).

- ## Cart
- `POST /api/v1/cart` – buyer stores persist their quote intents via this idempotent (24h TTL) route. `middleware.Idempotency` guards the route and injects the idempotency key, while `controllers.CartQuote` validates the buyer store is a verified buyer, decodes `cartdto.QuoteCartRequest`, and delegates to `internal/cart.Service.QuoteCart`. The service rebuilds vendor eligibility, inventory, MOQ, tier pricing, promo validation, and normalized totals before persisting `cart_record`/`cart_items`/`cart_vendor_groups` and returning the canonical `CartQuote` snapshot (`api/middleware/idempotency.go:45-208`; `internal/cart/service.go:310-414`).
- `GET /api/v1/cart` – returns the active cart record (with items) for the buyer store when present. `controllers.CartFetch` reuses the same buyer-store context, calls `internal/cart.Service.GetActiveCart` (which validates the buyer is a verified buyer store and scopes the query to `buyer_store_id`), and surfaces `404`/`pkgerrors.CodeNotFound` if no active cart exists, ensuring only the owning buyer can fetch the snapshot (`internal/cart/service.go:259-284`).
- `GET /api/v1/vendor/analytics` – vendor-only route (requires `StoreContext` + `StoreType=vendor` from middleware) that accepts either a `preset` query (`7d`, `30d`, `90d`, default `30d`) or both `from`/`to` RFC3339 timestamps, resolves a start/end range, and calls `internal/analytics.Service.Query` so KPIs (orders, revenue, AOV, cash collected) and per-day aggregates derive directly from BigQuery (`api/controllers/analytics/vendor.go`:16-58; `api/routes/router.go`:55-95; `internal/analytics/service.go`:1-200).
- `GET /api/v1/analytics/marketplace` – store-scoped route (requires `StoreContext` + valid `StoreType`) that follows the same timeframe contract, scopes by `activeStoreId`, and also flows through `internal/analytics.Service.Query` so buyers and vendors alike can access the marketplace dashboard data (`api/controllers/analytics/marketplace.go`:1-48; `api/routes/router.go`:60-100; `internal/analytics/service.go`:1-200).

## Checkout
- `POST /api/v1/checkout` – requires auth, store context, and idempotency (`middleware.Idempotency` enforces `Idempotency-Key` for buyer checkout with a 7d TTL and replays the first success while mismatched bodies return `pkg/errors.CodeIdempotency`/HTTP `409`); the handler asserts the store is a buyer (`pkg/errors.CodeForbidden`/HTTP `403` otherwise), decodes `cart_id` plus optional `attributed_ad_click_id`, calls `internal/checkout.Service.Execute`, and returns `201` with `checkout_group_id`, `vendor_orders` grouped by `vendor_store_id` (each order includes `subtotal`, `discount`, `total`, `balance_due`, and its `items` with `status`/`notes`), plus `rejected_vendors` that list every rejected line item so clients can surface failures (`api/controllers/checkout.go:9-145`; `api/middleware/idempotency.go:37-208`).
- `GET /api/v1/orders` – exposes buyer/vendor order lists by reading `activeStoreId`/`StoreType` from the middleware context; buyers call `internal/orders.Repository.ListBuyerOrders`, vendors call `ListVendorOrders` (both wired through `api/controllers/orders.List`), and the handler accepts cursor pagination plus filters (`order_status`, `fulfillment_status`, `shipping_status`, `payment_status`, `actionable_statuses`, `date_from`, `date_to`, `q`, `limit`, `cursor`). Unauthorized store types (missing or unsupported) return `pkg/errors.CodeForbidden`/HTTP `403` (`api/controllers/orders/orders.go:13-144`).
- `GET /api/v1/orders/{orderId}` – calls `internal/orders.Repository.FindOrderDetail`, verifies the returned order’s buyer/vendor store matches `activeStoreId` per the caller’s `StoreType`, and returns 403 when the store does not own the order; 404 is returned when the `orderId` is invalid or not found. The controller parses `order_status` (UUID), handles validation errors, and rejects missing store context before delegating to the repository (`api/controllers/orders/orders.go:146-220`).
- `POST /api/v1/vendor/orders/{orderId}/decision` – vendor-only endpoint (middleware sets `StoreContext`/`StoreType` and `Idempotency-Key`) that accepts `{decision: "accept"|"reject"}` JSON, rejects non-vendor requests/invalid decisions, loads the order, enforces `OrderStatus=created_pending`, transitions it to `accepted`/`rejected`, and emits the `order_decided` outbox event (`api/controllers/orders/orders.go:140-228`; `internal/orders/service.go:24-147`; middleware.StoreContext/logic ensures `Idempotency-Key` per `api/routes/router.go:60-116`).
- `POST /api/v1/vendor/orders/{orderId}/line-items/decision` – vendor-only endpoint (same middleware stack) that accepts `{line_item_id, decision: "fulfill"|"reject", notes?}` JSON, validates the line item belongs to the order, updates its status, releases inventory when rejecting, recomputes `subtotal_cents`, `total_cents`, and `balance_due_cents`, promotes `fulfillment_status`/`status` once every pending line is handled, and emits the `order_fulfilled` outbox event (`api/controllers/orders/orders.go:222-318`; `internal/orders/service.go:180-359`; `pkg/enums/outbox.go:57-72`).
- `POST /api/v1/orders/{orderId}/cancel` – buyer-only action that confirms the order is not in transit, rejects unresolved line items, releases any reserved inventory, sets `balance_due_cents` to zero, marks `status=canceled`, and emits the `order_canceled` outbox event so downstream systems (inventory, refunds, notifications) see the cancellation (`api/controllers/orders/orders.go:318-378`; `internal/orders/service.go:360-422`; `pkg/enums/outbox.go:57-69`).
- `POST /api/v1/orders/{orderId}/nudge` – buyer-only action that ensures the order is still mutable, then emits a `NotificationRequested` event with `type=order_nudge` to wake the vendor or ops team without mutating the order state (`api/controllers/orders/orders.go:378-426`; `internal/orders/service.go:422-462`; `pkg/enums/outbox.go:57-71`).
- `POST /api/v1/orders/{orderId}/retry` – buyer-only action that recreates just the expired vendor order snapshot: it clones the vendor order/line items, snapshots the payment method, reserves inventory again, writes a new payment intent, and emits the `order_retried` outbox event while leaving other checkout-group orders untouched (`api/controllers/orders/orders.go:426-482`; `internal/orders/service.go:462-660`; `pkg/enums/outbox.go:57-74`).
  * `pkg/checkout.ValidateMOQ` still runs as part of the service; each MOQ violation yields `pkg/errors.CodeStateConflict`/HTTP `422` with a `violations` array (`product_id`, optional `product_name`, `required_qty`, `requested_qty`) so callers can point to the offending products before checkout splits the cart (`pkg/checkout/validation.go:11-43`).

## Products
- `GET /api/v1/products` – buyer-facing listing requires `state` (only licensed/subscribed vendors in that state are returned). The controller reuses `pkg/visibility.EnsureVendorVisible` to confirm each vendor store is `kyc_status=verified`, `subscription_active=true`, and its `address.state` matches the requested `state` (plus the buyer store’s state when available); state mismatches yield `pkg/errors.CodeValidation`/HTTP `422`, while hidden vendors return `pkg/errors.CodeNotFound`/HTTP `404`, preventing cross-state or unverified leaks (`pkg/visibility/visibility.go:11-46`).
- `GET /api/v1/products/{productId}` – buyer product detail also applies `pkg/visibility.EnsureVendorVisible` so access to hidden vendors produces `404` regardless of the product ID (same helper contract as above).

## Ads (Phase 19)
- `GET /ads/serve` – publicly reachable serve point that accepts placement/state/filters, reads `status=active` ads (time window + store gating), consults Redis budget counters (`spend`, `imps`, `clicks`), selects the CPM winner via deterministic tie-breakers, and returns the creative plus signed tokens (`view_token`, `click_token`) containing `ad_id`, `buyer_store_id`, `target`, `event_type`, `expires_at` (30d) so the client can fire tracking events later (`docs/AD_ENGINE.md`:30-140).
- `POST /ads/impression` – client-provided `view_token` + `request_id` are validated (signature, expiry, store binding), deduplicated, and drive Redis counters (`imps:<adId>:<day>`, `spend:<adId>:<day>`). Duplicate deliveries are no-ops; success returns `204` so billing/pacing stays server-truth (`docs/AD_ENGINE.md`:106-144).
- `GET /ads/click` – verifies `click_token`, dedupes via `clickdedupe`, increments `clicks:<adId>:<day>`, and redirects to the advertised target while ensuring impressions/clicks never double-bill (`docs/AD_ENGINE.md`:145-170).

## Vendor
- `POST /api/v1/vendor/products` – requires auth, store context, and `Idempotency-Key` (api/middleware/idempotency.go:45-48); body accepts `sku`, `title`, `category`, `unit`, `feelings`, `flavors`, `usage`, inventory quantities, optional `media_ids`, and `volume_discounts`; the controller normalizes enums, validates required fields, and calls `internal/products.Service.CreateProduct`, which ensures the store is a vendor, the caller has one of the allowed store roles, inventory/reserved values make sense, volume discounts have unique `min_qty`, and provided media belong to the same store with `kind=product` before writing the product, inventory, discounts, and media rows in one transaction and returning the created product DTO (api/controllers/products.go:8-206; internal/products/service.go:63-204). Returns `201` on success, `400` for validation failures, `401/403` for auth/role denials, and `409` for conflicts.
- `PATCH /api/v1/vendor/products/{productId}` – requires auth + vendor store context and accepts optional metadata (`sku`, `title`, `subtitle`, `body_html`, `category`, `feelings`, `flavors`, `usage`, `strain`, `classification`, `unit`, `moq`, `price_cents`, `compare_at_price_cents`, `is_active`, `is_featured`, `thc_percent`, `cbd_percent`), plus optional `inventory`, `media_ids`, and `volume_discounts`. Inventory updates must supply both `available_qty` and `reserved_qty` (ints with `reserved_qty ≤ available_qty`), and `media_ids` are deduped while confirming each media record belongs to the same store and has `kind=product`. `controllers.VendorUpdateProduct` normalizes the payload, enforces non-empty trimmed strings, and calls `internal/products.Service.UpdateProduct`, which verifies vendor ownership/roles, ensures unique discount `min_qty`, revalidates the deduped media list, and updates the product, inventory, discounts, and media attachments inside a single transaction before returning the canonical product DTO (api/controllers/products.go:72-205; internal/products/service.go:226-355). Returns `200` on success and `400/401/403/404/409` for validation/auth errors.
- `DELETE /api/v1/vendor/products/{productId}` – requires auth + vendor store context; removes the product row owned by the active store while relying on FK cascades to clean up inventory, discounts, and attached media. `controllers.VendorDeleteProduct` validates the `productId`, store, and user contexts before calling `internal/products.Service.DeleteProduct`, which confirms the store is a vendor, the caller has an allowed role, the product belongs to that store, and then deletes it so inventory, discounts, and product media rows vanish. Returns `204` on success and `400/401/403/404` for canonical failures (api/controllers/products.go:72-244; internal/products/service.go:317-338).
- `POST /api/v1/vendor/subscriptions` – vendor-only, `StoreContext` and `StoreType=vendor` are required, `Idempotency-Key` is enforced, and the JSON body must carry `stripe_customer_id`/`stripe_payment_method_id` plus an optional `price_id`. `controllers.VendorSubscriptionCreate` calls `internal/subscriptions.Service.Create`, which defers to the billing repository + Stripe client so the first request boots the subscription, stores the metadata, sets `stores.subscription_active=true`, and returns `201`, while subsequent calls return the existing subscription with `200` so the one-active-subscription invariant holds (`api/controllers/subscriptions/vendor.go:19-120`; `internal/subscriptions/service.go:1-230`; `api/middleware/idempotency.go:37-58`).
- `POST /api/v1/vendor/subscriptions/cancel` – vendor only, idempotent (`Idempotency-Key` required), hits `internal/subscriptions.Service.Cancel` to terminate the Stripe subscription (if any), persist the cancellation row, and clear `stores.subscription_active` so the store is hidden from buyer listings. Replays succeed even when Stripe/DB already reflect `canceled` (`api/controllers/subscriptions/vendor.go:74-94`; `internal/subscriptions/service.go:170-230`; `api/middleware/idempotency.go:37-58`).
- `GET /api/v1/vendor/subscriptions` – vendor-only read that returns the single active subscription or `null` when unsubscribed by calling `internal/subscriptions.Service.GetActive`. The handler reuses the same response schema and `StoreContext` guard so clients can safely poll the current Stripe state (`api/controllers/subscriptions/vendor.go:96-154`; `internal/subscriptions/service.go:96-134`).

## Webhooks
- `POST /api/v1/webhooks/stripe` – public, verifies the `Stripe-Signature` header using the configured webhook secret, deduplicates deliveries via `internal/webhooks/stripe.IdempotencyGuard` (keys `pf:idempotency:stripe-webhook:<event_id>`/TTL `PACKFINDERZ_EVENTING_IDEMPOTENCY_TTL`), and supports `customer.subscription.created/updated/deleted` plus `invoice.paid`/`invoice.payment_failed` so `internal/webhooks/stripe.Service` can mirror Stripe’s subscription status and `stores.subscription_active` without replaying events (`api/routes/router.go:104-108`; `api/controllers/webhooks/stripe.go:13-82`; `internal/webhooks/stripe/service.go:1-178`; `internal/webhooks/stripe/idempotency.go:1-42`).

### Stores
- `GET /api/v1/stores/me` – requires active store JWT, returns `stores.StoreDTO` with company, address, owner, KYC, ratings, categories, social links (api/controllers/stores.go:21-48; internal/stores/dto.go:13-105).
- `PUT /api/v1/stores/me` – owner/manager role required, accepts `storeUpdateRequest` (company_name, description, contact, social, banner/logo, ratings, categories), returns updated `StoreDTO` (api/controllers/stores.go:51-124).
- `GET /api/v1/stores/me/users` – owner/manager only, returns `[]memberships.StoreUserDTO` with emails, role/status, last_login (api/controllers/stores.go:126-165; internal/memberships/dto.go:38-76).
- `POST /api/v1/stores/me/users/invite` – owner/manager only, requires `Idempotency-Key`, payload `{"email","first_name","last_name","role"}`, returns invited `StoreUserDTO` plus optional `temporary_password` for new accounts (api/controllers/stores.go:221-302).
- `DELETE /api/v1/stores/me/users/{userId}` – owner/manager only, deletes membership, enforces last-owner guard, returns 200 with empty body (api/controllers/stores.go:168-219).

### Media
- `GET /api/v1/media` – paginated list via optional query `limit`, `kind`, `status`, `mime_type`, `search`, returns `media.ListResult` with signed read URLs for `uploaded`/`ready` items (api/controllers/media.go:134-198; internal/media/list.go:15-139).
- `POST /api/v1/media/presign` – requires `Idempotency-Key`, body `{"media_kind","mime_type","file_name","size_bytes"}`, owner/store check, returns `media.PresignOutput` with `media_id`, `gcs_key`, signed PUT URL, and expiry (api/controllers/media.go:20-91; internal/media/service.go:94-195).
- `DELETE /api/v1/media/{mediaId}` – before mutating `media`, the controller loads `media_attachments` and rejects the request if any `entity_type` in `ProtectedAttachmentEntities` (license/ad) references the media so protected assets cannot be orphaned. Once the protection check passes, the handler emits the deletion event for downstream workers before deleting the GCS object and marking the row deleted; no attachment cleanup runs synchronously in the API. The client receives the canonical protected-attachment error (`403`/`409` depending on the implementation) when the guard fires so callers know why the deletion was blocked (api/controllers/media.go:94-132; internal/media/service.go:242-284; pkg/db/models/media_attachment.go:11-24).

### Licenses
- `POST /api/v1/licenses` – requires `Idempotency-Key`, body includes `media_id`, `issuing_state`, optional dates, `type`, `number`; media must be store-owned, kind `license_doc`, status `uploaded`/`ready`, returns structured license response (api/controllers/licenses.go:21-103; internal/licenses/service.go:51-165).
- `GET /api/v1/licenses` – accepts `limit`/`cursor`, returns `licenses.ListResult` with license metadata + signed GCS download URLs (api/controllers/licenses.go:105-144; internal/licenses/list.go:12-59).

-## Admin
-`GET /api/admin/ping` – requires Authorization bearer + role `admin`, share store context if present, no idempotency key required even though idempotency middleware is mounted (api/routes/router.go:64-81; api/controllers/ping.go:26-43).
-`POST /api/v1/admin/licenses/{licenseId}/verify` – admin-only, path parameter parsed as UUID, body `{"decision":"verified|rejected","reason"?}` drives `licenses.Service.VerifyLicense`, which enforces the license is still pending, writes the new status, emits `license_status_changed`, and returns the updated license DTO; invalid decisions or non-pending licenses are rejected with `4xx` errors (api/controllers/licenses.go:233-279; internal/licenses/service.go:382-419).
-`GET /api/v1/admin/orders/payouts` – requires Authorization + role `admin`, `limit`/`cursor` pagination; the handler calls `internal/orders.Repository.ListPayoutOrders`, which joins `vendor_orders` → `payment_intents`, filters on `status=delivered`, `payment_intents.status=settled`, and unpaid orders, orders by `delivered_at ASC, id ASC`, and returns a cursor list of `orderId`, `orderNumber`, `vendorStoreId`, `amountCents`, and `deliveredAt` (api/controllers/admin_orders.go:24-46; internal/orders/repo.go:561-620).
-`GET /api/v1/admin/orders/payouts/{orderId}` – requires Authorization + role `admin`, loads `internal/orders.Repository.FindOrderDetail`, ensures `status=delivered` and the attached `payment_intent` is `settled`, and rejects other states with `pkg.errors.CodeStateConflict` so admins can review line items, payment, and assignment info before payout (api/controllers/admin_orders.go:57-100; internal/orders/repo.go:553-596).
-`POST /api/v1/admin/orders/{orderId}/confirm-payout` – requires Authorization + role `admin`, `Idempotency-Key`, and `orderId`; validates the order is delivered with a settled payment intent, then inside the same transaction updates `payment_intents.status=paid`/`vendor_paid_at`, closes `vendor_orders.status=closed`, appends a `ledger_events(type=vendor_payout)` row, and emits the `order_paid` outbox event so downstream systems see the final payout (api/controllers/orders/orders.go:847-940; internal/ledger/service.go:22-64; pkg/enums/outbox.go:54-91).

## Agent
- `GET /api/v1/agent/ping` – requires Authorization + role `agent`, similar to admin ping. The `/api/v1/agent` group (mounted under `/api`) omits `StoreContext` (api/routes/router.go:83-101) so system agents seeded purely by `users.system_role='agent'` can run without an `activeStoreId`, and `RequireRole("agent")` (api/middleware/roles.go:1-27) rejects non-agent tokens.
- `GET /api/v1/agent/orders/queue` – requires Authorization + role `agent`, returns paginated `status=hold` vendor orders that currently lack an `active` `order_assignments` record so agents can inspect the global pickup queue. The handler accepts optional `limit`/`cursor` query params (`pagination.Params`) and the repository (internal/orders/repo.go:376-433) left joins `order_assignments` to ensure `oa.order_id IS NULL`, orders by `created_at DESC, id DESC`, and applies buffer-based cursor pagination with `LimitWithBuffer` before returning `AgentOrderQueueList`.
- `GET /api/v1/agent/orders` – requires Authorization + role `agent`, accepts optional `limit`/`cursor`, and calls `internal/orders.Repository.ListAssignedOrders` (internal/orders/repo.go:376-550). The query joins `vendor_orders` → `order_assignments` (active = true), filters on the caller’s `agent_user_id`, orders by `created_at DESC, id DESC`, and uses `LimitWithBuffer`/cursor encoding to return an `AgentOrderQueueList` that only contains the agent’s active assignments (api/controllers/agent_assigned_orders.go:9-58; internal/orders/repo.go:376-550).
- `GET /api/v1/agent/orders/{orderId}` – requires Authorization + role `agent`, loads `internal/orders.Repository.FindOrderDetail` (internal/orders/repo.go:553-596), and rejects the request if the resolved `ActiveAssignment` is nil or the agent_id differs from the caller; the response mirrors the shared `OrderDetail` payload (line items, payment intent, buyer/vendor metadata) only when the agent owns the order (api/controllers/agent_assigned_orders.go:60-109; internal/orders/repo.go:553-596).
- `POST /api/v1/agent/orders/{orderId}/pickup` – requires Authorization + role `agent`, uses `internal/orders.Service.AgentPickup` so assigned agents can mark an order as `in_transit`, timestamps `order_assignments.pickup_time`, and keeps the call idempotent when repeated after success (api/controllers/agent_assigned_orders.go:118-150; internal/orders/service.go:641-712).
- `POST /api/v1/agent/orders/{orderId}/deliver` – requires Authorization + role `agent`, `Idempotency-Key`, and an empty body; `controllers.AgentDeliverOrder` reads the JWT user ID, calls `internal/orders.Service.AgentDeliver` (internal/orders/service.go:724-778), and the service loads `FindOrderDetail` to ensure the active assignment belongs to the caller, rejects states outside `in_transit|delivered` with `pkg.errors.CodeStateConflict`/HTTP `422`, promotes `vendor_orders.status`/`vendor_orders.shipping_status` to `delivered`, records `vendor_orders.delivered_at`, and sets `order_assignments.delivery_time` (only once) so replayed calls no-op once the timestamps exist (api/controllers/agent_assigned_orders.go:151-202; internal/orders/service.go:724-778; pkg/migrate/migrations/20260129000000_add_order_assignment_meta.sql).
